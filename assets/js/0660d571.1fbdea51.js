"use strict";(globalThis.webpackChunkiowarp_site=globalThis.webpackChunkiowarp_site||[]).push([[9470],{4476:(e,s,r)=>{r.r(s),r.d(s,{default:()=>t});r(6540);var i=r(72),n=r(4848);function t(){return(0,n.jsxs)(i.N,{title:"Jarvis CI/CD Framework",path:"/platform/tooling/jarvis",description:"Reproducible HPC deployment in under 2 minutes with 100% success rate. Natural language automation for scientific computing.",children:[(0,n.jsx)("h1",{children:"Jarvis CI/CD Framework"}),(0,n.jsx)("p",{className:"mb-6 text-lg italic",children:"Reproducible HPC deployment in under 2 minutes with 100% success rate"}),(0,n.jsx)("h2",{children:"Overview"}),(0,n.jsxs)("p",{children:["Jarvis is a CI/CD framework that solves HPC deployment complexity through ",(0,n.jsx)("strong",{children:"natural language automation"}),". Instead of hours spent configuring environments, writing job scripts, and debugging scheduler submissions, researchers describe what they want in plain English or YAML and Jarvis handles environment discovery, package resolution, build configuration, job script generation, and execution monitoring. Deployment times range from ",(0,n.jsx)("strong",{children:"25 to 109 seconds"})," depending on agent configuration, with ",(0,n.jsx)("strong",{children:"100% success across 20 diverse prompts"})," in production testing."]}),(0,n.jsxs)("p",{children:["The framework introduces a ",(0,n.jsx)("strong",{children:"Package abstraction"}),"\u2014a unified way to define applications (WRF, LAMMPS, IOR), systems (IOWarp, OrangeFS), and libraries (profilers, debuggers). Packages combine into pipelines specified via CLI or YAML, automatically adapting to cluster-specific configurations through a ",(0,n.jsx)("strong",{children:"per-cluster resource graph"})," that captures hardware, software, and scheduler details. This enables one-command reproducibility: share a package definition instead of pages of documentation."]}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Package Abstraction"}),(0,n.jsxs)("p",{children:["A ",(0,n.jsx)("strong",{children:"Package"})," is Jarvis's core abstraction for defining any deployable component. Packages encapsulate everything needed to build, configure, and run software on HPC systems."]}),(0,n.jsxs)("table",{children:[(0,n.jsx)("thead",{children:(0,n.jsxs)("tr",{children:[(0,n.jsx)("th",{children:"Package Type"}),(0,n.jsx)("th",{children:"Examples"}),(0,n.jsx)("th",{children:"Purpose"})]})}),(0,n.jsxs)("tbody",{children:[(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"Applications"})}),(0,n.jsx)("td",{children:"IOR, WRF, LAMMPS, HACC"}),(0,n.jsx)("td",{children:"Scientific applications and benchmarks"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"Systems"})}),(0,n.jsx)("td",{children:"IOWarp, OrangeFS, Lustre"}),(0,n.jsx)("td",{children:"Storage systems and middleware"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"Libraries"})}),(0,n.jsx)("td",{children:"MPI, ADIOS2, HDF5"}),(0,n.jsx)("td",{children:"Dependencies and runtime libraries"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"Tools"})}),(0,n.jsx)("td",{children:"Darshan, TAU, VTune"}),(0,n.jsx)("td",{children:"Profilers, debuggers, analyzers"})]})]})]}),(0,n.jsx)("p",{className:"mt-4",children:"Each package defines build instructions, dependencies, configuration parameters, execution templates, and post-processing scripts. Packages can reference other packages, creating dependency graphs that Jarvis automatically resolves."}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Per-Cluster Resource Graphs"}),(0,n.jsxs)("p",{children:["Jarvis maintains a ",(0,n.jsx)("strong",{children:"resource graph"})," for each cluster capturing hardware topology (node counts, CPU/GPU specs, interconnect), software environment (module systems, compilers, libraries), scheduler configuration (Slurm, PBS, LSF parameters), and storage infrastructure (parallel file systems, scratch spaces). When deploying a package, Jarvis queries this graph to automatically adapt configurations\u2014selecting appropriate modules, generating correct job scripts, allocating resources efficiently, and configuring paths and environment variables."]}),(0,n.jsx)("p",{children:"This eliminates manual porting. A package defined on one cluster automatically deploys to another, with Jarvis handling all cluster-specific adaptations. New team members deploy working environments immediately without learning cluster quirks."}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Deployment Performance"}),(0,n.jsxs)("table",{children:[(0,n.jsx)("thead",{children:(0,n.jsxs)("tr",{children:[(0,n.jsx)("th",{children:"Configuration"}),(0,n.jsx)("th",{children:"Avg Time"}),(0,n.jsx)("th",{children:"Success Rate"}),(0,n.jsx)("th",{children:"Key Characteristics"})]})}),(0,n.jsxs)("tbody",{children:[(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"OpenCode + Devstral"})}),(0,n.jsx)("td",{children:"24.8s"}),(0,n.jsx)("td",{children:"100%"}),(0,n.jsx)("td",{children:"Local LLM execution, fastest"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"Cursor + GPT-4o"})}),(0,n.jsx)("td",{children:"37.7s"}),(0,n.jsx)("td",{children:"85%"}),(0,n.jsx)("td",{children:"Cloud-based, struggles with parameter synonyms"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"Gemini CLI + Gemini 2.5 Pro"})}),(0,n.jsx)("td",{children:"85.9s"}),(0,n.jsx)("td",{children:"100%"}),(0,n.jsx)("td",{children:"Robust across variations"})]}),(0,n.jsxs)("tr",{children:[(0,n.jsx)("td",{children:(0,n.jsx)("strong",{children:"Claude Code + Sonnet 4"})}),(0,n.jsx)("td",{children:"109.2s"}),(0,n.jsx)("td",{children:"100%"}),(0,n.jsx)("td",{children:"Most thorough, 100% reliability"})]})]})]}),(0,n.jsxs)("p",{className:"mt-6",children:['Testing deployed the IOR parallel I/O benchmark using eight different agent-model configurations, each tested with five diverse prompts ranging from terse commands like "Deploy ior with 8 processes" to detailed bash scripts. The standout result: ',(0,n.jsx)("strong",{children:"configurations using small local LLMs for execution (like Devstral) matched or beat large cloud models"})," in both speed and accuracy. This validates IOWarp's split planning-execution architecture\u2014use powerful models to understand intent, then execute locally for speed, cost reduction, and data security."]}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Deployment Workflow"}),(0,n.jsx)("p",{children:"A typical Jarvis deployment progresses through five phases:"}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"(1) Environment Discovery"})," \u2014 Query cluster configuration via resource graph, discover available compute nodes and hardware specs, inventory software modules and compilers, and determine scheduler type and configuration."]}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"(2) Package Resolution"}),' \u2014 Map user request (e.g., "ior") to package definition, resolve dependency graph (MPI, I/O libraries, etc.), verify all dependencies are available or can be built, and determine build order.']}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"(3) Build and Configuration"})," \u2014 Load required software modules, compile packages if needed with cluster-specific flags, generate hostfiles for distributed execution, and configure runtime environment variables."]}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"(4) Job Script Generation"})," \u2014 Create Slurm/PBS/LSF submission script, set appropriate resource requests (nodes, tasks, time), configure job output and error logging, and add package-specific execution commands."]}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"(5) Execution and Monitoring"})," \u2014 Submit job to scheduler, track job status (queued, running, completed), collect stdout/stderr output, and gather results for analysis."]}),(0,n.jsx)("p",{children:"All of this happens automatically from a single natural language prompt or YAML specification. Manual deployment of the same workflow typically requires 30+ minutes for repeat deployments and hours for first-time setup."}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Jarvis MCP Integration"}),(0,n.jsxs)("p",{children:["Jarvis exposes its capabilities through a ",(0,n.jsx)("strong",{children:"Model Context Protocol (MCP) server"})," with 25+ tools, enabling AI agents to autonomously deploy and manage HPC workloads. The Jarvis MCP provides package management operations (list, install, configure, remove), pipeline orchestration (define multi-package workflows), execution control (submit, monitor, cancel jobs), resource queries (available nodes, scheduler status), and result collection (gather outputs, parse logs)."]}),(0,n.jsxs)("p",{children:["This enables natural language workflows like: ",(0,n.jsx)("em",{children:'"Deploy IOR benchmark with 8 processes on 2 nodes, then run Darshan profiling and generate a performance report."'})," The agent uses Jarvis MCP to install IOR package, resolve MPI dependencies, install Darshan profiler, generate hostfile for 2 nodes, create job script with 8 MPI tasks, submit to scheduler, monitor execution, collect Darshan logs, and parse results into report. Complete end-to-end automation in minutes."]}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Use Cases"}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"Materials Science Workflows"})," \u2014 Orchestrate end-to-end pipelines from additive manufacturing diagnostics through X-ray microscopy to mechanical testing. Jarvis deploys reconstruction software, DIC analysis tools, and visualization applications with IOWarp storage configuration across ~100GB per specimen."]}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"I/O Benchmarking"})," \u2014 Rapidly deploy IOR, VPIC-IO, HACC-IO, or custom benchmarks across different configurations. Test parameter sweeps (block sizes, transfer patterns) without manual job script editing. Automated result collection enables systematic performance analysis."]}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"Simulation Campaigns"})," \u2014 Deploy LAMMPS molecular dynamics, WRF weather modeling, or HACC cosmological simulations. Package definitions include input deck templates, post-processing scripts, and visualization pipelines. Enables reproducible simulation studies across research groups."]}),(0,n.jsxs)("p",{children:[(0,n.jsx)("strong",{children:"System Software Testing"})," \u2014 Deploy and test IOWarp, OrangeFS, or other storage systems across different cluster configurations. Automatically configure client libraries, mount points, and test applications. Streamlines validation across diverse environments."]}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Architecture"}),(0,n.jsx)("pre",{children:(0,n.jsx)("code",{children:"User Request (Natural Language or YAML)\n          \u2193\n    Jarvis Agent (MCP Interface)\n          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        \u2502\n\u2502  Resource Graph Query  \u2502\n\u2502  Package Resolution    \u2502\n\u2502  Dependency Management \u2502\n\u2502  Build Orchestration   \u2502\n\u2502  Job Script Generation \u2502\n\u2502  Execution Monitoring  \u2502\n\u2502                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2193\n    Cluster Infrastructure\n    (Scheduler, Modules, Storage)"})}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Impact"}),(0,n.jsxs)("p",{children:["Jarvis transforms HPC deployment from an error-prone manual process requiring specialized expertise into a ",(0,n.jsx)("strong",{children:"fast, reproducible, natural language-driven workflow"}),". Researchers deploy complex simulations and benchmarks in under two minutes with perfect reliability. The split planning-execution architecture proves that local LLMs can handle execution while reserving expensive cloud models for planning, achieving the trifecta of speed, cost efficiency, and data security."]}),(0,n.jsxs)("p",{children:["Beyond individual deployments, Jarvis's package abstraction enables ",(0,n.jsx)("strong",{children:"one-command reproducibility"}),": share a package definition instead of pages of documentation. New team members deploy working environments immediately. Cross-cluster portability becomes automatic through per-cluster resource graphs. This democratizes HPC access, reduces time-to-science, and enables systematic exploration of parameter spaces that would be prohibitively tedious with manual deployment."]}),(0,n.jsx)("hr",{}),(0,n.jsx)("h2",{children:"Learn More"}),(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"/research/demos/jarvis-deployment",children:"Jarvis Deployment Demo"})}),(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"/research/demos/material-science",children:"Material Science Workflow"})}),(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"/platform/tooling/agent-toolkit",children:"Agent Toolkit (includes Jarvis MCP)"})}),(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"https://github.com/grc-iit/jarvis-cd",children:"Jarvis GitHub Repository"})}),(0,n.jsx)("li",{children:(0,n.jsx)("a",{href:"https://github.com/iowarp/iowarp-mcps",children:"IOWarp MCPs"})})]})]})}}}]);