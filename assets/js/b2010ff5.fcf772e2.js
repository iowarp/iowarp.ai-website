"use strict";(globalThis.webpackChunkiowarp_site=globalThis.webpackChunkiowarp_site||[]).push([[1719],{8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},8461:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"sdk/runtime_modules","title":"Chimaera Module Development Guide","description":"Linking","source":"@site/docs/sdk/2.runtime_modules.md","sourceDirName":"sdk","slug":"/sdk/runtime_modules","permalink":"/docs/sdk/runtime_modules","draft":false,"unlisted":false,"editUrl":"https://github.com/iowarp/iowarp.github.io/tree/main/docs/sdk/2.runtime_modules.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Hermes Shared Memory (CTE)","permalink":"/docs/sdk/interprocess"},"next":{"title":"Context Transfer SDK","permalink":"/docs/sdk/context_transfer"}}');var r=i(4848),t=i(8453);const a={},l="Chimaera Module Development Guide",o={},c=[{value:"Linking",id:"linking",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Core Principles",id:"core-principles",level:3},{value:"Key Components",id:"key-components",level:3},{value:"Coding Style",id:"coding-style",level:2},{value:"General Guidelines",id:"general-guidelines",level:3},{value:"Code Formatting",id:"code-formatting",level:3},{value:"Module Structure",id:"module-structure",level:2},{value:"Task Definition (MOD_NAME_tasks.h)",id:"task-definition-mod_name_tasksh",level:3},{value:"Client Implementation (MOD_NAME_client.h/cc)",id:"client-implementation-mod_name_clienthcc",level:3},{value:"ChiMod CreateTask Pool Assignment Requirements",id:"chimod-createtask-pool-assignment-requirements",level:3},{value:"Why This is Required",id:"why-this-is-required",level:4},{value:"Correct Usage",id:"correct-usage",level:4},{value:"Incorrect Usage",id:"incorrect-usage",level:4},{value:"Key Points",id:"key-points",level:4},{value:"ChiMod Name Requirements",id:"chimod-name-requirements",level:3},{value:"Correct Usage",id:"correct-usage-1",level:4},{value:"Incorrect Usage",id:"incorrect-usage-1",level:4},{value:"Why This is Required",id:"why-this-is-required-1",level:4},{value:"Implementation Pattern",id:"implementation-pattern",level:4},{value:"Runtime Container (MOD_NAME_runtime.h/cc)",id:"runtime-container-mod_name_runtimehcc",level:3},{value:"Execution Modes and Dynamic Scheduling",id:"execution-modes-and-dynamic-scheduling",level:3},{value:"ExecMode Overview",id:"execmode-overview",level:4},{value:"kExec Mode (Default)",id:"kexec-mode-default",level:4},{value:"kDynamicSchedule Mode",id:"kdynamicschedule-mode",level:4},{value:"Example: GetOrCreatePool with Dynamic Scheduling",id:"example-getorcreatepool-with-dynamic-scheduling",level:4},{value:"Using Dynamic() PoolQuery",id:"using-dynamic-poolquery",level:4},{value:"Benefits of Dynamic Scheduling",id:"benefits-of-dynamic-scheduling",level:4},{value:"Implementation Guidelines",id:"implementation-guidelines",level:4},{value:"Worker Implementation Details",id:"worker-implementation-details",level:4},{value:"Configuration and Code Generation",id:"configuration-and-code-generation",level:2},{value:"Overview",id:"overview-1",level:3},{value:"chimaera_repo.yaml",id:"chimaera_repoyaml",level:3},{value:"chimaera_mod.yaml",id:"chimaera_modyaml",level:3},{value:"chi_refresh_repo Utility",id:"chi_refresh_repo-utility",level:3},{value:"Usage",id:"usage",level:4},{value:"Generated Files",id:"generated-files",level:4},{value:"When to Run chi_refresh_repo",id:"when-to-run-chi_refresh_repo",level:4},{value:"Important Notes",id:"important-notes",level:4},{value:"Workflow Summary",id:"workflow-summary",level:3},{value:"Task Development",id:"task-development",level:2},{value:"Task Requirements",id:"task-requirements",level:3},{value:"Optional Task Methods: Copy and Aggregate",id:"optional-task-methods-copy-and-aggregate",level:3},{value:"Copy Method",id:"copy-method",level:4},{value:"Aggregate Method",id:"aggregate-method",level:4},{value:"When to Implement Copy and Aggregate",id:"when-to-implement-copy-and-aggregate",level:4},{value:"Copy/Aggregate Usage in Networking",id:"copyaggregate-usage-in-networking",level:4},{value:"Complete Example: ReadTask with Copy and Aggregate",id:"complete-example-readtask-with-copy-and-aggregate",level:4},{value:"Task Naming Conventions",id:"task-naming-conventions",level:3},{value:"Required Naming Pattern",id:"required-naming-pattern",level:4},{value:"Examples",id:"examples",level:4},{value:"Naming Rules",id:"naming-rules",level:4},{value:"Backward Compatibility",id:"backward-compatibility",level:4},{value:"Benefits of Consistent Naming",id:"benefits-of-consistent-naming",level:4},{value:"Method System and Auto-Generated Files",id:"method-system-and-auto-generated-files",level:3},{value:"Method Definitions (autogen/MOD_NAME_methods.h)",id:"method-definitions-autogenmod_name_methodsh",level:4},{value:"BaseCreateTask Template System",id:"basecreatetask-template-system",level:4},{value:"GetOrCreatePoolTask vs BaseCreateTask Usage",id:"getorcreatepooltask-vs-basecreatetask-usage",level:5},{value:"BaseCreateTask Template Parameters",id:"basecreatetask-template-parameters",level:4},{value:"BaseCreateTask Structure",id:"basecreatetask-structure",level:4},{value:"Usage Examples",id:"usage-examples",level:4},{value:"Migration from Custom CreateTask",id:"migration-from-custom-createtask",level:4},{value:"Data Annotations",id:"data-annotations",level:3},{value:"Task Lifecycle",id:"task-lifecycle",level:3},{value:"Framework Del Implementation",id:"framework-del-implementation",level:3},{value:"Synchronization Primitives",id:"synchronization-primitives",level:2},{value:"Why Use Chimaera Synchronization Primitives?",id:"why-use-chimaera-synchronization-primitives",level:3},{value:"CoMutex: Cooperative Mutual Exclusion",id:"comutex-cooperative-mutual-exclusion",level:3},{value:"Basic Usage",id:"basic-usage",level:4},{value:"Key Features",id:"key-features",level:4},{value:"API Reference",id:"api-reference",level:4},{value:"CoRwLock: Cooperative Reader-Writer Lock",id:"corwlock-cooperative-reader-writer-lock",level:3},{value:"Basic Usage",id:"basic-usage-1",level:4},{value:"Key Features",id:"key-features-1",level:4},{value:"API Reference",id:"api-reference-1",level:4},{value:"TaskId Grouping Behavior",id:"taskid-grouping-behavior",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Example: Module with Synchronized Data Structure",id:"example-module-with-synchronized-data-structure",level:3},{value:"Pool Query and Task Routing",id:"pool-query-and-task-routing",level:2},{value:"Overview of PoolQuery",id:"overview-of-poolquery",level:3},{value:"PoolQuery Types",id:"poolquery-types",level:3},{value:"1. Local Mode",id:"1-local-mode",level:4},{value:"2. Direct ID Mode",id:"2-direct-id-mode",level:4},{value:"3. Direct Hash Mode",id:"3-direct-hash-mode",level:4},{value:"4. Range Mode",id:"4-range-mode",level:4},{value:"5. Broadcast Mode",id:"5-broadcast-mode",level:4},{value:"6. Physical Mode",id:"6-physical-mode",level:4},{value:"7. Dynamic Mode (Recommended for Create Operations)",id:"7-dynamic-mode-recommended-for-create-operations",level:4},{value:"PoolQuery Usage Guidelines",id:"poolquery-usage-guidelines",level:3},{value:"Best Practices",id:"best-practices-1",level:4},{value:"Common Patterns",id:"common-patterns",level:4},{value:"Runtime Routing Implementation",id:"runtime-routing-implementation",level:3},{value:"PoolQuery in Task Definitions",id:"poolquery-in-task-definitions",level:3},{value:"Advanced PoolQuery Features",id:"advanced-poolquery-features",level:3},{value:"Query Introspection",id:"query-introspection",level:4},{value:"Combining with Task Priorities",id:"combining-with-task-priorities",level:4},{value:"Troubleshooting PoolQuery Issues",id:"troubleshooting-poolquery-issues",level:3},{value:"Client-Server Communication",id:"client-server-communication",level:2},{value:"Client Implementation Patterns",id:"client-implementation-patterns",level:3},{value:"Critical Pool ID Update Pattern",id:"critical-pool-id-update-pattern",level:4},{value:"Memory Segments",id:"memory-segments",level:3},{value:"IPC Queue",id:"ipc-queue",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"Allocator Usage",id:"allocator-usage",level:3},{value:"Best Practices",id:"best-practices-2",level:3},{value:"Task Allocation and Deallocation Pattern",id:"task-allocation-and-deallocation-pattern",level:3},{value:"CHI_IPC Buffer Allocation",id:"chi_ipc-buffer-allocation",level:3},{value:"Basic Usage",id:"basic-usage-2",level:4},{value:"Use Cases for CHI_IPC Buffers",id:"use-cases-for-chi_ipc-buffers",level:4},{value:"Best Practices",id:"best-practices-3",level:4},{value:"Shared-Memory Compatible Data Structures",id:"shared-memory-compatible-data-structures",level:3},{value:"chi::ipc::string",id:"chiipcstring",level:4},{value:"chi::ipc::vector",id:"chiipcvector",level:4},{value:"When to Use Each Type",id:"when-to-use-each-type",level:4},{value:"Type Conversion Examples",id:"type-conversion-examples",level:4},{value:"Serialization Support",id:"serialization-support",level:4},{value:"Bulk Transfer Support with ar.bulk",id:"bulk-transfer-support-with-arbulk",level:3},{value:"Overview",id:"overview-2",level:4},{value:"Bulk Transfer Flags",id:"bulk-transfer-flags",level:4},{value:"Basic Usage Pattern",id:"basic-usage-pattern",level:4},{value:"Write Operation (Sender Has Data)",id:"write-operation-sender-has-data",level:5},{value:"Read Operation (Receiver Needs Data)",id:"read-operation-receiver-needs-data",level:5},{value:"API Reference",id:"api-reference-2",level:4},{value:"Advanced Pattern: Bidirectional Transfer",id:"advanced-pattern-bidirectional-transfer",level:4},{value:"Integration with Lightbeam",id:"integration-with-lightbeam",level:4},{value:"Complete Example: BDev Read Task",id:"complete-example-bdev-read-task",level:4},{value:"Best Practices",id:"best-practices-4",level:4},{value:"Performance Considerations",id:"performance-considerations",level:4},{value:"Troubleshooting",id:"troubleshooting",level:4},{value:"chi::unordered_map_ll - Lock-Free Unordered Map",id:"chiunordered_map_ll---lock-free-unordered-map",level:3},{value:"Overview",id:"overview-3",level:4},{value:"Basic Usage",id:"basic-usage-3",level:4},{value:"Constructor",id:"constructor",level:4},{value:"API Reference",id:"api-reference-3",level:4},{value:"Return Value Semantics",id:"return-value-semantics",level:4},{value:"External Locking Patterns",id:"external-locking-patterns",level:4},{value:"When to Use chi::unordered_map_ll",id:"when-to-use-chiunordered_map_ll",level:4},{value:"Performance Considerations",id:"performance-considerations-1",level:4},{value:"Complete Example: Request Tracking Module",id:"complete-example-request-tracking-module",level:4},{value:"Key Differences from std::unordered_map",id:"key-differences-from-stdunordered_map",level:4},{value:"Summary",id:"summary",level:4},{value:"Build System Integration",id:"build-system-integration",level:2},{value:"CMakeLists.txt Template",id:"cmakeliststxt-template",level:3},{value:"CMakeLists.txt Guidelines",id:"cmakeliststxt-guidelines",level:3},{value:"ChiMod Build Functions Reference",id:"chimod-build-functions-reference",level:3},{value:"<code>add_chimod_client()</code> Function",id:"add_chimod_client-function",level:4},{value:"<code>add_chimod_runtime()</code> Function",id:"add_chimod_runtime-function",level:4},{value:"Configuration Requirements",id:"configuration-requirements",level:4},{value:"Typical Usage Pattern",id:"typical-usage-pattern",level:4},{value:"Target Naming and Linking",id:"target-naming-and-linking",level:3},{value:"Target Format",id:"target-format",level:4},{value:"Automatic Dependencies",id:"automatic-dependencies",level:3},{value:"Targets Created by ChiMod Functions",id:"targets-created-by-chimod-functions",level:3},{value:"Target Naming System",id:"target-naming-system",level:4},{value:"Runtime Target: <code>${NAMESPACE}_${CHIMOD_NAME}_runtime</code>",id:"runtime-target-namespace_chimod_name_runtime",level:4},{value:"Client Target: <code>${NAMESPACE}_${CHIMOD_NAME}_client</code>",id:"client-target-namespace_chimod_name_client",level:4},{value:"Namespace Configuration",id:"namespace-configuration",level:4},{value:"Example Output Files",id:"example-output-files",level:4},{value:"Using the Targets",id:"using-the-targets",level:4},{value:"Module Configuration (chimaera_mod.yaml)",id:"module-configuration-chimaera_modyaml",level:3},{value:"Auto-Generated Method Files",id:"auto-generated-method-files",level:3},{value:"Runtime Entry Points",id:"runtime-entry-points",level:3},{value:"Auto-Generated Code Pattern",id:"auto-generated-code-pattern",level:2},{value:"Overview",id:"overview-4",level:3},{value:"New Pattern: Auto-Generated Source Files",id:"new-pattern-auto-generated-source-files",level:3},{value:"File Structure",id:"file-structure",level:3},{value:"Auto-Generated Source Template",id:"auto-generated-source-template",level:3},{value:"Runtime Implementation Changes",id:"runtime-implementation-changes",level:3},{value:"Before (Old Pattern):",id:"before-old-pattern",level:4},{value:"After (New Pattern):",id:"after-new-pattern",level:4},{value:"CMake Integration",id:"cmake-integration",level:3},{value:"Benefits of the New Pattern",id:"benefits-of-the-new-pattern",level:3},{value:"Migration Guide",id:"migration-guide",level:3},{value:"Important Notes",id:"important-notes-1",level:3},{value:"External ChiMod Development",id:"external-chimod-development",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"External ChiMod Repository Structure",id:"external-chimod-repository-structure",level:3},{value:"Repository Configuration (chimaera_repo.yaml)",id:"repository-configuration-chimaera_repoyaml",level:3},{value:"Root CMakeLists.txt",id:"root-cmakeliststxt",level:3},{value:"ChiMod CMakeLists.txt",id:"chimod-cmakeliststxt",level:3},{value:"External Applications Using Your ChiMod",id:"external-applications-using-your-chimod",level:3},{value:"External ChiMod Implementation",id:"external-chimod-implementation",level:3},{value:"CreateParams Configuration",id:"createparams-configuration",level:4},{value:"C++ Namespace",id:"c-namespace",level:4},{value:"Building External ChiMods",id:"building-external-chimods",level:3},{value:"Usage in Applications",id:"usage-in-applications",level:3},{value:"CHIMAERA_RUNTIME_INIT for Testing and Benchmarks",id:"chimaera_runtime_init-for-testing-and-benchmarks",level:3},{value:"Dependencies and Installation Paths",id:"dependencies-and-installation-paths",level:3},{value:"Common External Development Issues",id:"common-external-development-issues",level:3},{value:"External ChiMod Checklist",id:"external-chimod-checklist",level:3},{value:"Example Module",id:"example-module",level:2},{value:"Creating a New Module",id:"creating-a-new-module",level:3},{value:"Recent Changes and Best Practices",id:"recent-changes-and-best-practices",level:2},{value:"Container Initialization Pattern",id:"container-initialization-pattern",level:3},{value:"Framework-Managed Task Cleanup",id:"framework-managed-task-cleanup",level:3},{value:"Simplified ChiMod Entry Points",id:"simplified-chimod-entry-points",level:3},{value:"FullPtr Parameter Pattern",id:"fullptr-parameter-pattern",level:3},{value:"Migration Guide",id:"migration-guide-1",level:3},{value:"Custom Namespace Configuration",id:"custom-namespace-configuration",level:2},{value:"Overview",id:"overview-5",level:3},{value:"Configuring Custom Namespace",id:"configuring-custom-namespace",level:3},{value:"Required Changes for Custom Namespace",id:"required-changes-for-custom-namespace",level:3},{value:"1. <strong>CreateParams chimod_lib_name</strong>",id:"1-createparams-chimod_lib_name",level:4},{value:"2. <strong>Module Namespace Declaration</strong>",id:"2-module-namespace-declaration",level:4},{value:"3. <strong>CMake Library Names</strong>",id:"3-cmake-library-names",level:4},{value:"4. <strong>Runtime Integration</strong>",id:"4-runtime-integration",level:4},{value:"Checklist for Custom Namespace",id:"checklist-for-custom-namespace",level:3},{value:"Example: Complete Custom Namespace Module",id:"example-complete-custom-namespace-module",level:3},{value:"Important Notes",id:"important-notes-2",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Task Scheduling",id:"task-scheduling",level:3},{value:"Automatic Routing Architecture",id:"automatic-routing-architecture",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Debugging Tips",id:"debugging-tips",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Performance Considerations",id:"performance-considerations-2",level:2},{value:"Unit Testing",id:"unit-testing",level:2},{value:"Quick Reference Checklist",id:"quick-reference-checklist",level:2},{value:"Task Definition Checklist (<code>_tasks.h</code>)",id:"task-definition-checklist-_tasksh",level:3},{value:"Runtime Container Checklist (<code>_runtime.h/cc</code>)",id:"runtime-container-checklist-_runtimehcc",level:3},{value:"Client API Checklist (<code>_client.h/cc</code>)",id:"client-api-checklist-_clienthcc",level:3},{value:"Build System Checklist",id:"build-system-checklist",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Pool Name Requirements",id:"pool-name-requirements",level:2},{value:"Why Pool Names Are Required",id:"why-pool-names-are-required",level:3},{value:"Pool Naming Guidelines",id:"pool-naming-guidelines",level:3},{value:"Correct Pool Naming Usage",id:"correct-pool-naming-usage",level:3},{value:"Incorrect Pool Naming Usage",id:"incorrect-pool-naming-usage",level:3},{value:"Client Interface Pattern",id:"client-interface-pattern",level:3},{value:"BDev-Specific Requirements",id:"bdev-specific-requirements",level:3},{value:"Compose Configuration Feature",id:"compose-configuration-feature",level:2},{value:"CreateParams LoadConfig Requirement",id:"createparams-loadconfig-requirement",level:3},{value:"Compose Configuration Format",id:"compose-configuration-format",level:3},{value:"Usage Modes",id:"usage-modes",level:3},{value:"Implementation Checklist",id:"implementation-checklist",level:3},{value:"Example Admin ChiMod LoadConfig",id:"example-admin-chimod-loadconfig",level:3},{value:"Example BDev ChiMod LoadConfig",id:"example-bdev-chimod-loadconfig",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chimaera-module-development-guide",children:"Chimaera Module Development Guide"})}),"\n",(0,r.jsx)(n.h2,{id:"linking",children:"Linking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"find_package(iowarp-core CONFIG)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#architecture",children:"Architecture"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#coding-style",children:"Coding Style"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#module-structure",children:"Module Structure"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#task-definition-mod_name_tasksh",children:"Task Definition"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#client-implementation-mod_name_clienthcc",children:"Client Implementation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#runtime-container-mod_name_runtimehcc",children:"Runtime Container"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#execution-modes-and-dynamic-scheduling",children:"Execution Modes and Dynamic Scheduling"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#configuration-and-code-generation",children:"Configuration and Code Generation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#task-development",children:"Task Development"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#synchronization-primitives",children:"Synchronization Primitives"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pool-query-and-task-routing",children:"Pool Query and Task Routing"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#client-server-communication",children:"Client-Server Communication"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#memory-management",children:"Memory Management"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#chi_client-buffer-allocation",children:"CHI_CLIENT Buffer Allocation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#shared-memory-compatible-data-structures",children:"Shared-Memory Compatible Data Structures"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#build-system-integration",children:"Build System Integration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#external-chimod-development",children:"External ChiMod Development"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#example-module",children:"Example Module"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Chimaera modules (ChiMods) are dynamically loadable components that extend the runtime with new functionality. Each module consists of:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client library"}),": Minimal code for task submission from user processes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime library"}),": Server-side execution logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task definitions"}),": Shared structures for client-server communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration"}),": YAML metadata describing the module"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Header Organization"}),": All ChiMod headers are organized under the namespace directory structure (",(0,r.jsx)(n.code,{children:"include/[namespace]/[module_name]/"}),") to provide clear namespace separation and prevent header conflicts."]}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"core-principles",children:"Core Principles"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client-Server Separation"}),": Clients only submit tasks; runtime handles all logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shared Memory Communication"}),": Tasks are allocated in shared memory segments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task-Based Processing"}),": All operations are expressed as tasks with methods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero-Copy Design"}),": Data stays in shared memory; only pointers are passed"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-components",children:"Key Components"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"ChiMod/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 [namespace]/\n\u2502       \u2514\u2500\u2500 MOD_NAME/\n\u2502           \u251c\u2500\u2500 MOD_NAME_client.h     # Client API\n\u2502           \u251c\u2500\u2500 MOD_NAME_runtime.h    # Runtime container\n\u2502           \u251c\u2500\u2500 MOD_NAME_tasks.h      # Task definitions\n\u2502           \u2514\u2500\u2500 autogen/\n\u2502               \u2514\u2500\u2500 MOD_NAME_methods.h    # Method constants\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 MOD_NAME_client.cc        # Client implementation\n\u2502   \u251c\u2500\u2500 MOD_NAME_runtime.cc       # Runtime implementation\n\u2502   \u2514\u2500\u2500 autogen/\n\u2502       \u2514\u2500\u2500 MOD_NAME_lib_exec.cc  # Auto-generated virtual method implementations\n\u251c\u2500\u2500 chimaera_mod.yaml              # Module configuration\n\u2514\u2500\u2500 CMakeLists.txt                 # Build configuration\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Include Directory Structure:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All ChiMod headers are organized under the namespace directory"}),"\n",(0,r.jsxs)(n.li,{children:["Structure: ",(0,r.jsx)(n.code,{children:"include/[namespace]/[module_name]/"})]}),"\n",(0,r.jsxs)(n.li,{children:["Example: Admin headers are in ",(0,r.jsx)(n.code,{children:"include/[namespace]/admin/"})," (where ",(0,r.jsx)(n.code,{children:"[namespace]"})," is the namespace from ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Headers follow naming pattern: ",(0,r.jsx)(n.code,{children:"[module_name]_[type].h"})]}),"\n",(0,r.jsxs)(n.li,{children:["Auto-generated headers are in the ",(0,r.jsx)(n.code,{children:"autogen/"})," subdirectory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": The namespace comes from ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"})," and the chimod directory name doesn't need to match the namespace"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"coding-style",children:"Coding Style"}),"\n",(0,r.jsx)(n.h3,{id:"general-guidelines",children:"General Guidelines"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Namespace"}),": All module code under ",(0,r.jsx)(n.code,{children:"chimaera::MOD_NAME"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Naming Conventions"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Classes: ",(0,r.jsx)(n.code,{children:"PascalCase"})," (e.g., ",(0,r.jsx)(n.code,{children:"CustomTask"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Methods: ",(0,r.jsx)(n.code,{children:"PascalCase"})," for public, ",(0,r.jsx)(n.code,{children:"camelCase"})," for private"]}),"\n",(0,r.jsxs)(n.li,{children:["Variables: ",(0,r.jsx)(n.code,{children:"snake_case_"})," with trailing underscore for members"]}),"\n",(0,r.jsxs)(n.li,{children:["Constants: ",(0,r.jsx)(n.code,{children:"kConstantName"})]}),"\n",(0,r.jsxs)(n.li,{children:["Enums: ",(0,r.jsx)(n.code,{children:"kEnumValue"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Header Guards"}),": Use ",(0,r.jsx)(n.code,{children:"#ifndef MOD_NAME_COMPONENT_H_"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Includes"}),": System headers first, then library headers, then local headers"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Comments"}),": Use Doxygen-style comments for public APIs"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"code-formatting",children:"Code Formatting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"namespace chimaera::MOD_NAME {\n\n/**\n * Brief description\n * \n * Detailed description if needed\n * @param param_name Parameter description\n * @return Return value description\n */\nclass ExampleClass {\n public:\n  // Public methods\n  void PublicMethod();\n  \n private:\n  // Private members with trailing underscore\n  u32 member_variable_;\n};\n\n}  // namespace chimaera::MOD_NAME\n"})}),"\n",(0,r.jsx)(n.h2,{id:"module-structure",children:"Module Structure"}),"\n",(0,r.jsx)(n.h3,{id:"task-definition-mod_name_tasksh",children:"Task Definition (MOD_NAME_tasks.h)"}),"\n",(0,r.jsx)(n.p,{children:"Task definition patterns:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CreateParams Structure"}),": Define configuration parameters for container creation","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"CreateParams use cereal serialization and do NOT require allocator-based constructors"}),"\n",(0,r.jsx)(n.li,{children:"Only need default constructor and parameter-based constructors"}),"\n",(0,r.jsx)(n.li,{children:"Allocator is NOT passed to CreateParams - it's handled internally by BaseCreateTask"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CreateTask Template"}),": Use GetOrCreatePoolTask template for container creation (non-admin modules)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom Tasks"}),": Define custom tasks with SHM/Emplace constructors and HSHM data members"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#ifndef MOD_NAME_TASKS_H_\n#define MOD_NAME_TASKS_H_\n\n#include <chimaera/chimaera.h>\n#include <[namespace]/MOD_NAME/autogen/MOD_NAME_methods.h>\n// Include admin tasks for GetOrCreatePoolTask\n#include <[namespace]/admin/admin_tasks.h>\n\nnamespace chimaera::MOD_NAME {\n\n/**\n * CreateParams for MOD_NAME chimod\n * Contains configuration parameters for MOD_NAME container creation\n */\nstruct CreateParams {\n  // MOD_NAME-specific parameters\n  std::string config_data_;\n  chi::u32 worker_count_;\n\n  // Required: chimod library name for module manager\n  static constexpr const char* chimod_lib_name = "chimaera_MOD_NAME";\n\n  // Default constructor\n  CreateParams() : worker_count_(1) {}\n\n  // Constructor with parameters\n  CreateParams(const std::string& config_data = "",\n               chi::u32 worker_count = 1)\n      : config_data_(config_data), worker_count_(worker_count) {}\n\n  // Serialization support for cereal\n  template<class Archive>\n  void serialize(Archive& ar) {\n    ar(config_data_, worker_count_);\n  }\n\n  /**\n   * Load configuration from PoolConfig (for compose mode)\n   * Required for compose feature support\n   * @param pool_config Pool configuration from compose section\n   */\n  void LoadConfig(const chi::PoolConfig& pool_config) {\n    // Parse YAML config string\n    YAML::Node config = YAML::Load(pool_config.config_);\n\n    // Load module-specific parameters from YAML\n    if (config["config_data"]) {\n      config_data_ = config["config_data"].as<std::string>();\n    }\n    if (config["worker_count"]) {\n      worker_count_ = config["worker_count"].as<chi::u32>();\n    }\n  }\n};\n\n/**\n * CreateTask - Initialize the MOD_NAME container\n * Type alias for GetOrCreatePoolTask with CreateParams (uses kGetOrCreatePool method)\n * Non-admin modules should use GetOrCreatePoolTask instead of BaseCreateTask\n */\nusing CreateTask = chimaera::admin::GetOrCreatePoolTask<CreateParams>;\n\n/**\n * Custom operation task\n */\nstruct CustomTask : public chi::Task {\n  // Task-specific data using HSHM macros\n  INOUT chi::string data_;      // Input/output string\n  IN chi::u32 operation_id_;     // Input parameter\n  OUT chi::u32 result_code_;     // Output result\n\n  // SHM constructor\n  explicit CustomTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc)\n      : chi::Task(alloc), \n        data_(alloc), \n        operation_id_(0), \n        result_code_(0) {}\n\n  // Emplace constructor\n  explicit CustomTask(\n      const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc,\n      const chi::TaskId &task_id,\n      const chi::PoolId &pool_id,\n      const chi::PoolQuery &pool_query,\n      const std::string &data,\n      chi::u32 operation_id)\n      : chi::Task(alloc, task_id, pool_id, pool_query, 10),\n        data_(alloc, data),\n        operation_id_(operation_id),\n        result_code_(0) {\n    task_id_ = task_id;\n    pool_id_ = pool_id;\n    method_ = Method::kCustom;\n    task_flags_.Clear();\n    pool_query_ = pool_query;\n  }\n};\n\n}  // namespace chimaera::MOD_NAME\n\n#endif  // MOD_NAME_TASKS_H_\n'})}),"\n",(0,r.jsx)(n.h3,{id:"client-implementation-mod_name_clienthcc",children:"Client Implementation (MOD_NAME_client.h/cc)"}),"\n",(0,r.jsx)(n.p,{children:"The client provides a simple API for task submission:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#ifndef MOD_NAME_CLIENT_H_\n#define MOD_NAME_CLIENT_H_\n\n#include <chimaera/chimaera.h>\n#include <[namespace]/MOD_NAME/MOD_NAME_tasks.h>\n\nnamespace chimaera::MOD_NAME {\n\nclass Client : public chi::ContainerClient {\n public:\n  Client() = default;\n  explicit Client(const chi::PoolId& pool_id) { Init(pool_id); }\n\n  /**\n   * Synchronous operation - waits for completion\n   */\n  void Create(const hipc::MemContext& mctx, \n              const chi::PoolQuery& pool_query,\n              const CreateParams& params = CreateParams()) {\n    auto task = AsyncCreate(mctx, pool_query, params);\n    task->Wait();\n    \n    // CRITICAL: Update client pool_id_ with the actual pool ID from the task\n    pool_id_ = task->new_pool_id_;\n    \n    CHI_IPC->DelTask(task);\n  }\n\n  /**\n   * Asynchronous operation - returns immediately\n   */\n  hipc::FullPtr<CreateTask> AsyncCreate(\n      const hipc::MemContext& mctx,\n      const chi::PoolQuery& pool_query,\n      const CreateParams& params = CreateParams()) {\n    auto* ipc_manager = CHI_IPC;\n    \n    // CRITICAL: CreateTask MUST use admin pool for GetOrCreatePool processing\n    auto task = ipc_manager->NewTask<CreateTask>(\n        chi::CreateTaskId(),\n        chi::kAdminPoolId,  // Always use admin pool for CreateTask\n        pool_query,\n        CreateParams::chimod_lib_name,  // ChiMod name from CreateParams\n        pool_name_,             // Pool name from base client\n        params);                // CreateParams with configuration\n    \n    // Submit to runtime\n    ipc_manager->Enqueue(task);\n    return task;\n  }\n};\n\n}  // namespace chimaera::MOD_NAME\n\n#endif  // MOD_NAME_CLIENT_H_\n"})}),"\n",(0,r.jsx)(n.h3,{id:"chimod-createtask-pool-assignment-requirements",children:"ChiMod CreateTask Pool Assignment Requirements"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CRITICAL"}),": All ChiMod clients implementing Create functions MUST use the explicit ",(0,r.jsx)(n.code,{children:"chi::kAdminPoolId"})," variable when constructing CreateTask operations. You CANNOT use ",(0,r.jsx)(n.code,{children:"pool_id_"})," for CreateTask operations."]}),"\n",(0,r.jsx)(n.h4,{id:"why-this-is-required",children:"Why This is Required"}),"\n",(0,r.jsxs)(n.p,{children:["CreateTask operations are actually GetOrCreatePoolTask operations that must be processed by the admin ChiMod to create or find the target pool. The ",(0,r.jsx)(n.code,{children:"pool_id_"})," variable is not initialized until after the Create operation completes successfully."]}),"\n",(0,r.jsx)(n.h4,{id:"correct-usage",children:"Correct Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// CORRECT: Always use chi::kAdminPoolId for CreateTask\nauto task = ipc_manager->NewTask<CreateTask>(\n    chi::CreateTaskId(),\n    chi::kAdminPoolId,          // REQUIRED: Use admin pool for CreateTask\n    pool_query,\n    CreateParams::chimod_lib_name,\n    pool_name,\n    pool_id_,                   // Target pool ID to create\n    params);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"incorrect-usage",children:"Incorrect Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// WRONG: Never use pool_id_ for CreateTask operations\nauto task = ipc_manager->NewTask<CreateTask>(\n    chi::CreateTaskId(),\n    pool_id_,                   // WRONG: pool_id_ is not initialized yet\n    pool_query,\n    CreateParams::chimod_lib_name,\n    pool_name,\n    pool_id_,\n    params);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"key-points",children:"Key Points"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin Pool Processing"}),": CreateTask is a GetOrCreatePoolTask that must be handled by the admin pool"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Uninitialized Variable"}),": ",(0,r.jsx)(n.code,{children:"pool_id_"})," is not set until after Create completes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Universal Requirement"}),": This applies to ALL ChiMod clients, including admin, bdev, and custom modules"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create Responsibility"}),": Create operations are responsible for allocating new pool IDs using the admin pool"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"chimod-name-requirements",children:"ChiMod Name Requirements"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CRITICAL"}),": All ChiMod clients MUST use ",(0,r.jsx)(n.code,{children:"CreateParams::chimod_lib_name"})," instead of hardcoding module names."]}),"\n",(0,r.jsx)(n.h4,{id:"correct-usage-1",children:"Correct Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// CORRECT: Use CreateParams::chimod_lib_name\nauto task = ipc_manager->NewTask<CreateTask>(\n    chi::CreateTaskId(),\n    chi::kAdminPoolId,\n    pool_query,\n    CreateParams::chimod_lib_name,  // Dynamic reference to CreateParams\n    pool_name,\n    pool_id,\n    params);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"incorrect-usage-1",children:"Incorrect Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// WRONG: Never hardcode module names\nauto task = ipc_manager->NewTask<CreateTask>(\n    chi::CreateTaskId(),\n    chi::kAdminPoolId,\n    pool_query,\n    "chimaera_MOD_NAME",  // Hardcoded name breaks flexibility\n    pool_name,\n    pool_id,\n    params);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"why-this-is-required-1",children:"Why This is Required"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Namespace Flexibility"}),": Allows ChiMods to work with different namespace configurations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Source of Truth"}),": The module name is defined once in CreateParams"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"External ChiMods"}),": Essential for external ChiMods using custom namespaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintainability"}),": Changes to module names only require updating CreateParams"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-pattern",children:"Implementation Pattern"}),"\n",(0,r.jsxs)(n.p,{children:["All non-admin ChiMods using ",(0,r.jsx)(n.code,{children:"GetOrCreatePoolTask"})," must follow this pattern:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// In AsyncCreate method\nauto task = ipc_manager->NewTask<CreateTask>(\n    chi::CreateTaskId(),\n    chi::kAdminPoolId,                    // Always use admin pool\n    pool_query,\n    CreateParams::chimod_lib_name,        // REQUIRED: Use static member\n    pool_name,                            // Pool identifier\n    pool_id,                              // Target pool ID\n    /* ...CreateParams arguments... */);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": The admin ChiMod uses ",(0,r.jsx)(n.code,{children:"BaseCreateTask"})," directly and doesn't require the chimod name parameter."]}),"\n",(0,r.jsx)(n.h3,{id:"runtime-container-mod_name_runtimehcc",children:"Runtime Container (MOD_NAME_runtime.h/cc)"}),"\n",(0,r.jsx)(n.p,{children:"The runtime container executes tasks server-side:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#ifndef MOD_NAME_RUNTIME_H_\n#define MOD_NAME_RUNTIME_H_\n\n#include <chimaera/chimaera.h>\n#include <[namespace]/MOD_NAME/MOD_NAME_tasks.h>\n\nnamespace chimaera::MOD_NAME {\n\nclass Container : public chi::Container {\n public:\n  Container() = default;\n  ~Container() override = default;\n\n  /**\n   * Initialize container with pool information (REQUIRED)\n   * This is called by the framework before Create is called\n   */\n  void Init(const chi::PoolId& pool_id, const std::string& pool_name) override {\n    // Call base class initialization\n    chi::Container::Init(pool_id, pool_name);\n\n    // Initialize the client for this ChiMod\n    client_ = Client(pool_id);\n  }\n\n  /**\n   * Create the container (Method::kCreate)\n   * This method creates queues and sets up container resources\n   * NOTE: Container is already initialized via Init() before Create is called\n   */\n  void Create(hipc::FullPtr<CreateTask> task, chi::RunContext& ctx) {\n    // Container is already initialized via Init() before Create is called\n    // Do NOT call Init() here\n\n    // Additional container-specific initialization logic here\n    std::cout << "Container created and initialized for pool: " << pool_name_\n              << " (ID: " << pool_id_ << ")" << std::endl;\n  }\n\n  /**\n   * Custom operation (Method::kCustom)\n   */\n  void Custom(hipc::FullPtr<CustomTask> task, chi::RunContext& ctx) {\n    // Process the operation\n    std::string result = processData(task->data_.str(),\n                                    task->operation_id_);\n    task->data_ = hipc::string(main_allocator_, result);\n    task->result_code_ = 0;\n    // Task completion is handled by the framework\n  }\n\n private:\n  std::string processData(const std::string& input, u32 op_id) {\n    // Business logic here\n    return input + "_processed";\n  }\n};\n\n}  // namespace chimaera::MOD_NAME\n\n// Define ChiMod entry points using CHI_TASK_CC macro\nCHI_TASK_CC(chimaera::MOD_NAME::Container)\n\n#endif  // MOD_NAME_RUNTIME_H_\n'})}),"\n",(0,r.jsx)(n.h3,{id:"execution-modes-and-dynamic-scheduling",children:"Execution Modes and Dynamic Scheduling"}),"\n",(0,r.jsxs)(n.p,{children:["The Chimaera runtime supports two execution modes through the ",(0,r.jsx)(n.code,{children:"ExecMode"})," enum in ",(0,r.jsx)(n.code,{children:"RunContext"}),", enabling sophisticated task routing patterns:"]}),"\n",(0,r.jsx)(n.h4,{id:"execmode-overview",children:"ExecMode Overview"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"/**\n * Execution mode for task processing\n */\nenum class ExecMode : u32 {\n  kExec = 0,              /**< Normal task execution (default) */\n  kDynamicSchedule = 1    /**< Dynamic scheduling - route after execution */\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The execution mode is accessible through the ",(0,r.jsx)(n.code,{children:"RunContext"})," parameter passed to all task methods:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void YourMethod(hipc::FullPtr<YourTask> task, chi::RunContext& rctx) {\n  // Check execution mode\n  if (rctx.exec_mode == chi::ExecMode::kDynamicSchedule) {\n    // Dynamic scheduling logic - modify task routing\n    task->pool_query_ = chi::PoolQuery::Broadcast();\n    return;  // Return early - task will be re-routed\n  }\n\n  // Normal execution logic (kExec mode)\n  // ... perform actual work ...\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"kexec-mode-default",children:"kExec Mode (Default)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Normal task execution mode where tasks are processed completely and then marked as finished."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Behavior"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tasks execute their full logic"}),"\n",(0,r.jsx)(n.li,{children:"Results are written to task output parameters"}),"\n",(0,r.jsxs)(n.li,{children:["Worker calls ",(0,r.jsx)(n.code,{children:"EndTask()"})," after execution completes"]}),"\n",(0,r.jsx)(n.li,{children:"Task is marked as completed and cleaned up"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use"}),": The default mode for all standard task processing."]}),"\n",(0,r.jsx)(n.h4,{id:"kdynamicschedule-mode",children:"kDynamicSchedule Mode"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Two-phase execution where the first execution determines routing, then the task is re-routed and executed again."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Behavior"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Worker sets ",(0,r.jsx)(n.code,{children:"exec_mode = kDynamicSchedule"})," before first execution"]}),"\n",(0,r.jsxs)(n.li,{children:["Task method examines state and modifies ",(0,r.jsx)(n.code,{children:"task->pool_query_"})," for routing"]}),"\n",(0,r.jsx)(n.li,{children:"Task returns early without performing full execution"}),"\n",(0,r.jsxs)(n.li,{children:["Worker calls ",(0,r.jsx)(n.code,{children:"RerouteDynamicTask()"})," instead of ",(0,r.jsx)(n.code,{children:"EndTask()"})]}),"\n",(0,r.jsxs)(n.li,{children:["Task is re-routed using the updated ",(0,r.jsx)(n.code,{children:"pool_query_"})]}),"\n",(0,r.jsxs)(n.li,{children:["Task executes again in normal ",(0,r.jsx)(n.code,{children:"kExec"})," mode with the new routing"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tasks that need runtime-dependent routing decisions"}),"\n",(0,r.jsx)(n.li,{children:"Cache optimization patterns (check local, then broadcast if not found)"}),"\n",(0,r.jsx)(n.li,{children:"Conditional distributed execution based on state"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-getorcreatepool-with-dynamic-scheduling",children:"Example: GetOrCreatePool with Dynamic Scheduling"}),"\n",(0,r.jsxs)(n.p,{children:["The admin ChiMod's ",(0,r.jsx)(n.code,{children:"GetOrCreatePool"})," method demonstrates the canonical dynamic scheduling pattern:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'void Runtime::GetOrCreatePool(\n    hipc::FullPtr<chimaera::admin::GetOrCreatePoolTask<chimaera::admin::CreateParams>> task,\n    chi::RunContext &rctx) {\n\n  auto *pool_manager = CHI_POOL_MANAGER;\n  std::string pool_name = task->pool_name_.str();\n\n  // PHASE 1: Dynamic scheduling - determine routing\n  if (rctx.exec_mode == chi::ExecMode::kDynamicSchedule) {\n    // Check if pool exists locally first\n    chi::PoolId existing_pool_id = pool_manager->FindPoolByName(pool_name);\n\n    if (!existing_pool_id.IsNull()) {\n      // Pool exists locally - route to local execution only\n      HILOG(kDebug, "Admin: Pool \'{}\' found locally (ID: {}), using Local query",\n            pool_name, existing_pool_id);\n      task->pool_query_ = chi::PoolQuery::Local();\n    } else {\n      // Pool doesn\'t exist - broadcast creation to all nodes\n      HILOG(kDebug, "Admin: Pool \'{}\' not found locally, broadcasting creation",\n            pool_name);\n      task->pool_query_ = chi::PoolQuery::Broadcast();\n    }\n    return;  // Return early - worker will re-route task\n  }\n\n  // PHASE 2: Normal execution - actually create/get the pool\n  HILOG(kDebug, "Admin: Executing GetOrCreatePool task - ChiMod: {}, Pool: {}",\n        task->chimod_name_.str(), pool_name);\n\n  task->return_code_ = 0;\n  task->error_message_ = "";\n\n  try {\n    if (!pool_manager->CreatePool(task.Cast<chi::Task>(), &rctx)) {\n      task->return_code_ = 2;\n      task->error_message_ = "Failed to create or get pool via PoolManager";\n      return;\n    }\n\n    task->return_code_ = 0;\n    pools_created_++;\n\n    HILOG(kDebug, "Admin: Pool operation completed successfully - ID: {}, Name: {}",\n          task->new_pool_id_, pool_name);\n\n  } catch (const std::exception &e) {\n    task->return_code_ = 99;\n    task->error_message_ = hipc::string(\n        task->GetCtxAllocator(),\n        std::string("Exception during pool creation: ") + e.what());\n    HELOG(kError, "Admin: Pool creation failed with exception: {}", e.what());\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"using-dynamic-poolquery",children:"Using Dynamic() PoolQuery"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"PoolQuery::Dynamic()"})," factory method triggers dynamic scheduling:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Client code - request dynamic routing\nauto pool_query = chi::PoolQuery::Dynamic();\nclient.Create(mctx, pool_query, "my_pool_name", pool_id);\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What happens internally:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Worker recognizes ",(0,r.jsx)(n.code,{children:"Dynamic()"})," pool query"]}),"\n",(0,r.jsxs)(n.li,{children:["Sets ",(0,r.jsx)(n.code,{children:"rctx.exec_mode = ExecMode::kDynamicSchedule"})]}),"\n",(0,r.jsx)(n.li,{children:"Routes task to local node first"}),"\n",(0,r.jsxs)(n.li,{children:["Task method checks cache and updates ",(0,r.jsx)(n.code,{children:"pool_query_"})]}),"\n",(0,r.jsx)(n.li,{children:"Worker re-routes with updated query"}),"\n",(0,r.jsx)(n.li,{children:"Task executes again in normal mode with correct routing"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"benefits-of-dynamic-scheduling",children:"Benefits of Dynamic Scheduling"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Performance Optimization:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Avoids redundant operations (e.g., pool creation when pool already exists)"}),"\n",(0,r.jsx)(n.li,{children:"Reduces network overhead by checking local state first"}),"\n",(0,r.jsx)(n.li,{children:"Enables intelligent routing based on runtime conditions"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Cache Optimization Pattern:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Check local cache first\nif (rctx.exec_mode == chi::ExecMode::kDynamicSchedule) {\n  if (LocalCacheHas(resource_id)) {\n    task->pool_query_ = chi::PoolQuery::Local();  // Found locally\n  } else {\n    task->pool_query_ = chi::PoolQuery::Broadcast();  // Need to fetch\n  }\n  return;\n}\n\n// Normal execution with optimized routing\nauto resource = GetResource(resource_id);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"State-Dependent Routing:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Route based on runtime conditions\nif (rctx.exec_mode == chi::ExecMode::kDynamicSchedule) {\n  if (ShouldExecuteDistributed(task)) {\n    task->pool_query_ = chi::PoolQuery::Broadcast();\n  } else {\n    task->pool_query_ = chi::PoolQuery::Local();\n  }\n  return;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"DO:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 Check ",(0,r.jsx)(n.code,{children:"rctx.exec_mode"})," at the start of your method"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 Return early after modifying ",(0,r.jsx)(n.code,{children:"pool_query_"})," in dynamic mode"]}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Keep dynamic scheduling logic lightweight (fast checks only)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Use dynamic scheduling for cache optimization patterns"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"DON'T:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u274c Perform expensive operations in dynamic scheduling mode"}),"\n",(0,r.jsx)(n.li,{children:"\u274c Modify task output parameters in dynamic scheduling mode"}),"\n",(0,r.jsxs)(n.li,{children:["\u274c Call ",(0,r.jsx)(n.code,{children:"Wait()"})," or spawn subtasks in dynamic scheduling mode"]}),"\n",(0,r.jsx)(n.li,{children:"\u274c Use dynamic scheduling for simple operations that don't need routing optimization"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"worker-implementation-details",children:"Worker Implementation Details"}),"\n",(0,r.jsx)(n.p,{children:"The worker automatically handles dynamic scheduling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Worker::ExecTask() logic\nif (run_ctx->exec_mode == ExecMode::kDynamicSchedule) {\n  // After task returns, call RerouteDynamicTask instead of EndTask\n  RerouteDynamicTask(task_ptr, run_ctx);\n  return;\n}\n\n// Normal mode - end task after execution\nEndTask(task_ptr, run_ctx);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"RerouteDynamicTask()"})," method:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Resets task flags (",(0,r.jsx)(n.code,{children:"TASK_STARTED"}),", ",(0,r.jsx)(n.code,{children:"TASK_ROUTED"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Re-routes task using updated ",(0,r.jsx)(n.code,{children:"pool_query_"})]}),"\n",(0,r.jsxs)(n.li,{children:["Sets ",(0,r.jsx)(n.code,{children:"exec_mode = kExec"})," for next execution"]}),"\n",(0,r.jsx)(n.li,{children:"Schedules task for execution again"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"configuration-and-code-generation",children:"Configuration and Code Generation"}),"\n",(0,r.jsx)(n.h3,{id:"overview-1",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Chimaera uses a two-level configuration system with automated code generation:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"chimaera_repo.yaml"}),": Repository-wide configuration (namespace, version, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"chimaera_mod.yaml"}),": Module-specific configuration (method IDs, metadata)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"chi_refresh_repo"}),": Utility script that generates autogen files from YAML configurations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"chimaera_repoyaml",children:"chimaera_repo.yaml"}),"\n",(0,r.jsxs)(n.p,{children:["Located at ",(0,r.jsx)(n.code,{children:"chimods/chimaera_repo.yaml"}),", this file defines repository-wide settings:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# Repository Configuration\nnamespace: chimaera        # MUST match namespace in all chimaera_mod.yaml files\nversion: 1.0.0\ndescription: "Chimaera Runtime ChiMod Repository"\n\n# Module discovery - directories to scan for ChiMods\nmodules:\n  - MOD_NAME\n  - admin  \n  - bdev\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Requirements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"namespace"})," field MUST be identical in both chimaera_repo.yaml and all chimaera_mod.yaml files"]}),"\n",(0,r.jsx)(n.li,{children:"Used by build system for CMake package generation and installation paths"}),"\n",(0,r.jsxs)(n.li,{children:["Determines export target names: ",(0,r.jsx)(n.code,{children:"${namespace}::${module}_runtime"}),", ",(0,r.jsx)(n.code,{children:"${namespace}::${module}_client"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"chimaera_modyaml",children:"chimaera_mod.yaml"}),"\n",(0,r.jsx)(n.p,{children:"Each ChiMod must have its own configuration file specifying methods and metadata:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# MOD_NAME ChiMod Configuration\nmodule_name: MOD_NAME\nnamespace: chimaera        # MUST match chimaera_repo.yaml namespace\nversion: 1.0.0\n\n# Inherited Methods (fixed IDs)\nkCreate: 0        # Container creation (required)\nkDestroy: 1       # Container destruction (required)\nkNodeFailure: -1  # Not implemented (-1 means disabled)\nkRecover: -1      # Not implemented \nkMigrate: -1      # Not implemented\nkUpgrade: -1      # Not implemented\n\n# Custom Methods (start from 10, use sequential IDs)\nkCustom: 10       # Custom operation method\nkCoMutexTest: 20  # CoMutex synchronization testing method\nkCoRwLockTest: 21 # CoRwLock reader-writer synchronization testing method\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Method ID Assignment Rules:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"0-9"}),": Reserved for system methods (kCreate=0, kDestroy=1, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"10+"}),": Custom methods (assign sequential IDs starting from 10)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Disabled methods"}),": Use -1 to disable inherited methods not implemented"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency"}),": Once assigned, never change method IDs (breaks compatibility)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"chi_refresh_repo-utility",children:"chi_refresh_repo Utility"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"chi_refresh_repo"})," utility automatically generates autogen files from YAML configurations."]}),"\n",(0,r.jsx)(n.h4,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# From project root, regenerate all autogen files\n./build/bin/chi_refresh_repo chimods\n\n# The utility will:\n# 1. Read chimaera_repo.yaml for global settings\n# 2. Scan each module's chimaera_mod.yaml \n# 3. Generate MOD_NAME_methods.h with method constants\n# 4. Generate MOD_NAME_lib_exec.cc with virtual method dispatch\n"})}),"\n",(0,r.jsx)(n.h4,{id:"generated-files",children:"Generated Files"}),"\n",(0,r.jsx)(n.p,{children:"For each ChiMod, the utility generates:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"include/[namespace]/MOD_NAME/autogen/MOD_NAME_methods.h"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"namespace chimaera::MOD_NAME {\nnamespace Method {\nGLOBAL_CONST chi::u32 kCreate = 0;\nGLOBAL_CONST chi::u32 kDestroy = 1;\nGLOBAL_CONST chi::u32 kCustom = 10;\nGLOBAL_CONST chi::u32 kCoMutexTest = 20;\n}  // namespace Method\n}  // namespace chimaera::MOD_NAME\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"src/autogen/MOD_NAME_lib_exec.cc"})}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Virtual method dispatch (Runtime::Run, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Task serialization support (SaveIn/Out, LoadIn/Out)"}),"\n",(0,r.jsx)(n.li,{children:"Memory management (Del, NewCopy, Aggregate)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-run-chi_refresh_repo",children:"When to Run chi_refresh_repo"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ALWAYS"})," run chi_refresh_repo when:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Adding new methods to chimaera_mod.yaml"}),"\n",(0,r.jsx)(n.li,{children:"Changing method IDs or names"}),"\n",(0,r.jsx)(n.li,{children:"Adding new ChiMods to the repository"}),"\n",(0,r.jsx)(n.li,{children:"Modifying namespace or version information"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"important-notes",children:"Important Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Never manually edit autogen files"})," - they are overwritten by chi_refresh_repo"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Run chi_refresh_repo before building"})," after YAML changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Commit autogen files to git"})," so other developers don't need to regenerate"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Method IDs are permanent"})," - changing them breaks binary compatibility"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"workflow-summary",children:"Workflow Summary"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Define methods in ",(0,r.jsx)(n.code,{children:"chimaera_mod.yaml"})," with sequential IDs"]}),"\n",(0,r.jsxs)(n.li,{children:["Implement corresponding methods in ",(0,r.jsx)(n.code,{children:"MOD_NAME_runtime.h/cc"})]}),"\n",(0,r.jsxs)(n.li,{children:["Run ",(0,r.jsx)(n.code,{children:"./build/bin/chi_refresh_repo chimods"})," to generate autogen files"]}),"\n",(0,r.jsxs)(n.li,{children:["Build project with ",(0,r.jsx)(n.code,{children:"make"})," - autogen files provide the dispatch logic"]}),"\n",(0,r.jsx)(n.li,{children:"Autogen files handle virtual method routing, serialization, and memory management"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This automated approach ensures consistency across all ChiMods and reduces boilerplate code maintenance."}),"\n",(0,r.jsx)(n.h2,{id:"task-development",children:"Task Development"}),"\n",(0,r.jsx)(n.h3,{id:"task-requirements",children:"Task Requirements"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inherit from chi::Task"}),": All tasks must inherit the base Task class"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Two Constructors"}),": SHM and emplace constructors are mandatory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serializable Types"}),": Use HSHM types (chi::string, chi::vector, etc.) for member variables"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Method Assignment"}),": Set the method_ field to identify the operation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FullPtr Usage"}),": All task method signatures use ",(0,r.jsx)(n.code,{children:"hipc::FullPtr<TaskType>"})," instead of raw pointers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Copy Method"}),": Optional - implement for tasks that need to be replicated across nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Aggregate Method"}),": Optional - implement for tasks that need to combine results from replicas"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"optional-task-methods-copy-and-aggregate",children:"Optional Task Methods: Copy and Aggregate"}),"\n",(0,r.jsxs)(n.p,{children:["For tasks that will be distributed across multiple nodes or need to combine results from multiple executions, you can optionally implement ",(0,r.jsx)(n.code,{children:"Copy()"})," and ",(0,r.jsx)(n.code,{children:"Aggregate()"})," methods."]}),"\n",(0,r.jsx)(n.h4,{id:"copy-method",children:"Copy Method"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Copy()"})," method is used to create a deep copy of a task, typically when distributing work across multiple nodes. This is useful for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Remote task execution via networking"}),"\n",(0,r.jsx)(n.li,{children:"Task replication for fault tolerance"}),"\n",(0,r.jsx)(n.li,{children:"Creating independent task replicas with separate data"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void Copy(const hipc::FullPtr<YourTask> &other);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implementation Pattern:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct WriteTask : public chi::Task {\n  IN Block block_;\n  IN hipc::Pointer data_;\n  IN size_t length_;\n  OUT chi::u64 bytes_written_;\n\n  /**\n   * Copy from another WriteTask (assumes this task is already constructed)\n   * @param other Pointer to the source task to copy from\n   */\n  void Copy(const hipc::FullPtr<WriteTask> &other) {\n    // Copy task-specific fields only\n    // Base Task fields are copied automatically by NewCopy\n    block_ = other->block_;\n    data_ = other->data_;\n    length_ = other->length_;\n    bytes_written_ = other->bytes_written_;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DO NOT"})," call ",(0,r.jsx)(n.code,{children:"chi::Task::Copy()"})," - base fields are copied automatically by autogenerated NewCopy"]}),"\n",(0,r.jsx)(n.li,{children:"Copy only task-specific fields from the source task"}),"\n",(0,r.jsxs)(n.li,{children:["The destination task (",(0,r.jsx)(n.code,{children:"this"}),") is already constructed - don't call constructors"]}),"\n",(0,r.jsx)(n.li,{children:"For pointer fields, decide if you need deep or shallow copy based on ownership"}),"\n",(0,r.jsx)(n.li,{children:"NewCopy in autogen code handles calling base Task::Copy before your Copy method"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"aggregate-method",children:"Aggregate Method"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Aggregate()"})," method combines results from multiple task replicas into a single result. This is commonly used for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Combining results from distributed task execution"}),"\n",(0,r.jsx)(n.li,{children:"Merging partial results from parallel operations"}),"\n",(0,r.jsx)(n.li,{children:"Accumulating metrics from multiple nodes"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void Aggregate(const hipc::FullPtr<YourTask> &other);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implementation Patterns:"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern 1: Last-Writer-Wins (Simple Override)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct WriteTask : public chi::Task {\n  IN Block block_;\n  IN hipc::Pointer data_;\n  OUT chi::u64 bytes_written_;\n\n  /**\n   * Aggregate results from another WriteTask\n   * For write operations, we typically just copy the result from the completed replica\n   */\n  void Aggregate(const hipc::FullPtr<WriteTask> &other) {\n    // Simply copy the result - last writer wins\n    Copy(other);\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern 2: Accumulation (Sum/Max/Min)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct GetStatsTask : public chi::Task {\n  OUT chi::u64 total_bytes_;\n  OUT chi::u64 operation_count_;\n  OUT chi::u64 max_latency_us_;\n\n  /**\n   * Aggregate statistics from multiple replicas\n   * Accumulate totals and find maximum values\n   */\n  void Aggregate(const hipc::FullPtr<GetStatsTask> &other) {\n    // Sum cumulative metrics\n    total_bytes_ += other->total_bytes_;\n    operation_count_ += other->operation_count_;\n\n    // Take maximum for latency\n    max_latency_us_ = std::max(max_latency_us_, other->max_latency_us_);\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern 3: List/Vector Merging"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct AllocateBlocksTask : public chi::Task {\n  OUT chi::ipc::vector<Block> blocks_;\n\n  /**\n   * Aggregate block allocations from multiple replicas\n   * Combine all allocated blocks into a single list\n   */\n  void Aggregate(const hipc::FullPtr<AllocateBlocksTask> &other) {\n    // Append blocks from other task to this task's list\n    blocks_.insert(blocks_.end(),\n                   other->blocks_.begin(),\n                   other->blocks_.end());\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern 4: Custom Logic"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct QueryTask : public chi::Task {\n  OUT chi::ipc::vector<Result> results_;\n  OUT chi::u32 error_count_;\n\n  /**\n   * Aggregate query results with custom deduplication\n   */\n  void Aggregate(const hipc::FullPtr<QueryTask> &other) {\n    // Merge results with deduplication\n    for (const auto &result : other->results_) {\n      if (!ContainsResult(results_, result)) {\n        results_.push_back(result);\n      }\n    }\n\n    // Accumulate error counts\n    error_count_ += other->error_count_;\n  }\n\nprivate:\n  bool ContainsResult(const chi::ipc::vector<Result> &vec, const Result &r) {\n    // Custom deduplication logic\n    return std::find(vec.begin(), vec.end(), r) != vec.end();\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"when-to-implement-copy-and-aggregate",children:"When to Implement Copy and Aggregate"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implement Copy when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Your task will be sent to remote nodes for execution"}),"\n",(0,r.jsx)(n.li,{children:"Task data needs to be replicated for fault tolerance"}),"\n",(0,r.jsx)(n.li,{children:"You need independent copies with separate data ownership"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implement Aggregate when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Your task returns results that can be combined (sums, lists, statistics)"}),"\n",(0,r.jsx)(n.li,{children:"You're using distributed execution patterns (e.g., map-reduce)"}),"\n",(0,r.jsx)(n.li,{children:"Multiple replicas produce partial results that need merging"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Skip Copy and Aggregate when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tasks are only executed locally on a single node"}),"\n",(0,r.jsx)(n.li,{children:"Results don't need to be combined across executions"}),"\n",(0,r.jsx)(n.li,{children:"Tasks have no output parameters (side-effects only)"}),"\n",(0,r.jsx)(n.li,{children:"Default shallow copy behavior is sufficient"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"copyaggregate-usage-in-networking",children:"Copy/Aggregate Usage in Networking"}),"\n",(0,r.jsx)(n.p,{children:"When tasks are sent across nodes using Send/Recv:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Send Phase"}),": The ",(0,r.jsx)(n.code,{children:"Copy()"})," method creates a replica of the origin task"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"hipc::FullPtr<Task> replica;\ncontainer->NewCopy(task->method_, origin_task, replica, /* replica_flag */);\n// Internally calls task->Copy(origin_task)\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recv Phase"}),": The ",(0,r.jsx)(n.code,{children:"Aggregate()"})," method combines replica results back into the origin"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"container->Aggregate(task->method_, origin_task, replica);\n// Internally calls origin_task->Aggregate(replica)\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Autogeneration"}),": The code generator creates dispatcher methods that call your Copy/Aggregate implementations:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// In autogen/MOD_NAME_lib_exec.cc\nvoid NewCopy(Runtime* runtime, chi::u32 method,\n             hipc::FullPtr<chi::Task> orig_task,\n             hipc::FullPtr<chi::Task>& new_task,\n             bool deep_copy) {\n  switch (method) {\n    case Method::kWrite: {\n      auto orig = orig_task.Cast<WriteTask>();\n      new_task = CHI_IPC->NewTask<WriteTask>(...);\n      new_task.Cast<WriteTask>()->Copy(orig);\n      break;\n    }\n  }\n}\n\nvoid Aggregate(Runtime* runtime, chi::u32 method,\n               hipc::FullPtr<chi::Task> task,\n               const hipc::FullPtr<chi::Task> &replica) {\n  switch (method) {\n    case Method::kWrite: {\n      task.Cast<WriteTask>()->Aggregate(replica.Cast<WriteTask>());\n      break;\n    }\n  }\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"complete-example-readtask-with-copy-and-aggregate",children:"Complete Example: ReadTask with Copy and Aggregate"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct ReadTask : public chi::Task {\n  IN Block block_;\n  OUT hipc::Pointer data_;\n  INOUT size_t length_;\n  OUT chi::u64 bytes_read_;\n\n  /** SHM constructor */\n  explicit ReadTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc)\n      : chi::Task(alloc), length_(0), bytes_read_(0) {}\n\n  /** Emplace constructor */\n  explicit ReadTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc,\n                    const chi::TaskId &task_node,\n                    const chi::PoolId &pool_id,\n                    const chi::PoolQuery &pool_query,\n                    const Block &block,\n                    hipc::Pointer data,\n                    size_t length)\n      : chi::Task(alloc, task_node, pool_id, pool_query, 10),\n        block_(block), data_(data), length_(length), bytes_read_(0) {\n    task_id_ = task_node;\n    pool_id_ = pool_id;\n    method_ = Method::kRead;\n    task_flags_.Clear();\n    pool_query_ = pool_query;\n  }\n\n  /**\n   * Copy from another ReadTask\n   * Used when creating replicas for remote execution\n   */\n  void Copy(const hipc::FullPtr<ReadTask> &other) {\n    // Copy task-specific fields only\n    // Base Task fields are copied automatically by NewCopy\n    block_ = other->block_;\n    data_ = other->data_;\n    length_ = other->length_;\n    bytes_read_ = other->bytes_read_;\n  }\n\n  /**\n   * Aggregate results from replica\n   * For read operations, simply copy the data from the completed replica\n   */\n  void Aggregate(const hipc::FullPtr<ReadTask> &other) {\n    // For reads, we just take the result from the replica\n    Copy(other);\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"task-naming-conventions",children:"Task Naming Conventions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CRITICAL"}),": All task names MUST follow consistent naming patterns to ensure proper code generation and maintenance."]}),"\n",(0,r.jsx)(n.h4,{id:"required-naming-pattern",children:"Required Naming Pattern"}),"\n",(0,r.jsx)(n.p,{children:"The naming convention enforces consistency across function names, task types, and method constants:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Function Name \u2192 Task Name \u2192 Method Constant\nFunctionName()  \u2192 FunctionNameTask  \u2192 kFunctionName\n"})}),"\n",(0,r.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Correct Naming:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Function: GetStats() and AsyncGetStats()\n// Task: GetStatsTask  \n// Method: kGetStats\n\n// In bdev_client.h\nPerfMetrics GetStats(const hipc::MemContext& mctx, chi::u64& remaining_size);\nhipc::FullPtr<GetStatsTask> AsyncGetStats(const hipc::MemContext& mctx);\n\n// In bdev_tasks.h  \nstruct GetStatsTask : public chi::Task {\n  OUT PerfMetrics metrics_;\n  OUT chi::u64 remaining_size_;\n  // ... constructors and methods\n};\n\n// In chimaera_mod.yaml\nkGetStats: 14    # Get performance statistics\n\n// In bdev_runtime.h\nvoid GetStats(hipc::FullPtr<GetStatsTask> task, chi::RunContext& ctx);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Incorrect Naming Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// WRONG: Function and task names don't match\nPerfMetrics GetStats(...);           // Function name\nstruct StatTask { ... };             // Task name doesn't match function\n\n// WRONG: Method constant doesn't match function  \nGLOBAL_CONST chi::u32 kStat = 14;    // Method doesn't match function name\n\n// WRONG: Runtime method doesn't match function\nvoid Stat(hipc::FullPtr<StatTask> task, ...);  // Runtime method doesn't match\n"})}),"\n",(0,r.jsx)(n.h4,{id:"naming-rules",children:"Naming Rules"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function Names"}),": Use descriptive verbs (e.g., ",(0,r.jsx)(n.code,{children:"GetStats"}),", ",(0,r.jsx)(n.code,{children:"AllocateBlocks"}),", ",(0,r.jsx)(n.code,{children:"WriteData"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task Names"}),': Always append "Task" to the function name (e.g., ',(0,r.jsx)(n.code,{children:"GetStatsTask"}),", ",(0,r.jsx)(n.code,{children:"AllocateBlocksTask"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Method Constants"}),': Prefix with "k" and match the function name exactly (e.g., ',(0,r.jsx)(n.code,{children:"kGetStats"}),", ",(0,r.jsx)(n.code,{children:"kAllocateBlocks"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Methods"}),": Must match the function name exactly (e.g., ",(0,r.jsx)(n.code,{children:"GetStats()"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"backward-compatibility",children:"Backward Compatibility"}),"\n",(0,r.jsx)(n.p,{children:"When renaming tasks, provide backward compatibility aliases:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// In bdev_tasks.h - provide alias for old name\nusing StatTask = GetStatsTask;  // Backward compatibility\n\n// In autogen/bdev_methods.h - provide constant alias\nGLOBAL_CONST chi::u32 kGetStats = 14;\nGLOBAL_CONST chi::u32 kStat = kGetStats;  // Backward compatibility\n\n// In bdev_runtime.h - provide wrapper methods\nvoid GetStats(hipc::FullPtr<GetStatsTask> task, chi::RunContext& ctx);  // Primary\nvoid Stat(hipc::FullPtr<StatTask> task, chi::RunContext& ctx) {         // Wrapper\n  GetStats(task, ctx);\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"benefits-of-consistent-naming",children:"Benefits of Consistent Naming"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Generation"}),": Automated tools can reliably generate method dispatch code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintenance"}),": Clear correlation between client functions and runtime implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Documentation"}),": Self-documenting code with predictable naming patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debugging"}),": Easy to trace from client calls to runtime execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Consistent patterns make it easier to write comprehensive tests"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"method-system-and-auto-generated-files",children:"Method System and Auto-Generated Files"}),"\n",(0,r.jsx)(n.h4,{id:"method-definitions-autogenmod_name_methodsh",children:"Method Definitions (autogen/MOD_NAME_methods.h)"}),"\n",(0,r.jsx)(n.p,{children:"Method IDs are now defined as namespace constants instead of enum class values. This eliminates the need for static casting:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#ifndef MOD_NAME_AUTOGEN_METHODS_H_\n#define MOD_NAME_AUTOGEN_METHODS_H_\n\n#include <chimaera/chimaera.h>\n\nnamespace chimaera::MOD_NAME {\n\nnamespace Method {\n  // Inherited methods\n  GLOBAL_CONST chi::u32 kCreate = 0;\n  GLOBAL_CONST chi::u32 kDestroy = 1;\n  GLOBAL_CONST chi::u32 kNodeFailure = 2;\n  GLOBAL_CONST chi::u32 kRecover = 3;\n  GLOBAL_CONST chi::u32 kMigrate = 4;\n  GLOBAL_CONST chi::u32 kUpgrade = 5;\n  \n  // Module-specific methods\n  GLOBAL_CONST chi::u32 kCustom = 10;\n}\n\n} // namespace chimaera::MOD_NAME\n\n#endif // MOD_NAME_AUTOGEN_METHODS_H_\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Changes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Namespace instead of enum class"}),": Use ",(0,r.jsx)(n.code,{children:"Method::kMethodName"})," directly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GLOBAL_CONST values"}),": No more static casting required"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Include chimaera.h"}),": Required for GLOBAL_CONST macro"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Direct assignment"}),": ",(0,r.jsx)(n.code,{children:"method_ = Method::kCreate;"})," (no casting)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"basecreatetask-template-system",children:"BaseCreateTask Template System"}),"\n",(0,r.jsx)(n.p,{children:"For modules that need container creation functionality, use the BaseCreateTask template instead of implementing custom CreateTask. However, there are different approaches depending on whether your module is the admin module or a regular ChiMod:"}),"\n",(0,r.jsx)(n.h5,{id:"getorcreatepooltask-vs-basecreatetask-usage",children:"GetOrCreatePoolTask vs BaseCreateTask Usage"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"For Non-Admin Modules (Recommended Pattern):"})}),"\n",(0,r.jsxs)(n.p,{children:["All non-admin ChiMods should use ",(0,r.jsx)(n.code,{children:"GetOrCreatePoolTask"})," which is a specialized version of BaseCreateTask designed for external pool creation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <[namespace]/admin/admin_tasks.h>  // Include admin templates\n\nnamespace chimaera::MOD_NAME {\n\n/**\n * CreateParams for MOD_NAME container creation\n */\nstruct CreateParams {\n  // Module-specific configuration\n  std::string config_data_;\n  chi::u32 worker_count_;\n  \n  // Required: chimod library name\n  static constexpr const char* chimod_lib_name = "chimaera_MOD_NAME";\n\n  // Constructors\n  CreateParams() : worker_count_(1) {}\n\n  CreateParams(const std::string& config_data = "",\n               chi::u32 worker_count = 1)\n      : config_data_(config_data), worker_count_(worker_count) {}\n\n  // Cereal serialization\n  template<class Archive>\n  void serialize(Archive& ar) {\n    ar(config_data_, worker_count_);\n  }\n};\n\n/**\n * CreateTask - Non-admin modules should use GetOrCreatePoolTask\n * This uses Method::kGetOrCreatePool and is designed for external pool creation\n */\nusing CreateTask = chimaera::admin::GetOrCreatePoolTask<CreateParams>;\n\n}  // namespace chimaera::MOD_NAME\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"For Admin Module Only:"})}),"\n",(0,r.jsx)(n.p,{children:"The admin module itself uses BaseCreateTask directly with Method::kCreate:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"namespace chimaera::admin {\n\n/**\n * CreateTask - Admin uses BaseCreateTask with Method::kCreate and IS_ADMIN=true\n */\nusing CreateTask = BaseCreateTask<CreateParams, Method::kCreate, true>;\n\n}  // namespace chimaera::admin\n"})}),"\n",(0,r.jsx)(n.h4,{id:"basecreatetask-template-parameters",children:"BaseCreateTask Template Parameters"}),"\n",(0,r.jsx)(n.p,{children:"The BaseCreateTask template has three parameters with smart defaults:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename CreateParamsT, \n          chi::u32 MethodId = Method::kGetOrCreatePool, \n          bool IS_ADMIN = false>\nstruct BaseCreateTask : public chi::Task\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Template Parameters:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CreateParamsT"}),": Your module's parameter structure (required)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MethodId"}),": Method ID for the task (default: ",(0,r.jsx)(n.code,{children:"kGetOrCreatePool"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IS_ADMIN"}),": Whether this is an admin operation (default: ",(0,r.jsx)(n.code,{children:"false"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"GetOrCreatePoolTask Template:"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"GetOrCreatePoolTask"})," template is a convenient alias that uses the optimal defaults for non-admin modules:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename CreateParamsT>\nusing GetOrCreatePoolTask = BaseCreateTask<CreateParamsT, Method::kGetOrCreatePool, false>;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use Each Pattern:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GetOrCreatePoolTask"}),": For all non-admin ChiMods (recommended)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BaseCreateTask with Method::kCreate"}),": Only for admin module internal operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BaseCreateTask with Method::kGetOrCreatePool"}),": Same as GetOrCreatePoolTask (not typically used directly)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"basecreatetask-structure",children:"BaseCreateTask Structure"}),"\n",(0,r.jsx)(n.p,{children:"BaseCreateTask provides a unified structure for container creation and pool operations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename CreateParamsT, chi::u32 MethodId, bool IS_ADMIN>\nstruct BaseCreateTask : public chi::Task {\n  // Pool operation parameters\n  INOUT chi::string chimod_name_;     // ChiMod name for loading\n  IN chi::string pool_name_;          // Target pool name\n  INOUT chi::string chimod_params_;   // Serialized CreateParamsT\n  INOUT chi::PoolId pool_id_;          // Input: requested ID, Output: actual ID\n  \n  // Results\n  OUT chi::u32 result_code_;           // 0 = success, non-zero = error\n  OUT chi::string error_message_;     // Error description if failed\n  \n  // Runtime flag set by template parameter\n  volatile bool is_admin_;             // Set to IS_ADMIN template value\n  \n  // Serialization methods\n  template<typename... Args>\n  void SetParams(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc, Args &&...args);\n  \n  CreateParamsT GetParams(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc) const;\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single pool_id"}),": Serves as both input (requested) and output (result)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serialized parameters"}),": ",(0,r.jsx)(n.code,{children:"chimod_params_"})," stores serialized CreateParamsT"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error checking"}),": Use ",(0,r.jsx)(n.code,{children:"result_code_ != 0"})," to check for failures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Template-driven behavior"}),": IS_ADMIN template parameter sets volatile variable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No static casting"}),": Direct method assignment using namespace constants"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Non-Admin ChiMod Container Creation (Recommended):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Use GetOrCreatePoolTask for all non-admin modules\nusing CreateTask = chimaera::admin::GetOrCreatePoolTask<MyCreateParams>;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Admin Module Container Creation:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Admin module uses BaseCreateTask with Method::kCreate and IS_ADMIN=true\nusing CreateTask = chimaera::admin::BaseCreateTask<AdminCreateParams, Method::kCreate, true>;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Alternative (Not Recommended):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Direct BaseCreateTask usage - GetOrCreatePoolTask is cleaner\nusing CreateTask = chimaera::admin::BaseCreateTask<MyCreateParams, Method::kGetOrCreatePool, false>;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"migration-from-custom-createtask",children:"Migration from Custom CreateTask"}),"\n",(0,r.jsx)(n.p,{children:"If you have existing custom CreateTask implementations, migrate to BaseCreateTask:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Before (Custom Implementation):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct CreateTask : public chi::Task {\n  // Custom constructor implementations\n  explicit CreateTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc,\n                      const chi::TaskId &task_id,\n                      const chi::PoolId &pool_id,\n                      const chi::PoolQuery &pool_query)\n      : chi::Task(alloc, task_id, pool_id, pool_query, 0) {\n    method_ = Method::kCreate;  // Static casting required\n    // ... initialization code ...\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"After (GetOrCreatePoolTask - Recommended for Non-Admin Modules):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Create params structure\nstruct CreateParams {\n  static constexpr const char* chimod_lib_name = "chimaera_mymodule";\n  // ... other params ...\n  template<class Archive> void serialize(Archive& ar) { /* ... */ }\n};\n\n// Simple type alias using GetOrCreatePoolTask - no custom implementation needed\nusing CreateTask = chimaera::admin::GetOrCreatePoolTask<CreateParams>;\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits of Migration:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No static casting"}),": Direct use of ",(0,r.jsx)(n.code,{children:"Method::kCreate"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Standardized structure"}),": Consistent across all modules"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Built-in serialization"}),": SetParams/GetParams methods included"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error handling"}),": Standardized result_code and error_message"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Less boilerplate"}),": No need to implement constructors manually"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"data-annotations",children:"Data Annotations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"IN"}),": Input-only parameters (read by runtime)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"OUT"}),": Output-only parameters (written by runtime)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"INOUT"}),": Bidirectional parameters"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"task-lifecycle",children:"Task Lifecycle"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Client allocates task in shared memory using ",(0,r.jsx)(n.code,{children:"ipc_manager->NewTask()"})]}),"\n",(0,r.jsx)(n.li,{children:"Client enqueues task pointer to IPC queue"}),"\n",(0,r.jsx)(n.li,{children:"Worker dequeues and executes task"}),"\n",(0,r.jsxs)(n.li,{children:["Framework calls ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})," to deallocate task from shared memory"]}),"\n",(0,r.jsx)(n.li,{children:"Task memory is properly reclaimed from the appropriate memory segment"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Individual ",(0,r.jsx)(n.code,{children:"DelTaskType"})," methods are no longer required. The framework's autogenerated Del dispatcher automatically calls ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})," for proper shared memory deallocation."]}),"\n",(0,r.jsx)(n.h3,{id:"framework-del-implementation",children:"Framework Del Implementation"}),"\n",(0,r.jsx)(n.p,{children:"The autogenerated Del dispatcher handles task cleanup:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"inline void Del(Runtime* runtime, chi::u32 method, hipc::FullPtr<chi::Task> task_ptr) {\n  auto* ipc_manager = CHI_IPC;\n  Method method_enum = static_cast<Method>(method);\n\n  switch (method_enum) {\n    case Method::kCreate: {\n      ipc_manager->DelTask(task_ptr.Cast<CreateTask>());\n      break;\n    }\n    case Method::kCustom: {\n      ipc_manager->DelTask(task_ptr.Cast<CustomTask>());\n      break;\n    }\n    default:\n      ipc_manager->DelTask(task_ptr);\n      break;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This ensures proper shared memory deallocation without requiring module-specific cleanup code."}),"\n",(0,r.jsx)(n.h2,{id:"synchronization-primitives",children:"Synchronization Primitives"}),"\n",(0,r.jsxs)(n.p,{children:["Chimaera provides specialized cooperative synchronization primitives designed for the runtime's task-based architecture. ",(0,r.jsx)(n.strong,{children:"These should be used instead of standard synchronization primitives"})," like ",(0,r.jsx)(n.code,{children:"std::mutex"}),", ",(0,r.jsx)(n.code,{children:"std::shared_mutex"}),", or ",(0,r.jsx)(n.code,{children:"pthread_mutex"})," when synchronizing access to module data structures."]}),"\n",(0,r.jsx)(n.h3,{id:"why-use-chimaera-synchronization-primitives",children:"Why Use Chimaera Synchronization Primitives?"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Critical: Always use CoMutex and CoRwLock for module synchronization:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cooperative Design"}),": Compatible with Chimaera's fiber-based task execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TaskId Grouping"}),": Tasks sharing the same TaskId can proceed together (bypassing locks)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deadlock Prevention"}),": Designed to prevent deadlocks in the runtime environment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Integration"}),": Automatically integrate with CHI_CUR_WORKER and task context"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Optimized for the runtime's execution model"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Do NOT use these standard synchronization primitives in module code:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.code,{children:"std::mutex"})," - Can cause fiber blocking issues"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.code,{children:"std::shared_mutex"})," - Not compatible with task execution model"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.code,{children:"pthread_mutex_t"})," - Can deadlock with runtime scheduling"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.code,{children:"std::condition_variable"})," - Incompatible with cooperative scheduling"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"comutex-cooperative-mutual-exclusion",children:"CoMutex: Cooperative Mutual Exclusion"}),"\n",(0,r.jsx)(n.p,{children:"CoMutex provides mutual exclusion with TaskId grouping support. Tasks sharing the same TaskId can bypass the lock and execute concurrently."}),"\n",(0,r.jsx)(n.h4,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <chimaera/comutex.h>\n\nclass Runtime : public chi::Container {\nprivate:\n  // Static member for shared synchronization across all container instances\n  static chi::CoMutex shared_mutex_;\n  \n  // Instance member for per-container synchronization\n  chi::CoMutex instance_mutex_;\n\npublic:\n  void SomeTask(hipc::FullPtr<SomeTaskType> task, chi::RunContext& rctx) {\n    // Manual lock/unlock\n    shared_mutex_.Lock();\n    // ... critical section ...\n    shared_mutex_.Unlock();\n    \n    // OR use RAII scoped lock (recommended)\n    chi::ScopedCoMutex lock(instance_mutex_);\n    // ... critical section ...\n    // Automatically unlocks when leaving scope\n  }\n};\n\n// Static member definition (required)\nchi::CoMutex Runtime::shared_mutex_;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Task Context"}),": Uses CHI_CUR_WORKER internally - no task parameters needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TaskId Grouping"}),": Tasks with the same TaskId bypass the mutex"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RAII Support"}),": ScopedCoMutex for automatic lock management"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Try-Lock Support"}),": Non-blocking lock attempts"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"api-reference",children:"API Reference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"namespace chi {\n  class CoMutex {\n  public:\n    // Blocking operations\n    void Lock();                    // Block until lock acquired\n    void Unlock();                  // Release the lock\n    bool TryLock();                 // Non-blocking lock attempt\n    \n    // No task parameters needed - uses CHI_CUR_WORKER automatically\n  };\n  \n  // RAII wrapper (recommended)\n  class ScopedCoMutex {\n  public:\n    explicit ScopedCoMutex(CoMutex& mutex);  // Locks in constructor\n    ~ScopedCoMutex();                        // Unlocks in destructor\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"corwlock-cooperative-reader-writer-lock",children:"CoRwLock: Cooperative Reader-Writer Lock"}),"\n",(0,r.jsx)(n.p,{children:"CoRwLock provides reader-writer semantics with TaskId grouping. Multiple readers can proceed concurrently, but writers have exclusive access."}),"\n",(0,r.jsx)(n.h4,{id:"basic-usage-1",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <chimaera/corwlock.h>\n\nclass Runtime : public chi::Container {\nprivate:\n  static chi::CoRwLock data_lock_;  // Protect shared data structures\n\npublic:\n  void ReadTask(hipc::FullPtr<ReadTaskType> task, chi::RunContext& rctx) {\n    // Manual reader lock\n    data_lock_.ReadLock();\n    // ... read operations ...\n    data_lock_.ReadUnlock();\n    \n    // OR use RAII scoped reader lock (recommended)\n    chi::ScopedCoRwReadLock lock(data_lock_);\n    // ... read operations ...\n    // Automatically unlocks when leaving scope\n  }\n  \n  void WriteTask(hipc::FullPtr<WriteTaskType> task, chi::RunContext& rctx) {\n    // RAII scoped writer lock (recommended)\n    chi::ScopedCoRwWriteLock lock(data_lock_);\n    // ... write operations ...\n    // Automatically unlocks when leaving scope\n  }\n};\n\n// Static member definition\nchi::CoRwLock Runtime::data_lock_;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"key-features-1",children:"Key Features"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiple Readers"}),": Concurrent read access when no writers are active"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Exclusive Writers"}),": Writers get exclusive access, blocking all other operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TaskId Grouping"}),": Tasks with same TaskId can bypass reader locks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Context"}),": Uses CHI_CUR_WORKER for task identification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RAII Support"}),": Scoped locks for both readers and writers"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"api-reference-1",children:"API Reference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"namespace chi {\n  class CoRwLock {\n  public:\n    // Reader operations\n    void ReadLock();                // Acquire reader lock\n    void ReadUnlock();              // Release reader lock\n    bool TryReadLock();             // Non-blocking reader lock attempt\n    \n    // Writer operations  \n    void WriteLock();               // Acquire exclusive writer lock\n    void WriteUnlock();             // Release writer lock\n    bool TryWriteLock();            // Non-blocking writer lock attempt\n  };\n  \n  // RAII wrappers (recommended)\n  class ScopedCoRwReadLock {\n  public:\n    explicit ScopedCoRwReadLock(CoRwLock& lock);  // Acquire read lock\n    ~ScopedCoRwReadLock();                        // Release read lock\n  };\n  \n  class ScopedCoRwWriteLock {\n  public:\n    explicit ScopedCoRwWriteLock(CoRwLock& lock); // Acquire write lock\n    ~ScopedCoRwWriteLock();                       // Release write lock\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"taskid-grouping-behavior",children:"TaskId Grouping Behavior"}),"\n",(0,r.jsx)(n.p,{children:"Both CoMutex and CoRwLock support TaskId grouping, which allows related tasks to bypass synchronization:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Tasks created with the same TaskId can proceed together\nauto task_id = chi::CreateTaskId();\n\n// These tasks share the same TaskId - they can bypass CoMutex/CoRwLock\nauto task1 = ipc_manager->NewTask<Task1>(task_id, pool_id, pool_query, ...);\nauto task2 = ipc_manager->NewTask<Task2>(task_id, pool_id, pool_query, ...);\n\n// This task has a different TaskId - must respect locks normally\nauto task3 = ipc_manager->NewTask<Task3>(chi::CreateTaskId(), pool_id, pool_query, ...);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Tasks with the same TaskId are considered "grouped" and can bypass locks'}),"\n",(0,r.jsx)(n.li,{children:"Use TaskId grouping for logically related operations that don't need mutual exclusion"}),"\n",(0,r.jsx)(n.li,{children:"Different TaskIds must respect normal lock semantics"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use RAII Wrappers"}),": Always prefer ",(0,r.jsx)(n.code,{children:"ScopedCoMutex"})," and ",(0,r.jsx)(n.code,{children:"ScopedCoRw*Lock"})," over manual lock/unlock"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static vs Instance"}),": Use static members for cross-container synchronization, instance members for per-container data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Member Definition"}),": Don't forget to define static members in your .cc file"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Choose Appropriate Lock"}),": Use CoRwLock for read-heavy workloads, CoMutex for simple mutual exclusion"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal Critical Sections"}),": Keep locked sections as small as possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TaskId Design"}),": Group related tasks that can safely bypass locks"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-module-with-synchronized-data-structure",children:"Example: Module with Synchronized Data Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// In MOD_NAME_runtime.h\nclass Runtime : public chi::Container {\nprivate:\n  // Synchronized data structure\n  chi::hash_map<chi::u32, ModuleData> data_map_;\n  \n  // Synchronization primitives\n  static chi::CoRwLock data_lock_;        // For data_map_ access\n  static chi::CoMutex operation_mutex_;   // For exclusive operations\n\npublic:\n  void ReadData(hipc::FullPtr<ReadDataTask> task, chi::RunContext& rctx);\n  void WriteData(hipc::FullPtr<WriteDataTask> task, chi::RunContext& rctx);\n  void ExclusiveOperation(hipc::FullPtr<ExclusiveTask> task, chi::RunContext& rctx);\n};\n\n// In MOD_NAME_runtime.cc  \nchi::CoRwLock Runtime::data_lock_;\nchi::CoMutex Runtime::operation_mutex_;\n\nvoid Runtime::ReadData(hipc::FullPtr<ReadDataTask> task, chi::RunContext& rctx) {\n  chi::ScopedCoRwReadLock lock(data_lock_);  // Multiple readers allowed\n  \n  // Safe to read data_map_ concurrently\n  auto it = data_map_.find(task->key_);\n  if (it != data_map_.end()) {\n    task->result_data_ = it->second;\n    task->result_ = 0;  // Success\n  } else {\n    task->result_ = 1;  // Not found\n  }\n}\n\nvoid Runtime::WriteData(hipc::FullPtr<WriteDataTask> task, chi::RunContext& rctx) {\n  chi::ScopedCoRwWriteLock lock(data_lock_);  // Exclusive writer access\n  \n  // Safe to modify data_map_ exclusively\n  data_map_[task->key_] = task->new_data_;\n  task->result_ = 0;  // Success\n}\n\nvoid Runtime::ExclusiveOperation(hipc::FullPtr<ExclusiveTask> task, chi::RunContext& rctx) {\n  chi::ScopedCoMutex lock(operation_mutex_);  // Exclusive operation\n  \n  // Perform operation that requires complete exclusivity\n  // ... complex operation ...\n  task->result_ = 0;  // Success\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This synchronization model ensures thread-safe access to module data structures while maintaining compatibility with Chimaera's cooperative task execution system."}),"\n",(0,r.jsx)(n.h2,{id:"pool-query-and-task-routing",children:"Pool Query and Task Routing"}),"\n",(0,r.jsx)(n.h3,{id:"overview-of-poolquery",children:"Overview of PoolQuery"}),"\n",(0,r.jsx)(n.p,{children:"PoolQuery is a fundamental component of Chimaera's task routing system that determines where and how tasks are executed across the distributed runtime. It provides flexible routing strategies for load balancing, locality optimization, and distributed execution patterns."}),"\n",(0,r.jsx)(n.h3,{id:"poolquery-types",children:"PoolQuery Types"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"chi::PoolQuery"})," class provides six different routing modes through static factory methods:"]}),"\n",(0,r.jsx)(n.h4,{id:"1-local-mode",children:"1. Local Mode"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"chi::PoolQuery::Local()\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Routes tasks to the local node only"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Operations that must execute on the calling node"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": MPI-based container creation, node-specific diagnostics"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Client usage in MPI environment\nconst chi::PoolId custom_pool_id(7000, 0);\nclient.Create(HSHM_MCTX, chi::PoolQuery::Local(), "my_pool", custom_pool_id);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"2-direct-id-mode",children:"2. Direct ID Mode"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"chi::PoolQuery::DirectId(ContainerId container_id)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Routes to a specific container by its unique ID"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Targeted operations on known containers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Container-specific configuration changes"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Route to container with ID 42\nauto query = chi::PoolQuery::DirectId(ContainerId(42));\nclient.UpdateConfig(HSHM_MCTX, query, new_config);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"3-direct-hash-mode",children:"3. Direct Hash Mode"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"chi::PoolQuery::DirectHash(u32 hash)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Routes using consistent hash-based load balancing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Distributing operations across containers deterministically"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Key-value store operations where keys map to specific containers"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Hash-based routing for a key\nu32 hash = std::hash<std::string>{}(key);\nauto query = chi::PoolQuery::DirectHash(hash);\nclient.Put(HSHM_MCTX, query, key, value);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"4-range-mode",children:"4. Range Mode"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"chi::PoolQuery::Range(u32 offset, u32 count)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Routes to a range of containers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Batch operations across multiple containers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Parallel scan operations, bulk updates"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Process containers 10-19 (10 containers starting at offset 10)\nauto query = chi::PoolQuery::Range(10, 10);\nclient.BulkUpdate(HSHM_MCTX, query, update_data);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"5-broadcast-mode",children:"5. Broadcast Mode"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"chi::PoolQuery::Broadcast()\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Routes to all containers in the pool"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Global operations affecting all containers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Configuration updates, global cache invalidation"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Broadcast configuration change to all containers\nauto query = chi::PoolQuery::Broadcast();\nclient.InvalidateCache(HSHM_MCTX, query);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"6-physical-mode",children:"6. Physical Mode"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"chi::PoolQuery::Physical(u32 node_id)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Routes to a specific physical node by ID"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Node-specific operations in distributed deployments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Remote node administration, cross-node data migration"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Execute on physical node 3\nauto query = chi::PoolQuery::Physical(3);\nclient.NodeDiagnostics(HSHM_MCTX, query);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"7-dynamic-mode-recommended-for-create-operations",children:"7. Dynamic Mode (Recommended for Create Operations)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"chi::PoolQuery::Dynamic()\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Intelligent routing with automatic caching optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Create operations that benefit from local cache checking"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Behavior"}),": Uses dynamic scheduling (ExecMode::kDynamicSchedule) for cache optimization","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check if pool exists locally using PoolManager"}),"\n",(0,r.jsx)(n.li,{children:"If pool exists: change pool_query to Local (execute locally using existing pool)"}),"\n",(0,r.jsx)(n.li,{children:"If pool doesn't exist: change pool_query to Broadcast (create pool on all nodes)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Avoids redundant pool creation attempts"}),"\n",(0,r.jsx)(n.li,{children:"Eliminates unnecessary network overhead for existing pools"}),"\n",(0,r.jsx)(n.li,{children:"Automatic fallback to broadcast creation when needed"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Container creation with automatic caching"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Recommended: Use Dynamic() for Create operations\nconst chi::PoolId custom_pool_id(7000, 0);\nclient.Create(HSHM_MCTX, chi::PoolQuery::Dynamic(), "my_pool", custom_pool_id);\n\n// Dynamic scheduling will:\n// - Check local cache for "my_pool"\n// - If found: switch to Local mode (fast path)\n// - If not found: switch to Broadcast mode (creation path)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"poolquery-usage-guidelines",children:"PoolQuery Usage Guidelines"}),"\n",(0,r.jsx)(n.h4,{id:"best-practices-1",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Never use null queries"}),": Always specify an explicit PoolQuery type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Default to Dynamic for Create"}),": Use ",(0,r.jsx)(n.code,{children:"PoolQuery::Dynamic()"})," for container creation to enable automatic caching optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Alternative: Use Broadcast or Local explicitly"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"Broadcast()"})," when you want to force distributed creation regardless of cache"]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"Local()"})," in MPI jobs when you want node-local containers only"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider locality"}),": Prefer local execution to minimize network overhead for regular operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate granularity"}),": Match routing mode to operation scope"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Container Creation Pattern (Recommended)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Recommended: Use Dynamic for automatic cache optimization\n// This checks local cache first and falls back to broadcast creation if needed\nconst chi::PoolId custom_pool_id(7000, 0);\nclient.Create(HSHM_MCTX, chi::PoolQuery::Dynamic(), "my_pool_name", custom_pool_id);\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Container Creation Pattern (Explicit Broadcast)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Alternative: Use Broadcast to force distributed creation regardless of cache\n// This ensures the container is created across all nodes in distributed environments\nconst chi::PoolId custom_pool_id(7000, 0);\nclient.Create(HSHM_MCTX, chi::PoolQuery::Broadcast(), "my_pool_name", custom_pool_id);\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Container Creation Pattern (MPI Environments)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// In MPI jobs, Local may be more efficient for node-local containers\n// Use Local when you want node-local containers only\nconst chi::PoolId custom_pool_id(7000, 0);\nclient.Create(HSHM_MCTX, chi::PoolQuery::Local(), "my_pool_name", custom_pool_id);\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Load-Balanced Operations"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Use hash-based routing for even distribution\nfor (const auto& item : items) {\n  u32 hash = ComputeHash(item.id);\n  auto query = chi::PoolQuery::DirectHash(hash);\n  client.Process(HSHM_MCTX, query, item);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Batch Processing"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Process containers in chunks\nconst u32 total_containers = pool_info->num_containers_;\nconst u32 batch_size = 10;\nfor (u32 offset = 0; offset < total_containers; offset += batch_size) {\n  u32 count = std::min(batch_size, total_containers - offset);\n  auto query = chi::PoolQuery::Range(offset, count);\n  client.BatchProcess(HSHM_MCTX, query, batch_data);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"runtime-routing-implementation",children:"Runtime Routing Implementation"}),"\n",(0,r.jsx)(n.p,{children:"The runtime uses PoolQuery to determine task routing through several stages:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Query Validation"}),": Ensures the query parameters are valid"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Container Resolution"}),": Maps query to specific container(s)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task Distribution"}),": Routes task to appropriate worker queues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Load Balancing"}),": Applies distribution strategies for multi-container queries"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"poolquery-in-task-definitions",children:"PoolQuery in Task Definitions"}),"\n",(0,r.jsx)(n.p,{children:"Tasks must include PoolQuery in their constructors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class CustomTask : public chi::Task {\n public:\n  CustomTask(hipc::Allocator *alloc,\n             const chi::TaskId &task_id,\n             const chi::PoolId &pool_id,\n             const chi::PoolQuery &pool_query,  // Required parameter\n             /* custom parameters */)\n      : chi::Task(alloc, task_id, pool_id, pool_query, method_id) {\n    // Task initialization\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-poolquery-features",children:"Advanced PoolQuery Features"}),"\n",(0,r.jsx)(n.h4,{id:"query-introspection",children:"Query Introspection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"PoolQuery query = PoolQuery::Range(0, 10);\n\n// Check routing mode\nif (query.IsRangeMode()) {\n  u32 offset = query.GetRangeOffset();\n  u32 count = query.GetRangeCount();\n  // Process range parameters\n}\n\n// Get routing mode enum\nRoutingMode mode = query.GetRoutingMode();\nswitch (mode) {\n  case RoutingMode::Local:\n    // Handle local routing\n    break;\n  case RoutingMode::Broadcast:\n    // Handle broadcast\n    break;\n  // ... other cases\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"combining-with-task-priorities",children:"Combining with Task Priorities"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// High-priority broadcast\nauto query = chi::PoolQuery::Broadcast();\nauto task = ipc_manager->NewTask<UpdateTask>(\n    chi::CreateTaskId(),\n    pool_id,\n    query,\n    update_data\n);\nipc_manager->Enqueue(task, chi::kHighPriority);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"troubleshooting-poolquery-issues",children:"Troubleshooting PoolQuery Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Common Errors"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Null Query Error"}),': "NEVER use a null pool query"']}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Solution: Always use a factory method like ",(0,r.jsx)(n.code,{children:"PoolQuery::Local()"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Invalid Container ID"}),": Container not found for DirectId query"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Solution: Verify container exists before using DirectId"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Range Out of Bounds"}),": Range exceeds available containers"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Solution: Check pool size before creating Range queries"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Node ID Invalid"}),": Physical node ID doesn't exist"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Solution: Validate node IDs against cluster configuration"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"client-server-communication",children:"Client-Server Communication"}),"\n",(0,r.jsx)(n.h3,{id:"client-implementation-patterns",children:"Client Implementation Patterns"}),"\n",(0,r.jsx)(n.h4,{id:"critical-pool-id-update-pattern",children:"Critical Pool ID Update Pattern"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"IMPORTANT"}),": All ChiMod clients that implement Create methods MUST update their ",(0,r.jsx)(n.code,{children:"pool_id_"})," field with the actual pool ID returned from completed CreateTask operations. This is essential because:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"CreateTask operations may return a different pool ID than initially specified"}),"\n",(0,r.jsx)(n.li,{children:"Pool creation may reuse existing pools with different IDs"}),"\n",(0,r.jsx)(n.li,{children:"Subsequent client operations depend on the correct pool ID"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Pattern for All Client Create Methods:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void Create(const hipc::MemContext& mctx,\n            const chi::PoolQuery& pool_query,\n            const std::string& pool_name,\n            const chi::PoolId& custom_pool_id,\n            /* other module-specific parameters */) {\n    auto task = AsyncCreate(mctx, pool_query, pool_name, custom_pool_id, /* other params */);\n    task->Wait();\n\n    // CRITICAL: Update client pool_id_ with the actual pool ID from the task\n    pool_id_ = task->new_pool_id_;\n\n    CHI_IPC->DelTask(task);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Parameters for All Create Methods:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mctx"}),": Memory context for shared memory allocations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pool_query"}),": Task routing strategy (use ",(0,r.jsx)(n.code,{children:"Broadcast()"})," for non-MPI, ",(0,r.jsx)(n.code,{children:"Local()"})," for MPI)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pool_name"}),": User-provided name for the pool (must be unique, used as file path for file-based modules)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"custom_pool_id"}),": Explicit pool ID for the container being created (must not be null)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module-specific parameters"}),": Additional parameters specific to the ChiMod (e.g., BDev type, size)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why This Is Required:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pool Reuse"}),": CreateTask is actually a GetOrCreatePoolTask that may return an existing pool"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ID Assignment"}),": The admin ChiMod may assign a different pool ID than requested"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client Consistency"}),": All subsequent operations must use the correct pool ID"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distributed Operation"}),": Pool IDs must be consistent across all client instances"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples of Correct Implementation:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Admin client Create method\nvoid Create(const hipc::MemContext& mctx,\n            const chi::PoolQuery& pool_query,\n            const std::string& pool_name,\n            const chi::PoolId& custom_pool_id) {\n    auto task = AsyncCreate(mctx, pool_query, pool_name, custom_pool_id);\n    task->Wait();\n\n    // CRITICAL: Update client pool_id_ with the actual pool ID from the task\n    pool_id_ = task->new_pool_id_;\n\n    auto* ipc_manager = CHI_IPC;\n    ipc_manager->DelTask(task);\n}\n\n// BDev client Create method (with module-specific parameters)\nvoid Create(const hipc::MemContext& mctx,\n            const chi::PoolQuery& pool_query,\n            const std::string& pool_name,\n            const chi::PoolId& custom_pool_id,\n            BdevType bdev_type,\n            chi::u64 total_size = 0,\n            chi::u32 io_depth = 128,\n            chi::u32 alignment = 4096) {\n    auto task = AsyncCreate(mctx, pool_query, pool_name, custom_pool_id,\n                           bdev_type, total_size, io_depth, alignment);\n    task->Wait();\n\n    // CRITICAL: Update client pool_id_ with the actual pool ID from the task\n    pool_id_ = task->new_pool_id_;\n\n    CHI_IPC->DelTask(task);\n}\n\n// MOD_NAME client Create method (simple case)\nvoid Create(const hipc::MemContext& mctx,\n            const chi::PoolQuery& pool_query,\n            const std::string& pool_name,\n            const chi::PoolId& custom_pool_id) {\n    auto task = AsyncCreate(mctx, pool_query, pool_name, custom_pool_id);\n    task->Wait();\n\n    // CRITICAL: Update client pool_id_ with the actual pool ID from the task\n    pool_id_ = task->new_pool_id_;\n\n    CHI_IPC->DelTask(task);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Mistakes to Avoid:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Using null PoolId for custom_pool_id"}),": Create operations REQUIRE explicit, non-null pool IDs"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Forgetting to update pool_id_"}),": Leads to incorrect pool ID for subsequent operations"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Using original pool_id_"}),": The task may return a different pool ID than initially specified"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Updating before task completion"}),": Always wait for task completion before reading new_pool_id_"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Not implementing this pattern"}),": All synchronous Create methods must follow this pattern"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Using Local instead of Broadcast"}),": In non-MPI environments, use ",(0,r.jsx)(n.code,{children:"Broadcast()"})," for distributed container creation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Critical Validation:"})}),"\n",(0,r.jsxs)(n.p,{children:["The runtime validates that ",(0,r.jsx)(n.code,{children:"custom_pool_id"})," is not null during Create operations. If a null PoolId is provided, the Create operation will fail with an error:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// WRONG - This will fail with error\nchi::PoolId null_id;  // Null pool ID\nclient.Create(HSHM_MCTX, chi::PoolQuery::Broadcast(), "my_pool", null_id);\n// Error: "Cannot create pool with null PoolId. Explicit pool IDs are required."\n\n// CORRECT - Always provide explicit pool IDs\nconst chi::PoolId custom_pool_id(7000, 0);\nclient.Create(HSHM_MCTX, chi::PoolQuery::Broadcast(), "my_pool", custom_pool_id);\n'})}),"\n",(0,r.jsx)(n.p,{children:"This pattern is mandatory for all ChiMod clients and ensures correct pool ID management throughout the client lifecycle."}),"\n",(0,r.jsx)(n.h3,{id:"memory-segments",children:"Memory Segments"}),"\n",(0,r.jsx)(n.p,{children:"Three shared memory segments are used:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Main Segment"}),": Tasks and control structures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client Data Segment"}),": User data buffers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Data Segment"}),": Runtime-only data"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ipc-queue",children:"IPC Queue"}),"\n",(0,r.jsx)(n.p,{children:"Tasks are submitted via a lock-free multi-producer single-consumer queue:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Client side\nauto task = ipc_manager->NewTask<CustomTask>(...);\nipc_manager->Enqueue(task, chi::kLowLatency);\n\n// Server side\nhipc::Pointer task_ptr = ipc_manager->Dequeue(chi::kLowLatency);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsx)(n.h3,{id:"allocator-usage",children:"Allocator Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Get context allocator for current segment\nhipc::CtxAllocator<CHI_MAIN_ALLOC_T> ctx_alloc(HSHM_MCTX, allocator);\n\n// Allocate serializable string\nchi::string my_string(ctx_alloc, "initial value");\n\n// Allocate vector\nchi::vector<u32> my_vector(ctx_alloc);\nmy_vector.resize(100);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"best-practices-2",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Always use HSHM types for shared data"}),"\n",(0,r.jsx)(n.li,{children:"Pass CtxAllocator to constructors"}),"\n",(0,r.jsx)(n.li,{children:"Use FullPtr for cross-process references"}),"\n",(0,r.jsxs)(n.li,{children:["Let framework handle task cleanup via ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"task-allocation-and-deallocation-pattern",children:"Task Allocation and Deallocation Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Client side - allocation (NewTask uses main allocator automatically)\nauto task = ipc_manager->NewTask<CustomTask>(\n    chi::CreateTaskId(),\n    pool_id_,\n    pool_query,\n    input_data,\n    operation_id);\n\n// Client side - cleanup (after task completion)\nipc_manager->DelTask(task);\n\n// Runtime side - automatic cleanup (no code needed)\n// Framework Del dispatcher calls ipc_manager->DelTask() automatically\n"})}),"\n",(0,r.jsx)(n.h3,{id:"chi_ipc-buffer-allocation",children:"CHI_IPC Buffer Allocation"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"CHI_IPC"})," singleton provides centralized buffer allocation for shared memory operations in client code. Use this for allocating temporary buffers that need to be shared between client and runtime processes."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important"}),": ",(0,r.jsx)(n.code,{children:"AllocateBuffer"})," returns ",(0,r.jsx)(n.code,{children:"hipc::FullPtr<char>"}),", not ",(0,r.jsx)(n.code,{children:"hipc::Pointer"}),". It is NOT a template function."]}),"\n",(0,r.jsx)(n.h4,{id:"basic-usage-2",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <chimaera/chimaera.h>\n\n// Get the IPC manager singleton\nauto* ipc_manager = CHI_IPC;\n\n// Allocate a buffer in shared memory (returns FullPtr<char>)\nsize_t buffer_size = 1024;\nhipc::FullPtr<char> buffer_ptr = ipc_manager->AllocateBuffer(buffer_size);\n\n// Use the buffer (example: copy data into it)\nchar* buffer_data = buffer_ptr.ptr_;\nmemcpy(buffer_data, source_data, data_size);\n\n// Alternative: Use directly\nstrncpy(buffer_ptr.ptr_, "example data", buffer_size);\n\n// The buffer will be automatically freed when buffer_ptr goes out of scope\n// or when explicitly deallocated by the framework\n'})}),"\n",(0,r.jsx)(n.h4,{id:"use-cases-for-chi_ipc-buffers",children:"Use Cases for CHI_IPC Buffers"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Temporary data transfer"}),": When passing large data to tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Intermediate storage"}),": For computations that need shared memory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I/O operations"}),": Reading/writing data that needs to be accessible by runtime"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"best-practices-3",children:"Best Practices"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// \u2705 Good: Use CHI_IPC for temporary shared buffers\nauto* ipc_manager = CHI_IPC;\nhipc::FullPtr<char> temp_buffer = ipc_manager->AllocateBuffer(data_size);\n\n// \u2705 Good: Use chi::ipc types for persistent task data\nchi::ipc::string task_string(ctx_alloc, "persistent data");\n\n// \u274c Avoid: Don\'t use CHI_IPC for small, simple task parameters\n// Use chi::ipc types directly in task definitions instead\n'})}),"\n",(0,r.jsx)(n.h3,{id:"shared-memory-compatible-data-structures",children:"Shared-Memory Compatible Data Structures"}),"\n",(0,r.jsx)(n.p,{children:"For task definitions and any data that needs to be shared between client and runtime processes, always use shared-memory compatible types instead of standard C++ containers."}),"\n",(0,r.jsx)(n.h4,{id:"chiipcstring",children:"chi::ipc::string"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"chi::ipc::string"})," or ",(0,r.jsx)(n.code,{children:"hipc::string"})," instead of ",(0,r.jsx)(n.code,{children:"std::string"})," in task definitions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <[namespace]/types.h>\n\n// Task definition using shared-memory string\nstruct CustomTask : public chi::Task {\n  INOUT hipc::string input_data_;     // Shared-memory compatible string\n  INOUT hipc::string output_data_;    // Results stored in shared memory\n  \n  CustomTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T>& alloc,\n             const std::string& input) \n    : input_data_(alloc, input),      // Initialize from std::string\n      output_data_(alloc) {}          // Empty initialization\n      \n  // Conversion to std::string when needed\n  std::string getResult() const {\n    return std::string(output_data_.data(), output_data_.size());\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"chiipcvector",children:"chi::ipc::vector"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"chi::ipc::vector"})," instead of ",(0,r.jsx)(n.code,{children:"std::vector"})," for arrays in task definitions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Task definition using shared-memory vector\nstruct ProcessArrayTask : public chi::Task {\n  INOUT chi::ipc::vector<chi::u32> data_array_;\n  INOUT chi::ipc::vector<chi::f32> result_array_;\n  \n  ProcessArrayTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T>& alloc,\n                   const std::vector<chi::u32>& input_data)\n    : data_array_(alloc),\n      result_array_(alloc) {\n    // Copy from std::vector to shared-memory vector\n    data_array_.resize(input_data.size());\n    std::copy(input_data.begin(), input_data.end(), data_array_.begin());\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-each-type",children:"When to Use Each Type"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use shared-memory types (chi::ipc::string, hipc::string, chi::ipc::vector, etc.) for:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Task input/output parameters"}),"\n",(0,r.jsx)(n.li,{children:"Data that persists across task execution"}),"\n",(0,r.jsx)(n.li,{children:"Any data structure that needs serialization"}),"\n",(0,r.jsx)(n.li,{children:"Data shared between client and runtime"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use std::string/vector for:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Local variables in client code"}),"\n",(0,r.jsx)(n.li,{children:"Temporary computations"}),"\n",(0,r.jsx)(n.li,{children:"Converting to/from shared-memory types"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"type-conversion-examples",children:"Type Conversion Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Converting between std::string and shared-memory string types\nstd::string std_str = "example data";\nhipc::string shm_str(ctx_alloc, std_str);          // std -> shared memory\nstd::string result = std::string(shm_str);         // shared memory -> std\n\n// Converting between std::vector and shared-memory vector types\nstd::vector<int> std_vec = {1, 2, 3, 4, 5};\nchi::ipc::vector<int> shm_vec(ctx_alloc);\nshm_vec.assign(std_vec.begin(), std_vec.end());    // std -> shared memory\n\nstd::vector<int> result_vec(shm_vec.begin(), shm_vec.end());  // shared memory -> std\n'})}),"\n",(0,r.jsx)(n.h4,{id:"serialization-support",children:"Serialization Support"}),"\n",(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.code,{children:"chi::ipc::string"})," and ",(0,r.jsx)(n.code,{children:"chi::ipc::vector"})," automatically support serialization for task communication:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Task definition - no manual serialization needed\nstruct SerializableTask : public chi::Task {\n  INOUT hipc::string message_;\n  INOUT chi::ipc::vector<chi::u64> timestamps_;\n\n  // Cereal automatically handles chi::ipc types\n  template<class Archive>\n  void serialize(Archive& ar) {\n    ar(message_, timestamps_);  // Works automatically\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"bulk-transfer-support-with-arbulk",children:"Bulk Transfer Support with ar.bulk"}),"\n",(0,r.jsxs)(n.p,{children:["For tasks that involve large data transfers (such as I/O operations), Chimaera provides ",(0,r.jsx)(n.code,{children:"ar.bulk()"})," for efficient bulk data serialization. This feature integrates with the Lightbeam networking layer to enable zero-copy data transfer and RDMA optimization."]}),"\n",(0,r.jsx)(n.h4,{id:"overview-2",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ar.bulk()"})," method marks data pointers for bulk transfer during task serialization. This is essential for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large I/O Operations"}),": Read/write tasks with multi-megabyte payloads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero-Copy Transfer"}),": Avoiding unnecessary data copies during serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RDMA Optimization"}),": Preparing data for remote direct memory access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distributed Execution"}),": Sending tasks with large data buffers across nodes"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"bulk-transfer-flags",children:"Bulk Transfer Flags"}),"\n",(0,r.jsx)(n.p,{children:"Two flags control bulk transfer behavior:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Defined in hermes_shm/lightbeam/lightbeam.h\n#define BULK_EXPOSE  // Metadata only - no data transfer (receiver allocates)\n#define BULK_XFER    // Marks bulk for actual data transmission\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Flag Usage:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BULK_EXPOSE"}),": Sender exposes metadata (size, pointer info) but doesn't transfer data","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Receiver sees the bulk size and allocates local buffer"}),"\n",(0,r.jsx)(n.li,{children:"Useful when receiver will write data (e.g., Read operations)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BULK_XFER"}),": Marks bulk for actual data transmission","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Data is transferred over network"}),"\n",(0,r.jsx)(n.li,{children:"Used when sender has data to send (e.g., Write operations)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"basic-usage-pattern",children:"Basic Usage Pattern"}),"\n",(0,r.jsx)(n.h5,{id:"write-operation-sender-has-data",children:"Write Operation (Sender Has Data)"}),"\n",(0,r.jsx)(n.p,{children:"For write operations, the sender has data to transfer:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct WriteTask : public chi::Task {\n  IN Block block_;              // Block to write to\n  IN hipc::Pointer data_;       // Data buffer pointer\n  IN size_t length_;            // Data length\n  OUT chi::u64 bytes_written_;  // Result\n\n  /** Serialize IN and INOUT parameters */\n  template <typename Archive>\n  void SerializeIn(Archive &ar) {\n    ar(block_, length_);\n    // Use BULK_XFER to transfer data from sender to receiver\n    ar.bulk(data_, length_, BULK_XFER);\n  }\n\n  /** Serialize OUT and INOUT parameters */\n  template <typename Archive>\n  void SerializeOut(Archive &ar) {\n    ar(bytes_written_);\n    // No bulk transfer needed for output (just metadata)\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Workflow:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client Side (SerializeIn)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Serializes ",(0,r.jsx)(n.code,{children:"block_"})," and ",(0,r.jsx)(n.code,{children:"length_"})," metadata"]}),"\n",(0,r.jsxs)(n.li,{children:["Marks ",(0,r.jsx)(n.code,{children:"data_"})," buffer with ",(0,r.jsx)(n.code,{children:"BULK_XFER"})," flag"]}),"\n",(0,r.jsx)(n.li,{children:"Lightbeam transmits the data buffer to receiver"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Side (Execute)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Receives metadata and data buffer"}),"\n",(0,r.jsx)(n.li,{children:"Executes write operation using transferred data"}),"\n",(0,r.jsxs)(n.li,{children:["Sets ",(0,r.jsx)(n.code,{children:"bytes_written_"})," result"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client Side (SerializeOut)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Receives ",(0,r.jsx)(n.code,{children:"bytes_written_"})," result"]}),"\n",(0,r.jsx)(n.li,{children:"No bulk transfer needed for small output values"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"read-operation-receiver-needs-data",children:"Read Operation (Receiver Needs Data)"}),"\n",(0,r.jsx)(n.p,{children:"For read operations, the receiver allocates buffer for incoming data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct ReadTask : public chi::Task {\n  IN Block block_;              // Block to read from\n  OUT hipc::Pointer data_;      // Data buffer pointer (allocated by receiver)\n  INOUT size_t length_;         // Requested/actual length\n  OUT chi::u64 bytes_read_;     // Result\n\n  /** Serialize IN and INOUT parameters */\n  template <typename Archive>\n  void SerializeIn(Archive &ar) {\n    ar(block_, length_);\n    // Use BULK_EXPOSE - metadata only, receiver will allocate buffer\n    ar.bulk(data_, length_, BULK_EXPOSE);\n  }\n\n  /** Serialize OUT and INOUT parameters */\n  template <typename Archive>\n  void SerializeOut(Archive &ar) {\n    ar(length_, bytes_read_);\n    // Use BULK_XFER to transfer read data back to client\n    ar.bulk(data_, length_, BULK_XFER);\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Workflow:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client Side (SerializeIn)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Serializes ",(0,r.jsx)(n.code,{children:"block_"})," and ",(0,r.jsx)(n.code,{children:"length_"})," metadata"]}),"\n",(0,r.jsxs)(n.li,{children:["Marks ",(0,r.jsx)(n.code,{children:"data_"})," with ",(0,r.jsx)(n.code,{children:"BULK_EXPOSE"})," (no data sent yet)"]}),"\n",(0,r.jsx)(n.li,{children:"Receiver sees buffer size needed"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Side (Execute)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Receives metadata including buffer size"}),"\n",(0,r.jsxs)(n.li,{children:["Allocates local buffer for ",(0,r.jsx)(n.code,{children:"data_"})]}),"\n",(0,r.jsx)(n.li,{children:"Executes read operation filling the buffer"}),"\n",(0,r.jsxs)(n.li,{children:["Sets ",(0,r.jsx)(n.code,{children:"length_"})," and ",(0,r.jsx)(n.code,{children:"bytes_read_"})," results"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client Side (SerializeOut)"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Marks ",(0,r.jsx)(n.code,{children:"data_"})," with ",(0,r.jsx)(n.code,{children:"BULK_XFER"})," flag"]}),"\n",(0,r.jsx)(n.li,{children:"Lightbeam transfers read data back to client"}),"\n",(0,r.jsxs)(n.li,{children:["Client receives ",(0,r.jsx)(n.code,{children:"length_"}),", ",(0,r.jsx)(n.code,{children:"bytes_read_"}),", and data buffer"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"api-reference-2",children:"API Reference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename Archive>\nvoid ar.bulk(hipc::Pointer ptr, size_t size, uint32_t flags);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ptr"}),": Pointer to data buffer (",(0,r.jsx)(n.code,{children:"hipc::Pointer"}),", ",(0,r.jsx)(n.code,{children:"hipc::FullPtr"}),", or raw pointer)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"size"}),": Size of data in bytes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"flags"}),": Transfer flags (",(0,r.jsx)(n.code,{children:"BULK_EXPOSE"})," or ",(0,r.jsx)(n.code,{children:"BULK_XFER"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Behavior:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Records bulk transfer metadata in the archive"}),"\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.code,{children:"BULK_XFER"}),": Prepares data for network transmission"]}),"\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.code,{children:"BULK_EXPOSE"}),": Records metadata only (size and pointer info)"]}),"\n",(0,r.jsx)(n.li,{children:"Integrates with Lightbeam networking for actual data transfer"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"advanced-pattern-bidirectional-transfer",children:"Advanced Pattern: Bidirectional Transfer"}),"\n",(0,r.jsx)(n.p,{children:"Some operations require data transfer in both directions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct ProcessTask : public chi::Task {\n  INOUT hipc::Pointer data_;    // Data buffer (modified in-place)\n  INOUT size_t length_;         // Buffer length\n\n  /** Serialize IN and INOUT parameters */\n  template <typename Archive>\n  void SerializeIn(Archive &ar) {\n    ar(length_);\n    // Send input data to runtime\n    ar.bulk(data_, length_, BULK_XFER);\n  }\n\n  /** Serialize OUT and INOUT parameters */\n  template <typename Archive>\n  void SerializeOut(Archive &ar) {\n    ar(length_);\n    // Send modified data back to client\n    ar.bulk(data_, length_, BULK_XFER);\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"integration-with-lightbeam",children:"Integration with Lightbeam"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ar.bulk()"})," calls integrate seamlessly with the Lightbeam networking layer:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Archive Records Bulks"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["TaskOutputArchive stores bulk metadata in ",(0,r.jsx)(n.code,{children:"bulk_transfers_"})," vector"]}),"\n",(0,r.jsx)(n.li,{children:"Each bulk includes pointer, size, and flags"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lightbeam Transmission"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Bulks marked ",(0,r.jsx)(n.code,{children:"BULK_XFER"})," are transmitted via ",(0,r.jsx)(n.code,{children:"Send()"})," and ",(0,r.jsx)(n.code,{children:"RecvBulks()"})]}),"\n",(0,r.jsxs)(n.li,{children:["Bulks marked ",(0,r.jsx)(n.code,{children:"BULK_EXPOSE"})," provide metadata only"]}),"\n",(0,r.jsx)(n.li,{children:"Receiver inspects all bulks to determine buffer sizes"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Zero-Copy Optimization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Data stays in original buffers during serialization"}),"\n",(0,r.jsx)(n.li,{children:"Only pointers and metadata are serialized"}),"\n",(0,r.jsx)(n.li,{children:"Actual data transfer handled separately by Lightbeam"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"complete-example-bdev-read-task",children:"Complete Example: BDev Read Task"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct ReadTask : public chi::Task {\n  IN Block block_;              // Block descriptor\n  OUT hipc::Pointer data_;      // Data buffer\n  INOUT size_t length_;         // Buffer length\n  OUT chi::u64 bytes_read_;     // Bytes actually read\n\n  /** SHM constructor */\n  explicit ReadTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc)\n      : chi::Task(alloc), length_(0), bytes_read_(0) {}\n\n  /** Emplace constructor */\n  explicit ReadTask(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc,\n                    const chi::TaskId &task_node,\n                    const chi::PoolId &pool_id,\n                    const chi::PoolQuery &pool_query,\n                    const Block &block,\n                    hipc::Pointer data,\n                    size_t length)\n      : chi::Task(alloc, task_node, pool_id, pool_query, 10),\n        block_(block), data_(data), length_(length), bytes_read_(0) {\n    task_id_ = task_node;\n    pool_id_ = pool_id;\n    method_ = Method::kRead;\n    task_flags_.Clear();\n    pool_query_ = pool_query;\n  }\n\n  /** Serialize IN and INOUT parameters */\n  template <typename Archive>\n  void SerializeIn(Archive &ar) {\n    ar(block_, length_);\n    // BULK_EXPOSE: Tell receiver the buffer size, but don't send data yet\n    // Receiver will allocate local buffer\n    ar.bulk(data_, length_, BULK_EXPOSE);\n  }\n\n  /** Serialize OUT and INOUT parameters */\n  template <typename Archive>\n  void SerializeOut(Archive &ar) {\n    ar(length_, bytes_read_);\n    // BULK_XFER: Transfer the read data back to client\n    ar.bulk(data_, length_, BULK_XFER);\n  }\n\n  /** Copy from another ReadTask */\n  void Copy(const hipc::FullPtr<ReadTask> &other) {\n    // Copy task-specific fields only\n    // Base Task fields are copied automatically by NewCopy\n    block_ = other->block_;\n    data_ = other->data_;\n    length_ = other->length_;\n    bytes_read_ = other->bytes_read_;\n  }\n\n  /** Aggregate results from replica */\n  void Aggregate(const hipc::FullPtr<ReadTask> &other) {\n    // For reads, just copy the result from the replica\n    Copy(other);\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"best-practices-4",children:"Best Practices"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"DO:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 Use ",(0,r.jsx)(n.code,{children:"BULK_XFER"})," when sender has data to transmit (Write operations)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 Use ",(0,r.jsx)(n.code,{children:"BULK_EXPOSE"})," when receiver needs to allocate buffer (Read operations)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 Always specify both ",(0,r.jsx)(n.code,{children:"SerializeIn()"})," and ",(0,r.jsx)(n.code,{children:"SerializeOut()"})," for consistency"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 Use ",(0,r.jsx)(n.code,{children:"ar.bulk()"})," for data buffers larger than a few KB"]}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Ensure data buffer lifetime extends until serialization completes"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"DON'T:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u274c Don't use ",(0,r.jsx)(n.code,{children:"ar.bulk()"})," for small data (< 4KB) - serialize directly instead"]}),"\n",(0,r.jsx)(n.li,{children:"\u274c Don't forget to specify bulk size - it determines receiver buffer allocation"}),"\n",(0,r.jsxs)(n.li,{children:["\u274c Don't mix ",(0,r.jsx)(n.code,{children:"ar()"})," and ",(0,r.jsx)(n.code,{children:"ar.bulk()"})," for the same data - choose one approach"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c Don't use ",(0,r.jsx)(n.code,{children:"BULK_EXPOSE"})," for write operations (sender has data to send)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u274c Don't use ",(0,r.jsx)(n.code,{children:"BULK_XFER"})," in SerializeIn for read operations (no data to send yet)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Buffer Alignment"}),": Ensure buffers are properly aligned (typically 4KB for I/O operations)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Size Thresholds"}),": Use bulk transfer for data > 4KB; use regular serialization for smaller data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero-Copy"}),": Lightbeam can use zero-copy techniques when data is in shared memory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RDMA Ready"}),": The bulk transfer API is designed for future RDMA transport integration"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Issues:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Missing Data Transfer"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Ensure ",(0,r.jsx)(n.code,{children:"BULK_XFER"})," flag is used when data should be transmitted"]}),"\n",(0,r.jsxs)(n.li,{children:["Check that SerializeOut uses ",(0,r.jsx)(n.code,{children:"BULK_XFER"})," for read operations"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Buffer Size Mismatch"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Verify ",(0,r.jsx)(n.code,{children:"length_"})," parameter matches actual buffer size"]}),"\n",(0,r.jsx)(n.li,{children:"Ensure receiver allocates buffer matching the exposed size"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Serialization Order"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Serialize metadata (block, length) before ",(0,r.jsx)(n.code,{children:"ar.bulk()"})," call"]}),"\n",(0,r.jsx)(n.li,{children:"This ensures receiver knows buffer size before allocating"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"chiunordered_map_ll---lock-free-unordered-map",children:"chi::unordered_map_ll - Lock-Free Unordered Map"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"chi::unordered_map_ll"})," is a hash map implementation using a vector of lists design that provides efficient concurrent access when combined with external locking. This container is specifically designed for runtime module data structures that require external synchronization control."]}),"\n",(0,r.jsx)(n.h4,{id:"overview-3",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Characteristics:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vector of Lists Design"}),": Uses a vector of buckets, each containing a list of key-value pairs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"External Locking Required"}),": No internal mutexes - users must provide synchronization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bucket Partitioning"}),": Hash space is partitioned across multiple buckets for better cache locality"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Standard API"}),": Compatible with ",(0,r.jsx)(n.code,{children:"std::unordered_map"})," interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"NOT Shared-Memory Compatible"}),": For runtime-only data structures, not task parameters"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"basic-usage-3",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <chimaera/unordered_map_ll.h>\n\nclass Runtime : public chi::Container {\nprivate:\n  // Runtime data structure with external locking\n  chi::unordered_map_ll<chi::u32, ModuleData> data_map_;\n\n  // External synchronization using CoRwLock\n  static chi::CoRwLock data_lock_;\n\npublic:\n  Runtime() : data_map_(32) {}  // 32 buckets for hash partitioning\n\n  void ReadData(hipc::FullPtr<ReadTask> task, chi::RunContext& ctx) {\n    chi::ScopedCoRwReadLock lock(data_lock_);\n\n    // Safe to access data_map_ with external lock held\n    auto* value = data_map_.find(task->key_);\n    if (value) {\n      task->result_ = *value;\n    }\n  }\n\n  void WriteData(hipc::FullPtr<WriteTask> task, chi::RunContext& ctx) {\n    chi::ScopedCoRwWriteLock lock(data_lock_);\n\n    // Safe to modify data_map_ with exclusive lock\n    data_map_.insert_or_assign(task->key_, task->data_);\n  }\n};\n\n// Static member definition\nchi::CoRwLock Runtime::data_lock_;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"constructor",children:"Constructor"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Create map with specified bucket count (determines max useful concurrency)\nchi::unordered_map_ll<Key, T> map(max_concurrency);\n\n// Example: 32 buckets provides good distribution for most workloads\nchi::unordered_map_ll<int, std::string> map(32);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"max_concurrency"}),": Number of buckets (default: 16)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Higher values = better distribution, more memory overhead"}),"\n",(0,r.jsx)(n.li,{children:"Typical values: 16-64 for most use cases"}),"\n",(0,r.jsx)(n.li,{children:"Should be power of 2 for optimal hash distribution"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"api-reference-3",children:"API Reference"}),"\n",(0,r.jsxs)(n.p,{children:["The container provides a ",(0,r.jsx)(n.code,{children:"std::unordered_map"}),"-compatible interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Insertion operations\nauto [inserted, value_ptr] = map.insert(key, value);          // Insert if not exists\nauto [inserted, value_ptr] = map.insert_or_assign(key, value); // Insert or update\nT& ref = map[key];                                            // Insert default if missing\n\n// Lookup operations\nT* ptr = map.find(key);                    // Returns nullptr if not found\nconst T* ptr = map.find(key) const;        // Const version\nT& ref = map.at(key);                      // Throws if not found\nbool exists = map.contains(key);           // Check existence\nsize_t count = map.count(key);             // Returns 0 or 1\n\n// Removal operations\nsize_t erased = map.erase(key);            // Returns number of elements erased\nvoid map.clear();                          // Remove all elements\n\n// Size operations\nsize_t size = map.size();                  // Total element count\nbool empty = map.empty();                  // Check if empty\nsize_t buckets = map.bucket_count();       // Number of buckets\n\n// Iteration\nmap.for_each([](const Key& key, T& value) {\n  // Process each element\n  // Note: External lock must be held during iteration\n});\n"})}),"\n",(0,r.jsx)(n.h4,{id:"return-value-semantics",children:"Return Value Semantics"}),"\n",(0,r.jsxs)(n.p,{children:["Insert operations return ",(0,r.jsx)(n.code,{children:"std::pair<bool, T*>"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"first"}),": ",(0,r.jsx)(n.code,{children:"true"})," if insertion occurred, ",(0,r.jsx)(n.code,{children:"false"})," if key already exists"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"second"}),": Pointer to the value (existing or newly inserted)"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'auto [inserted, value_ptr] = map.insert(42, "hello");\nif (inserted) {\n  // New element was inserted\n  std::cout << "Inserted: " << *value_ptr << std::endl;\n} else {\n  // Key already existed\n  std::cout << "Existing: " << *value_ptr << std::endl;\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"external-locking-patterns",children:"External Locking Patterns"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern 1: CoRwLock for Read-Heavy Workloads"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Runtime : public chi::Container {\nprivate:\n  chi::unordered_map_ll<chi::u64, CachedData> cache_;\n  static chi::CoRwLock cache_lock_;\n\npublic:\n  void LookupCache(hipc::FullPtr<LookupTask> task, chi::RunContext& ctx) {\n    chi::ScopedCoRwReadLock lock(cache_lock_);  // Multiple readers allowed\n\n    auto* data = cache_.find(task->cache_key_);\n    if (data) {\n      task->result_ = *data;\n      task->found_ = true;\n    } else {\n      task->found_ = false;\n    }\n  }\n\n  void UpdateCache(hipc::FullPtr<UpdateTask> task, chi::RunContext& ctx) {\n    chi::ScopedCoRwWriteLock lock(cache_lock_);  // Exclusive writer\n\n    cache_.insert_or_assign(task->cache_key_, task->new_data_);\n  }\n};\n\nchi::CoRwLock Runtime::cache_lock_;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern 2: CoMutex for Write-Heavy Workloads"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Runtime : public chi::Container {\nprivate:\n  chi::unordered_map_ll<std::string, RequestCounter> counters_;\n  static chi::CoMutex counters_mutex_;\n\npublic:\n  void IncrementCounter(hipc::FullPtr<IncrementTask> task, chi::RunContext& ctx) {\n    chi::ScopedCoMutex lock(counters_mutex_);\n\n    auto [inserted, counter_ptr] = counters_.insert(task->counter_name_, RequestCounter{});\n    counter_ptr->count++;\n    task->new_count_ = counter_ptr->count;\n  }\n};\n\nchi::CoMutex Runtime::counters_mutex_;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pattern 3: Instance-Level Locking"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Runtime : public chi::Container {\nprivate:\n  // Per-container instance data\n  chi::unordered_map_ll<chi::u32, TaskState> active_tasks_;\n  chi::CoMutex instance_lock_;  // Instance member, not static\n\npublic:\n  void RegisterTask(hipc::FullPtr<RegisterTask> task, chi::RunContext& ctx) {\n    chi::ScopedCoMutex lock(instance_lock_);  // Lock this container instance only\n\n    active_tasks_.insert(task->task_id_, TaskState{task->start_time_});\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-chiunordered_map_ll",children:"When to Use chi::unordered_map_ll"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"\u2705 Use chi::unordered_map_ll for:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Runtime container data structures (caches, registries, counters)"}),"\n",(0,r.jsx)(n.li,{children:"Module-internal state management"}),"\n",(0,r.jsx)(n.li,{children:"Lookup tables for fast key-value access"}),"\n",(0,r.jsx)(n.li,{children:"Data structures protected by CoMutex/CoRwLock"}),"\n",(0,r.jsx)(n.li,{children:"Non-shared memory data (runtime process only)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"\u274c Do NOT use chi::unordered_map_ll for:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Task input/output parameters (use ",(0,r.jsx)(n.code,{children:"chi::ipc::"})," types instead)"]}),"\n",(0,r.jsx)(n.li,{children:"Shared-memory data structures (not compatible with HSHM allocators)"}),"\n",(0,r.jsxs)(n.li,{children:["Client-side code (use ",(0,r.jsx)(n.code,{children:"std::unordered_map"})," instead)"]}),"\n",(0,r.jsxs)(n.li,{children:["Data that needs to be serialized (use ",(0,r.jsx)(n.code,{children:"std::unordered_map"})," with cereal)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"performance-considerations-1",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Bucket Count Selection:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Small datasets (< 100 elements): 16 buckets\nchi::unordered_map_ll<Key, Value> small_map(16);\n\n// Medium datasets (100-10000 elements): 32-64 buckets\nchi::unordered_map_ll<Key, Value> medium_map(32);\n\n// Large datasets (> 10000 elements): 64-128 buckets\nchi::unordered_map_ll<Key, Value> large_map(64);\n\n// Very large datasets or high concurrency: 128+ buckets\nchi::unordered_map_ll<Key, Value> huge_map(128);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Iteration Performance:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Iteration requires external lock for entire duration\nvoid ProcessAllEntries(hipc::FullPtr<Task> task, chi::RunContext& ctx) {\n  chi::ScopedCoRwReadLock lock(data_lock_);  // Hold lock during entire iteration\n\n  size_t count = 0;\n  data_map_.for_each([&count](const Key& key, Value& value) {\n    // Process entry\n    count++;\n  });\n\n  task->processed_count_ = count;\n  // Lock released when scope exits\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"complete-example-request-tracking-module",children:"Complete Example: Request Tracking Module"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// In MOD_NAME_runtime.h\n#include <chimaera/unordered_map_ll.h>\n#include <chimaera/corwlock.h>\n\nclass Runtime : public chi::Container {\nprivate:\n  // Request tracking data structure\n  struct RequestInfo {\n    chi::u64 start_time_us_;\n    chi::u64 bytes_processed_;\n    chi::u32 status_code_;\n  };\n\n  // Map of active requests (external locking required)\n  chi::unordered_map_ll<chi::u64, RequestInfo> active_requests_;\n\n  // Completed request statistics\n  chi::unordered_map_ll<chi::u32, chi::u64> status_counts_;\n\n  // Synchronization primitives\n  static chi::CoRwLock requests_lock_;\n  static chi::CoMutex stats_mutex_;\n\npublic:\n  Runtime()\n    : active_requests_(64),   // 64 buckets for active requests\n      status_counts_(16) {}   // 16 buckets for status codes\n\n  void StartRequest(hipc::FullPtr<StartRequestTask> task, chi::RunContext& ctx) {\n    chi::ScopedCoRwWriteLock lock(requests_lock_);\n\n    RequestInfo info{\n      .start_time_us_ = task->timestamp_,\n      .bytes_processed_ = 0,\n      .status_code_ = 0\n    };\n\n    active_requests_.insert(task->request_id_, info);\n  }\n\n  void CompleteRequest(hipc::FullPtr<CompleteRequestTask> task, chi::RunContext& ctx) {\n    {\n      // Update active requests\n      chi::ScopedCoRwWriteLock lock(requests_lock_);\n\n      auto* info = active_requests_.find(task->request_id_);\n      if (info) {\n        task->duration_us_ = task->end_time_ - info->start_time_us_;\n        task->bytes_processed_ = info->bytes_processed_;\n\n        // Update statistics\n        {\n          chi::ScopedCoMutex stats_lock(stats_mutex_);\n          auto [inserted, count_ptr] = status_counts_.insert_or_assign(\n            info->status_code_, 0);\n          (*count_ptr)++;\n        }\n\n        active_requests_.erase(task->request_id_);\n      }\n    }\n  }\n\n  void GetStatistics(hipc::FullPtr<GetStatsTask> task, chi::RunContext& ctx) {\n    // Read statistics with read lock\n    chi::ScopedCoRwReadLock lock(requests_lock_);\n\n    task->active_count_ = active_requests_.size();\n\n    // Get status code distribution\n    chi::ScopedCoMutex stats_lock(stats_mutex_);\n    status_counts_.for_each([&task](const chi::u32& status, const chi::u64& count) {\n      task->status_distribution_.push_back({status, count});\n    });\n  }\n};\n\n// Static member definitions\nchi::CoRwLock Runtime::requests_lock_;\nchi::CoMutex Runtime::stats_mutex_;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"key-differences-from-stdunordered_map",children:"Key Differences from std::unordered_map"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"std::unordered_map"}),(0,r.jsx)(n.th,{children:"chi::unordered_map_ll"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Thread Safety"}),(0,r.jsx)(n.td,{children:"None (external locking required)"}),(0,r.jsx)(n.td,{children:"None (external locking required)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Internal Structure"}),(0,r.jsx)(n.td,{children:"Implementation-defined"}),(0,r.jsx)(n.td,{children:"Vector of lists (explicit)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Bucket Count"}),(0,r.jsx)(n.td,{children:"Dynamic rehashing"}),(0,r.jsx)(n.td,{children:"Fixed at construction"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Iterator Stability"}),(0,r.jsx)(n.td,{children:"Unstable across insertions"}),(0,r.jsx)(n.td,{children:"Stable (list-based)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Shared Memory"}),(0,r.jsx)(n.td,{children:"Not compatible"}),(0,r.jsx)(n.td,{children:"Not compatible"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Return Values"}),(0,r.jsx)(n.td,{children:"Iterators"}),(0,r.jsx)(n.td,{children:"Pointers to values"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Use Case"}),(0,r.jsx)(n.td,{children:"General purpose"}),(0,r.jsx)(n.td,{children:"Runtime data structures"})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"chi::unordered_map_ll"})," provides a specialized hash map implementation optimized for Chimaera runtime modules:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"External Locking"}),": Must be protected by CoMutex or CoRwLock"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fixed Buckets"}),": Bucket count set at construction (no rehashing)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pointer Interface"}),": Operations return pointers instead of iterators"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Only"}),": Not for shared-memory or task parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient Lookup"}),": O(1) average case for find/insert/erase operations"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For runtime container data structures requiring fast key-value access with external synchronization, ",(0,r.jsx)(n.code,{children:"chi::unordered_map_ll"})," provides an efficient and predictable solution."]}),"\n",(0,r.jsx)(n.h2,{id:"build-system-integration",children:"Build System Integration"}),"\n",(0,r.jsx)(n.h3,{id:"cmakeliststxt-template",children:"CMakeLists.txt Template"}),"\n",(0,r.jsx)(n.p,{children:"ChiMod CMakeLists.txt files should use the standardized ChimaeraCommon.cmake functions for consistency and proper configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.10)\n\n# Create both client and runtime libraries for your module\n# This creates targets: ${NAMESPACE}_${CHIMOD_NAME}_runtime and ${NAMESPACE}_${CHIMOD_NAME}_client\n# CMake aliases: ${NAMESPACE}::${CHIMOD_NAME}_runtime and ${NAMESPACE}::${CHIMOD_NAME}_client\nadd_chimod_client(\n  CHIMOD_NAME YOUR_MODULE_NAME\n  SOURCES src/YOUR_MODULE_NAME_client.cc\n)\nadd_chimod_runtime(\n  CHIMOD_NAME YOUR_MODULE_NAME\n  SOURCES src/YOUR_MODULE_NAME_runtime.cc src/autogen/YOUR_MODULE_NAME_lib_exec.cc\n)\n\n# Installation is automatic - no separate install_chimod() call required\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cmakeliststxt-guidelines",children:"CMakeLists.txt Guidelines"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"DO:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"add_chimod_client()"})," and ",(0,r.jsx)(n.code,{children:"add_chimod_runtime()"})," utility functions (installation is automatic)"]}),"\n",(0,r.jsxs)(n.li,{children:["Set ",(0,r.jsx)(n.code,{children:"CHIMOD_NAME"})," to your module's name"]}),"\n",(0,r.jsxs)(n.li,{children:["List source files explicitly in ",(0,r.jsx)(n.code,{children:"SOURCES"})," parameters"]}),"\n",(0,r.jsxs)(n.li,{children:["Include autogen source files in runtime ",(0,r.jsx)(n.code,{children:"SOURCES"})]}),"\n",(0,r.jsx)(n.li,{children:"Keep the CMakeLists.txt minimal and consistent"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"DON'T:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use manual ",(0,r.jsx)(n.code,{children:"add_library()"})," calls - use the utilities instead"]}),"\n",(0,r.jsxs)(n.li,{children:["Call ",(0,r.jsx)(n.code,{children:"install_chimod()"})," separately - it's handled automatically"]}),"\n",(0,r.jsxs)(n.li,{children:["Include relative paths like ",(0,r.jsx)(n.code,{children:"../include/*"})," - use proper include directories"]}),"\n",(0,r.jsx)(n.li,{children:"Set custom compile definitions - the utilities handle this"}),"\n",(0,r.jsx)(n.li,{children:"Manually configure target properties - the utilities provide standard settings"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"chimod-build-functions-reference",children:"ChiMod Build Functions Reference"}),"\n",(0,r.jsxs)(n.h4,{id:"add_chimod_client-function",children:[(0,r.jsx)(n.code,{children:"add_chimod_client()"})," Function"]}),"\n",(0,r.jsx)(n.p,{children:"Creates a ChiMod client library target with automatic dependency management."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"add_chimod_client(\n  SOURCES source_file1.cc source_file2.cc ...\n  [COMPILE_DEFINITIONS definition1 definition2 ...]\n  [LINK_LIBRARIES library1 library2 ...]\n  [LINK_DIRECTORIES directory1 directory2 ...]\n  [INCLUDE_LIBRARIES target1 target2 ...]\n  [INCLUDE_DIRECTORIES directory1 directory2 ...]\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"SOURCES"})})," (required): List of source files for the client library"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"COMPILE_DEFINITIONS"})})," (optional): Additional preprocessor definitions beyond automatic ones"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"LINK_LIBRARIES"})})," (optional): Additional libraries to link beyond automatic dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"LINK_DIRECTORIES"})})," (optional): Additional library search directories"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"INCLUDE_LIBRARIES"})})," (optional): Target libraries whose include directories should be inherited"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"INCLUDE_DIRECTORIES"})})," (optional): Additional include directories beyond automatic ones"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Automatic Behavior:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Creates target: ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_client"})]}),"\n",(0,r.jsxs)(n.li,{children:["Creates alias: ",(0,r.jsx)(n.code,{children:"${NAMESPACE}::${CHIMOD_NAME}_client"})]}),"\n",(0,r.jsxs)(n.li,{children:["Automatically links core Chimaera library (",(0,r.jsx)(n.code,{children:"chimaera::cxx"})," or ",(0,r.jsx)(n.code,{children:"hermes_shm::cxx"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["For non-admin ChiMods: automatically links ",(0,r.jsx)(n.code,{children:"chimaera_admin_client"})]}),"\n",(0,r.jsxs)(n.li,{children:["Automatically includes module headers from ",(0,r.jsx)(n.code,{children:"include/"})," directory"]}),"\n",(0,r.jsx)(n.li,{children:"Installs library and headers with proper CMake export configuration"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"add_chimod_client(\n  SOURCES src/my_module_client.cc\n  COMPILE_DEFINITIONS MY_MODULE_DEBUG=1\n  LINK_LIBRARIES additional_lib\n  INCLUDE_DIRECTORIES ${EXTERNAL_INCLUDE_DIR}\n)\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"add_chimod_runtime-function",children:[(0,r.jsx)(n.code,{children:"add_chimod_runtime()"})," Function"]}),"\n",(0,r.jsx)(n.p,{children:"Creates a ChiMod runtime library target with automatic dependency management."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"add_chimod_runtime(\n  SOURCES source_file1.cc source_file2.cc ...\n  [COMPILE_DEFINITIONS definition1 definition2 ...]\n  [LINK_LIBRARIES library1 library2 ...]\n  [LINK_DIRECTORIES directory1 directory2 ...]\n  [INCLUDE_LIBRARIES target1 target2 ...]\n  [INCLUDE_DIRECTORIES directory1 directory2 ...]\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"SOURCES"})})," (required): List of source files for the runtime library (include autogen files)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"COMPILE_DEFINITIONS"})})," (optional): Additional preprocessor definitions beyond automatic ones"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"LINK_LIBRARIES"})})," (optional): Additional libraries to link beyond automatic dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"LINK_DIRECTORIES"})})," (optional): Additional library search directories"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"INCLUDE_LIBRARIES"})})," (optional): Target libraries whose include directories should be inherited"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"INCLUDE_DIRECTORIES"})})," (optional): Additional include directories beyond automatic ones"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Automatic Behavior:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Creates target: ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_runtime"})]}),"\n",(0,r.jsxs)(n.li,{children:["Creates alias: ",(0,r.jsx)(n.code,{children:"${NAMESPACE}::${CHIMOD_NAME}_runtime"})]}),"\n",(0,r.jsxs)(n.li,{children:["Automatically defines ",(0,r.jsx)(n.code,{children:"CHIMAERA_RUNTIME=1"})," for runtime code"]}),"\n",(0,r.jsxs)(n.li,{children:["Automatically links core Chimaera library (",(0,r.jsx)(n.code,{children:"chimaera::cxx"})," or ",(0,r.jsx)(n.code,{children:"hermes_shm::cxx"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Automatically links ",(0,r.jsx)(n.code,{children:"rt"})," library for POSIX real-time support"]}),"\n",(0,r.jsxs)(n.li,{children:["For non-admin ChiMods: automatically links both ",(0,r.jsx)(n.code,{children:"chimaera_admin_runtime"})," and ",(0,r.jsx)(n.code,{children:"chimaera_admin_client"})]}),"\n",(0,r.jsxs)(n.li,{children:["Automatically includes module headers from ",(0,r.jsx)(n.code,{children:"include/"})," directory"]}),"\n",(0,r.jsx)(n.li,{children:"Links to client library if it exists"}),"\n",(0,r.jsx)(n.li,{children:"Installs library and headers with proper CMake export configuration"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"add_chimod_runtime(\n  SOURCES \n    src/my_module_runtime.cc \n    src/autogen/my_module_lib_exec.cc\n  COMPILE_DEFINITIONS MY_MODULE_RUNTIME_DEBUG=1\n  LINK_LIBRARIES libaio\n  INCLUDE_DIRECTORIES ${LIBAIO_INCLUDE_DIR}\n)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"configuration-requirements",children:"Configuration Requirements"}),"\n",(0,r.jsx)(n.p,{children:"Before using these functions, ensure your ChiMod directory contains:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"chimaera_mod.yaml"})}),": Module configuration file defining the module name"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"module_name: my_module\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Include structure"}),": Headers organized as ",(0,r.jsx)(n.code,{children:"include/[namespace]/[module_name]/"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Source files"}),": Client and runtime implementations with autogen files for runtime"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"typical-usage-pattern",children:"Typical Usage Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Most ChiMods use both functions together:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"# Create client library\nadd_chimod_client(\n  SOURCES src/my_module_client.cc\n)\n\n# Create runtime library\nadd_chimod_runtime(\n  SOURCES \n    src/my_module_runtime.cc \n    src/autogen/my_module_lib_exec.cc\n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Function Dependencies:"}),"\nBoth functions automatically handle common dependencies:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Core Library"}),": Automatically links appropriate Chimaera core library"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Libraries"}),": ",(0,r.jsx)(n.code,{children:"add_chimod_runtime()"})," automatically links ",(0,r.jsx)(n.code,{children:"rt"})," library for async I/O operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin ChiMod Integration"}),": For non-admin chimods, both functions automatically link admin libraries and include admin headers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client-Runtime Linking"}),": Runtime automatically links to client library when both exist"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This eliminates the need for manual dependency configuration in individual ChiMod CMakeLists.txt files."}),"\n",(0,r.jsx)(n.h3,{id:"target-naming-and-linking",children:"Target Naming and Linking"}),"\n",(0,r.jsx)(n.h4,{id:"target-format",children:"Target Format"}),"\n",(0,r.jsx)(n.p,{children:"The system uses underscore-based target names for consistency with CMake conventions:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Target Names:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime"}),": ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_runtime"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera_admin_runtime"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client"}),": ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_client"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera_admin_client"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"CMake Aliases (Recommended):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime"}),": ",(0,r.jsx)(n.code,{children:"${NAMESPACE}::${CHIMOD_NAME}_runtime"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera::admin_runtime"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client"}),": ",(0,r.jsx)(n.code,{children:"${NAMESPACE}::${CHIMOD_NAME}_client"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera::admin_client"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Package Names:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Format: ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera_admin"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Used with: ",(0,r.jsx)(n.code,{children:"find_package(chimaera_admin REQUIRED)"})]}),"\n",(0,r.jsxs)(n.li,{children:["Core package: ",(0,r.jsx)(n.code,{children:"chimaera"})," (automatically included by ",(0,r.jsx)(n.code,{children:"find_package(chimaera)"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"External Application Linking (Based on test/unit/external/CMakeLists.txt):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"# External applications typically only need ChiMod client libraries\n# Core library dependencies are automatically included\nfind_package(chimaera REQUIRED)\nfind_package(chimaera_admin REQUIRED)\n\ntarget_link_libraries(my_external_app\n  chimaera::admin_client            # Admin client (includes all dependencies)\n  ${CMAKE_THREAD_LIBS_INIT}         # Threading support\n)\n# Note: chimaera::cxx is automatically included by ChiMod client libraries\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Internal Development Linking:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"# For internal development within the Chimaera project\ntarget_link_libraries(internal_app\n  chimaera::admin_client            # ChiMod client\n  chimaera::bdev_client             # BDev client \n  # Core dependencies are automatically linked by ChiMod libraries\n)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"automatic-dependencies",children:"Automatic Dependencies"}),"\n",(0,r.jsx)(n.p,{children:"The ChiMod build functions automatically handle common dependencies:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"For Runtime Code:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rt library"}),": Automatically linked for POSIX real-time library support (async I/O operations)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin ChiMod"}),": Automatically linked for all non-admin ChiMods (both runtime and client)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin includes"}),": Automatically added to include directories for non-admin ChiMods"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"For All ChiMods:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Creates both client and runtime shared libraries"}),"\n",(0,r.jsxs)(n.li,{children:["Sets proper include directories (include/, ",(0,r.jsx)(n.code,{children:"${CMAKE_SOURCE_DIR}"}),"/include)"]}),"\n",(0,r.jsx)(n.li,{children:"Automatically links core Chimaera dependencies"}),"\n",(0,r.jsx)(n.li,{children:"Sets required compile definitions (CHI_CHIMOD_NAME, CHI_NAMESPACE)"}),"\n",(0,r.jsx)(n.li,{children:"Configures proper build flags and settings"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simplified Development:"}),"\nChiMod developers no longer need to manually specify:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rt"})," library dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:["Admin ChiMod dependencies (",(0,r.jsx)(n.code,{children:"chimaera_admin_runtime"}),", ",(0,r.jsx)(n.code,{children:"chimaera_admin_client"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Admin include directories"}),"\n",(0,r.jsx)(n.li,{children:"Core Chimaera library dependencies"}),"\n",(0,r.jsx)(n.li,{children:"Common linking patterns"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important Note for External Applications:"}),"\nExternal applications linking against ChiMod libraries receive all necessary dependencies automatically. The ChiMod client libraries include the core Chimaera library as a transitive dependency."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Automatic Installation:"}),"\nThe ChiMod build functions automatically handle installation:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Installs libraries to the correct destination"}),"\n",(0,r.jsx)(n.li,{children:"Sets up proper runtime paths"}),"\n",(0,r.jsx)(n.li,{children:"Configures installation properties"}),"\n",(0,r.jsx)(n.li,{children:"Includes automatic dependencies in exported CMake packages"}),"\n",(0,r.jsxs)(n.li,{children:["No separate ",(0,r.jsx)(n.code,{children:"install_chimod()"})," call required"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"targets-created-by-chimod-functions",children:"Targets Created by ChiMod Functions"}),"\n",(0,r.jsxs)(n.p,{children:["When you call ",(0,r.jsx)(n.code,{children:"add_chimod_client()"})," and ",(0,r.jsx)(n.code,{children:"add_chimod_runtime()"})," with ",(0,r.jsx)(n.code,{children:"CHIMOD_NAME YOUR_MODULE_NAME"}),", they create the following CMake targets using the underscore-based naming format:"]}),"\n",(0,r.jsx)(n.h4,{id:"target-naming-system",children:"Target Naming System"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actual Target Names"}),": ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_runtime"})," and ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_client"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CMake Aliases"}),": ",(0,r.jsx)(n.code,{children:"${NAMESPACE}::${CHIMOD_NAME}_runtime"})," and ",(0,r.jsx)(n.code,{children:"${NAMESPACE}::${CHIMOD_NAME}_client"})," (",(0,r.jsx)(n.strong,{children:"recommended"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Package Names"}),": ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}"})," (for ",(0,r.jsx)(n.code,{children:"find_package()"}),")"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"runtime-target-namespace_chimod_name_runtime",children:["Runtime Target: ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_runtime"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Target Name"}),": ",(0,r.jsx)(n.code,{children:"chimaera_YOUR_MODULE_NAME_runtime"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera_admin_runtime"}),", ",(0,r.jsx)(n.code,{children:"chimaera_MOD_NAME_runtime"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CMake Alias"}),": ",(0,r.jsx)(n.code,{children:"chimaera::YOUR_MODULE_NAME_runtime"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera::admin_runtime"}),") - ",(0,r.jsx)(n.strong,{children:"recommended for linking"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": Shared library (",(0,r.jsx)(n.code,{children:".so"})," file)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Contains server-side execution logic, runs in the Chimaera runtime process"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compile Definitions"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'CHI_CHIMOD_NAME="${CHIMOD_NAME}"'})," - Module name for runtime identification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'CHI_NAMESPACE="${NAMESPACE}"'})," - Project namespace"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Include Directories"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"include/"})," - Local module headers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"${CMAKE_SOURCE_DIR}/include"})," - Chimaera framework headers"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": Links against ",(0,r.jsx)(n.code,{children:"chimaera"})," library, rt library (automatic), admin dependencies (automatic)"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"client-target-namespace_chimod_name_client",children:["Client Target: ",(0,r.jsx)(n.code,{children:"${NAMESPACE}_${CHIMOD_NAME}_client"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Target Name"}),": ",(0,r.jsx)(n.code,{children:"chimaera_YOUR_MODULE_NAME_client"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera_admin_client"}),", ",(0,r.jsx)(n.code,{children:"chimaera_MOD_NAME_client"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CMake Alias"}),": ",(0,r.jsx)(n.code,{children:"chimaera::YOUR_MODULE_NAME_client"})," (e.g., ",(0,r.jsx)(n.code,{children:"chimaera::admin_client"}),") - ",(0,r.jsx)(n.strong,{children:"recommended for linking"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type"}),": Shared library (",(0,r.jsx)(n.code,{children:".so"})," file)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Contains client-side API, runs in user processes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compile Definitions"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'CHI_CHIMOD_NAME="${CHIMOD_NAME}"'})," - Module name for client identification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'CHI_NAMESPACE="${NAMESPACE}"'})," - Project namespace"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Include Directories"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"include/"})," - Local module headers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"${CMAKE_SOURCE_DIR}/include"})," - Chimaera framework headers"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependencies"}),": Links against ",(0,r.jsx)(n.code,{children:"chimaera"})," library, admin dependencies (automatic)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"namespace-configuration",children:"Namespace Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["The namespace is automatically read from ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"})," files. The system searches up the directory tree from the CMakeLists.txt location to find the first ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"})," file:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Main project ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"}),":"]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"namespace: chimaera  # Main project namespace\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Module repository ",(0,r.jsx)(n.code,{children:"chimods/chimaera_repo.yaml"}),":"]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"namespace: chimods   # Modules get this namespace\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This means modules in the ",(0,r.jsx)(n.code,{children:"chimods/"}),' directory will use the "chimods" namespace, creating targets like ',(0,r.jsx)(n.code,{children:"chimods_admin_runtime"}),", while other components use the main project namespace."]}),"\n",(0,r.jsx)(n.h4,{id:"example-output-files",children:"Example Output Files"}),"\n",(0,r.jsxs)(n.p,{children:['For a module named "admin" with namespace "chimods" (from ',(0,r.jsx)(n.code,{children:"chimods/chimaera_repo.yaml"}),"), the build produces:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"build/bin/libchimods_admin_runtime.so    # Runtime library  \nbuild/bin/libchimods_admin_client.so     # Client library\n"})}),"\n",(0,r.jsx)(n.h4,{id:"using-the-targets",children:"Using the Targets"}),"\n",(0,r.jsx)(n.p,{children:"You can reference these targets in your CMakeLists.txt using the full target name:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"# Add custom properties to the runtime target\nset_target_properties(chimaera_${CHIMOD_NAME}_runtime PROPERTIES\n  VERSION 1.0.0\n  SOVERSION 1\n)\n\n# Add additional dependencies if needed\ntarget_link_libraries(chimaera_${CHIMOD_NAME}_runtime PRIVATE some_external_lib)\n\n# Or use the global property to get the actual target name\nget_property(RUNTIME_TARGET GLOBAL PROPERTY ${CHIMOD_NAME}_RUNTIME_TARGET)\ntarget_link_libraries(${RUNTIME_TARGET} PRIVATE some_external_lib)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"module-configuration-chimaera_modyaml",children:"Module Configuration (chimaera_mod.yaml)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'name: MOD_NAME\nversion: 1.0.0\ndescription: "Module description"\nauthor: "Author Name"\nmethods:\n  - kCreate\n  - kCustom\ndependencies: []\n'})}),"\n",(0,r.jsx)(n.h3,{id:"auto-generated-method-files",children:"Auto-Generated Method Files"}),"\n",(0,r.jsxs)(n.p,{children:["Each module requires an auto-generated methods file at ",(0,r.jsx)(n.code,{children:"include/[namespace]/MOD_NAME/autogen/MOD_NAME_methods.h"}),". This file must:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Include chimaera.h"}),": Required for GLOBAL_CONST macro"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use namespace constants"}),": Define methods as ",(0,r.jsx)(n.code,{children:"GLOBAL_CONST chi::u32"})," values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Follow naming convention"}),": Method names should start with ",(0,r.jsx)(n.code,{children:"k"})," (e.g., ",(0,r.jsx)(n.code,{children:"kCreate"}),", ",(0,r.jsx)(n.code,{children:"kCustom"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Template:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#ifndef MOD_NAME_AUTOGEN_METHODS_H_\n#define MOD_NAME_AUTOGEN_METHODS_H_\n\n#include <chimaera/chimaera.h>\n\nnamespace chimaera::MOD_NAME {\n\nnamespace Method {\n  // Standard inherited methods (always include these)\n  GLOBAL_CONST chi::u32 kCreate = 0;\n  GLOBAL_CONST chi::u32 kDestroy = 1;\n  GLOBAL_CONST chi::u32 kNodeFailure = 2;\n  GLOBAL_CONST chi::u32 kRecover = 3;\n  GLOBAL_CONST chi::u32 kMigrate = 4;\n  GLOBAL_CONST chi::u32 kUpgrade = 5;\n  \n  // Module-specific methods (customize these)\n  GLOBAL_CONST chi::u32 kCustom = 10;\n  // Add more module-specific methods starting from 10+\n}\n\n} // namespace chimaera::MOD_NAME\n\n#endif // MOD_NAME_AUTOGEN_METHODS_H_\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Important Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GLOBAL_CONST is required"}),": Do not use ",(0,r.jsx)(n.code,{children:"const"})," or ",(0,r.jsx)(n.code,{children:"constexpr"})," - use ",(0,r.jsx)(n.code,{children:"GLOBAL_CONST"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Include chimaera.h"}),": This header defines the GLOBAL_CONST macro"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Standard methods 0-5"}),": Always include the inherited methods (kCreate through kUpgrade)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom methods 10+"}),": Start custom methods from ID 10 to avoid conflicts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No static casting needed"}),": Use method values directly (e.g., ",(0,r.jsx)(n.code,{children:"method_ = Method::kCreate;"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"runtime-entry-points",children:"Runtime Entry Points"}),"\n",(0,r.jsxs)(n.p,{children:["Use the ",(0,r.jsx)(n.code,{children:"CHI_TASK_CC"})," macro to define module entry points:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// At the end of your runtime source file (_runtime.cc)\nCHI_TASK_CC(your_namespace::YourContainerClass)\n"})}),"\n",(0,r.jsxs)(n.p,{children:['This macro automatically generates all required extern "C" functions and gets the module name from ',(0,r.jsx)(n.code,{children:"YourContainerClass::CreateParams::chimod_lib_name"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"alloc_chimod()"})," - Creates container instance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"new_chimod()"})," - Creates and initializes container"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"get_chimod_name()"})," - Returns module name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"destroy_chimod()"})," - Destroys container instance"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Requirements for CHI_TASK_CC to work:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Your runtime class must define a public typedef: ",(0,r.jsx)(n.code,{children:"using CreateParams = your_namespace::CreateParams;"})]}),"\n",(0,r.jsxs)(n.li,{children:["Your CreateParams struct must have: ",(0,r.jsx)(n.code,{children:'static constexpr const char* chimod_lib_name = "your_module_name";'})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"IMPORTANT:"})," The ",(0,r.jsx)(n.code,{children:"chimod_lib_name"})," should ",(0,r.jsx)(n.strong,{children:"NOT"})," include the ",(0,r.jsx)(n.code,{children:"_runtime"})," suffix. The module manager automatically appends ",(0,r.jsx)(n.code,{children:"_runtime"})," when loading the library. For example, use ",(0,r.jsx)(n.code,{children:'"chimaera_mymodule"'})," not ",(0,r.jsx)(n.code,{children:'"chimaera_mymodule_runtime"'}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'namespace chimaera::your_module {\n\nstruct CreateParams {\n  static constexpr const char* chimod_lib_name = "chimaera_your_module";\n  // ... other parameters\n};\n\nclass Runtime : public chi::Container {\npublic:\n  using CreateParams = chimaera::your_module::CreateParams;  // Required for CHI_TASK_CC\n  // ... rest of class\n};\n\n}  // namespace chimaera::your_module\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"is_chimaera_chimod_"})," - Module identification flag"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"auto-generated-code-pattern",children:"Auto-Generated Code Pattern"}),"\n",(0,r.jsx)(n.h3,{id:"overview-4",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"ChiMods use auto-generated source files to implement the Container virtual APIs (Run, Monitor, Del, SaveIn, LoadIn, SaveOut, LoadOut, NewCopy). This approach provides consistent dispatch logic and reduces boilerplate code."}),"\n",(0,r.jsx)(n.h3,{id:"new-pattern-auto-generated-source-files",children:"New Pattern: Auto-Generated Source Files"}),"\n",(0,r.jsxs)(n.p,{children:["Instead of using inline functions in headers, ChiMods now use auto-generated ",(0,r.jsx)(n.code,{children:".cc"})," source files that implement the virtual methods directly. This pattern:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Eliminates inline dispatchers"}),": Virtual methods are implemented directly in auto-generated source"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduces header dependencies"}),": No need to include autogen headers in runtime files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improves compilation"}),": Source files compile once, not in every including file"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintains consistency"}),": All ChiMods use the same dispatch pattern"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"file-structure",children:"File Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"src/\n\u2514\u2500\u2500 autogen/\n    \u2514\u2500\u2500 MOD_NAME_lib_exec.cc    # Auto-generated virtual method implementations\n"})}),"\n",(0,r.jsx)(n.p,{children:"The auto-generated source file contains:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Container virtual method implementations (Run, Del, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Switch-case dispatch based on method IDs"}),"\n",(0,r.jsx)(n.li,{children:"Proper task type casting and method invocation"}),"\n",(0,r.jsx)(n.li,{children:"IPC manager integration for task lifecycle management"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"auto-generated-source-template",children:"Auto-Generated Source Template"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"/**\n * Auto-generated execution implementation for MOD_NAME ChiMod\n * Implements Container virtual APIs directly using switch-case dispatch\n * \n * This file is autogenerated - do not edit manually.\n * Changes should be made to the autogen tool or the YAML configuration.\n */\n\n#include <[namespace]/MOD_NAME/MOD_NAME_runtime.h>\n#include <[namespace]/MOD_NAME/autogen/MOD_NAME_methods.h>\n#include <chimaera/chimaera.h>\n\nnamespace chimaera::MOD_NAME {\n\n//==============================================================================\n// Runtime Virtual API Implementations\n//==============================================================================\n\nvoid Runtime::Run(chi::u32 method, hipc::FullPtr<chi::Task> task_ptr, chi::RunContext& rctx) {\n  switch (method) {\n    case Method::kCreate: {\n      Create(task_ptr.Cast<CreateTask>(), rctx);\n      break;\n    }\n    case Method::kDestroy: {\n      Destroy(task_ptr.Cast<DestroyTask>(), rctx);\n      break;\n    }\n    case Method::kCustom: {\n      Custom(task_ptr.Cast<CustomTask>(), rctx);\n      break;\n    }\n    default: {\n      // Unknown method - do nothing\n      break;\n    }\n  }\n}\n\nvoid Runtime::Del(chi::u32 method, hipc::FullPtr<chi::Task> task_ptr) {\n  // Use IPC manager to deallocate task from shared memory\n  auto* ipc_manager = CHI_IPC;\n  \n  switch (method) {\n    case Method::kCreate: {\n      ipc_manager->DelTask(task_ptr.Cast<CreateTask>());\n      break;\n    }\n    case Method::kDestroy: {\n      ipc_manager->DelTask(task_ptr.Cast<DestroyTask>());\n      break;\n    }\n    case Method::kCustom: {\n      ipc_manager->DelTask(task_ptr.Cast<CustomTask>());\n      break;\n    }\n    default: {\n      // For unknown methods, still try to delete from main segment\n      ipc_manager->DelTask(task_ptr);\n      break;\n    }\n  }\n}\n\n// SaveIn, LoadIn, SaveOut, LoadOut, and NewCopy follow similar patterns...\n\n} // namespace chimaera::MOD_NAME\n"})}),"\n",(0,r.jsx)(n.h3,{id:"runtime-implementation-changes",children:"Runtime Implementation Changes"}),"\n",(0,r.jsxs)(n.p,{children:["With the new autogen pattern, runtime source files (",(0,r.jsx)(n.code,{children:"MOD_NAME_runtime.cc"}),") no longer include autogen headers or implement dispatcher methods:"]}),"\n",(0,r.jsx)(n.h4,{id:"before-old-pattern",children:"Before (Old Pattern):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// No autogen header includes needed with new pattern\n\nvoid Runtime::Run(chi::u32 method, hipc::FullPtr<chi::Task> task_ptr, chi::RunContext& rctx) {\n  // Dispatch to the appropriate method handler\n  chimaera::MOD_NAME::Run(this, method, task_ptr, rctx);\n}\n\n// Similar dispatcher implementations for Del, SaveIn, LoadIn, SaveOut, LoadOut, NewCopy...\n"})}),"\n",(0,r.jsx)(n.h4,{id:"after-new-pattern",children:"After (New Pattern):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// No autogen header includes needed\n// No dispatcher method implementations needed\n\n// Virtual method implementations are now in src/autogen/MOD_NAME_lib_exec.cc\n// Runtime source focuses only on business logic methods like Create(), Custom(), etc.\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cmake-integration",children:"CMake Integration"}),"\n",(0,r.jsxs)(n.p,{children:["The auto-generated source file must be included in the ",(0,r.jsx)(n.code,{children:"RUNTIME_SOURCES"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"add_chimod_client(\n  CHIMOD_NAME MOD_NAME\n  SOURCES src/MOD_NAME_client.cc\n)\nadd_chimod_runtime(\n  CHIMOD_NAME MOD_NAME\n  SOURCES src/MOD_NAME_runtime.cc src/autogen/MOD_NAME_lib_exec.cc\n)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"benefits-of-the-new-pattern",children:"Benefits of the New Pattern"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cleaner Runtime Code"}),": Runtime implementations focus on business logic, not dispatching"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better Compilation"}),": Source files compile once instead of being inlined in every header include"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistent Pattern"}),": All ChiMods use identical dispatch logic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Header Simplification"}),": No need to include complex autogen headers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better IDE Support"}),": Proper source files work better with IDEs than inline templates"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"migration-guide",children:"Migration Guide"}),"\n",(0,r.jsx)(n.p,{children:"To migrate from the old inline header pattern to the new source pattern:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create autogen source directory"}),": ",(0,r.jsx)(n.code,{children:"mkdir -p src/autogen/"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generate new autogen source"}),": Create ",(0,r.jsx)(n.code,{children:"src/autogen/MOD_NAME_lib_exec.cc"})," with virtual method implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove autogen header includes"}),": Delete ",(0,r.jsx)(n.code,{children:"#include <[namespace]/MOD_NAME/autogen/MOD_NAME_lib_exec.h>"})," from runtime source (replaced by .cc files)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove dispatcher methods"}),": Delete all virtual method implementations from runtime source (Run, Del, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update CMakeLists.txt"}),": Add autogen source to ",(0,r.jsx)(n.code,{children:"RUNTIME_SOURCES"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keep business logic"}),": Retain the actual task processing methods (Create, Custom, etc.)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"important-notes-1",children:"Important Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Auto-generated files"}),": These files should be generated by tools, not hand-written"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Do not edit"}),": Manual changes to autogen files will be lost when regenerated"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Template consistency"}),": All ChiMods should follow the same autogen template pattern"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build integration"}),": Autogen source files must be included in CMake build"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"external-chimod-development",children:"External ChiMod Development"}),"\n",(0,r.jsx)(n.p,{children:"When developing ChiMods in external repositories (outside the main Chimaera project), you need to link against the installed Chimaera libraries and use the CMake package discovery system."}),"\n",(0,r.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsx)(n.p,{children:"Before developing external ChiMods, ensure Chimaera is properly installed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Configure and build Chimaera\ncmake --preset debug\ncmake --build build\n\n# Install Chimaera libraries and CMake configs  \ncmake --install build --prefix /usr/local\n"})}),"\n",(0,r.jsx)(n.p,{children:"This installs:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Core Chimaera library (",(0,r.jsx)(n.code,{children:"libcxx.so"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["ChiMod libraries (",(0,r.jsx)(n.code,{children:"libchimaera_admin_runtime.so"}),", ",(0,r.jsx)(n.code,{children:"libchimaera_admin_client.so"}),", etc.)"]}),"\n",(0,r.jsx)(n.li,{children:"CMake package configuration files for external discovery"}),"\n",(0,r.jsx)(n.li,{children:"Header files for development"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"external-chimod-repository-structure",children:"External ChiMod Repository Structure"}),"\n",(0,r.jsx)(n.p,{children:"Your external ChiMod repository should follow this structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"my_external_chimod/\n\u251c\u2500\u2500 chimaera_repo.yaml          # Repository namespace configuration\n\u251c\u2500\u2500 CMakeLists.txt              # Root CMake configuration\n\u251c\u2500\u2500 modules/                    # ChiMod modules directory (name is flexible)\n\u2502   \u2514\u2500\u2500 my_module/\n\u2502       \u251c\u2500\u2500 chimaera_mod.yaml   # Module configuration\n\u2502       \u251c\u2500\u2500 CMakeLists.txt      # Module build configuration  \n\u2502       \u251c\u2500\u2500 include/\n\u2502       \u2502   \u2514\u2500\u2500 [namespace]/\n\u2502       \u2502       \u2514\u2500\u2500 my_module/\n\u2502       \u2502           \u251c\u2500\u2500 my_module_client.h\n\u2502       \u2502           \u251c\u2500\u2500 my_module_runtime.h\n\u2502       \u2502           \u251c\u2500\u2500 my_module_tasks.h\n\u2502       \u2502           \u2514\u2500\u2500 autogen/\n\u2502       \u2502               \u2514\u2500\u2500 my_module_methods.h\n\u2502       \u2514\u2500\u2500 src/\n\u2502           \u251c\u2500\u2500 my_module_client.cc\n\u2502           \u251c\u2500\u2500 my_module_runtime.cc\n\u2502           \u2514\u2500\u2500 autogen/\n\u2502               \u2514\u2500\u2500 my_module_lib_exec.cc\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": The directory name for modules (shown here as ",(0,r.jsx)(n.code,{children:"modules/"}),") is flexible. You can use ",(0,r.jsx)(n.code,{children:"chimods/"}),", ",(0,r.jsx)(n.code,{children:"components/"}),", ",(0,r.jsx)(n.code,{children:"plugins/"}),", or any other name that fits your project structure. The directory name doesn't need to match the namespace."]}),"\n",(0,r.jsx)(n.h3,{id:"repository-configuration-chimaera_repoyaml",children:"Repository Configuration (chimaera_repo.yaml)"}),"\n",(0,r.jsxs)(n.p,{children:["Create a ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"})," file in your repository root to define the namespace:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# Repository-level configuration\nnamespace: myproject      # Your custom namespace (replaces "chimaera")\n'})}),"\n",(0,r.jsx)(n.p,{children:"This namespace will be used for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["CMake target names: ",(0,r.jsx)(n.code,{children:"myproject_my_module_runtime"}),", ",(0,r.jsx)(n.code,{children:"myproject_my_module_client"})]}),"\n",(0,r.jsxs)(n.li,{children:["Library file names: ",(0,r.jsx)(n.code,{children:"libmyproject_my_module_runtime.so"}),", ",(0,r.jsx)(n.code,{children:"libmyproject_my_module_client.so"})]}),"\n",(0,r.jsxs)(n.li,{children:["C++ namespaces: ",(0,r.jsx)(n.code,{children:"myproject::my_module"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"root-cmakeliststxt",children:"Root CMakeLists.txt"}),"\n",(0,r.jsxs)(n.p,{children:["Your repository's root ",(0,r.jsx)(n.code,{children:"CMakeLists.txt"})," must find and link to the installed Chimaera packages:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.20)\nproject(my_external_chimod)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Find required Chimaera packages\n# These packages are installed by 'cmake --install build --prefix /usr/local'\nfind_package(chimaera REQUIRED)              # Core Chimaera (automatically includes ChimaeraCommon.cmake)\nfind_package(chimaera_admin REQUIRED)        # Admin ChiMod (often required)\n\n# Set CMAKE_PREFIX_PATH if Chimaera is installed in a custom location\n# set(CMAKE_PREFIX_PATH \"/path/to/[namespace]/install\" ${CMAKE_PREFIX_PATH})\n\n# ChimaeraCommon.cmake utilities are automatically included by find_package(chimaera)\n# This provides add_chimod_client(), add_chimod_runtime(), and other build functions\n\n# Add subdirectories containing your ChiMods\nadd_subdirectory(modules/my_module)  # Use your actual directory name\n"})}),"\n",(0,r.jsx)(n.h3,{id:"chimod-cmakeliststxt",children:"ChiMod CMakeLists.txt"}),"\n",(0,r.jsxs)(n.p,{children:["Each ChiMod's ",(0,r.jsx)(n.code,{children:"CMakeLists.txt"})," uses the standard Chimaera build utilities:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.20)\n\n# Create both client and runtime libraries using standard Chimaera utilities\n# These functions are provided by ChimaeraCommon.cmake (automatically included via find_package(chimaera))\n# Creates targets: my_namespace_my_module_client, my_namespace_my_module_runtime\n# Creates aliases: my_namespace::my_module_client, my_namespace::my_module_runtime\nadd_chimod_client(\n  CHIMOD_NAME my_module\n  SOURCES src/my_module_client.cc\n)\nadd_chimod_runtime(\n  CHIMOD_NAME my_module\n  SOURCES\n    src/my_module_runtime.cc \n    src/autogen/my_module_lib_exec.cc\n)\n\n# Installation is automatic - no separate install_chimod() call required\n# Package name: my_namespace_my_module (for find_package)\n\n# Optional: Add additional dependencies if your ChiMod needs external libraries\n# get_property(RUNTIME_TARGET GLOBAL PROPERTY my_module_RUNTIME_TARGET)\n# get_property(CLIENT_TARGET GLOBAL PROPERTY my_module_CLIENT_TARGET)\n# target_link_libraries(${RUNTIME_TARGET} PRIVATE some_external_lib)\n# target_link_libraries(${CLIENT_TARGET} PRIVATE some_external_lib)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"external-applications-using-your-chimod",children:"External Applications Using Your ChiMod"}),"\n",(0,r.jsx)(n.p,{children:"Once installed, external applications can find and link to your ChiMod. Based on our external unit test patterns (see test/unit/external-chimod/CMakeLists.txt):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"# External application CMakeLists.txt\nfind_package(my_namespace_my_module REQUIRED)  # Your ChiMod package\nfind_package(chimaera REQUIRED)                # Core Chimaera (automatically includes utilities)\nfind_package(chimaera_admin REQUIRED)          # Admin ChiMod (often required)\n\n# Simple linking pattern - ChiMod libraries include all dependencies\ntarget_link_libraries(my_external_app\n  my_namespace::my_module_client    # Your ChiMod client\n  chimaera::admin_client            # Admin client (if needed)\n  ${CMAKE_THREAD_LIBS_INIT}         # Threading support\n)\n# Core Chimaera library is automatically included by ChiMod dependencies\n"})}),"\n",(0,r.jsx)(n.h3,{id:"external-chimod-implementation",children:"External ChiMod Implementation"}),"\n",(0,r.jsx)(n.p,{children:"Your external ChiMod implementation follows the same patterns as internal ChiMods:"}),"\n",(0,r.jsx)(n.h4,{id:"createparams-configuration",children:"CreateParams Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["In your ",(0,r.jsx)(n.code,{children:"my_module_tasks.h"}),", the ",(0,r.jsx)(n.code,{children:"CreateParams"})," must reference your custom namespace:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'struct CreateParams {\n  // Your module-specific parameters\n  std::string config_data_;\n  chi::u32 worker_count_;\n  \n  // CRITICAL: Library name must match your namespace\n  static constexpr const char* chimod_lib_name = "myproject_my_module";\n  \n  // Constructors and serialization...\n};\n'})}),"\n",(0,r.jsx)(n.h4,{id:"c-namespace",children:"C++ Namespace"}),"\n",(0,r.jsx)(n.p,{children:"Use your custom namespace throughout your implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// In all header and source files\nnamespace myproject::my_module {\n\n// Your ChiMod implementation...\nclass Runtime : public chi::Container {\n  // Implementation...\n};\n\nclass Client : public chi::ContainerClient {  \n  // Implementation...\n};\n\n} // namespace myproject::my_module\n"})}),"\n",(0,r.jsx)(n.h3,{id:"building-external-chimods",children:"Building External ChiMods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Configure your external ChiMod project\nmkdir build && cd build\ncmake ..\n\n# Build your ChiMods\nmake\n\n# Optional: Install your ChiMods\nmake install\n"})}),"\n",(0,r.jsx)(n.p,{children:"The build system will automatically:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Link all necessary core Chimaera dependencies"}),"\n",(0,r.jsxs)(n.li,{children:["Link against ",(0,r.jsx)(n.code,{children:"chimaera::admin_client"})," and ",(0,r.jsx)(n.code,{children:"chimaera::admin_runtime"})," (for non-admin modules)"]}),"\n",(0,r.jsxs)(n.li,{children:["Generate libraries with your custom namespace: ",(0,r.jsx)(n.code,{children:"libmyproject_my_module_runtime.so"})]}),"\n",(0,r.jsx)(n.li,{children:"Configure proper include paths and dependencies"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usage-in-applications",children:"Usage in Applications"}),"\n",(0,r.jsx)(n.p,{children:"Applications using your external ChiMod would reference it as:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <chimaera/chimaera.h>\n#include <[namespace]/my_module/my_module_client.h>\n#include <[namespace]/admin/admin_client.h>\n\nint main() {\n  // Initialize Chimaera client\n  chi::CHIMAERA_CLIENT_INIT();\n  \n  // Create your ChiMod client\n  const chi::PoolId pool_id = chi::PoolId(7000, 0);\n  myproject::my_module::Client client(pool_id);\n  \n  // Use your ChiMod\n  auto pool_query = chi::PoolQuery::Local();\n  client.Create(HSHM_MCTX, pool_query);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"chimaera_runtime_init-for-testing-and-benchmarks",children:"CHIMAERA_RUNTIME_INIT for Testing and Benchmarks"}),"\n",(0,r.jsxs)(n.p,{children:["For simple unit tests and benchmarks, Chimaera provides ",(0,r.jsx)(n.code,{children:"CHIMAERA_RUNTIME_INIT()"})," as a convenience function that initializes both the client and runtime in a single process. This is an alternative to using ",(0,r.jsx)(n.code,{children:"CHIMAERA_CLIENT_INIT()"})," when you need both components initialized together."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Important Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Primary Use Case"}),": Unit tests and benchmarks only"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not for Production"}),": Should NOT be used in main production applications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Process"}),": Initializes both client and runtime in the same process"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplified Testing"}),": Eliminates need for separate runtime and client processes during testing"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Usage Example (Unit Tests/Benchmarks):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include <chimaera/chimaera.h>\n#include <[namespace]/my_module/my_module_client.h>\n\nTEST(MyModuleTest, BasicOperation) {\n  // Initialize both client and runtime in single process\n  chi::CHIMAERA_RUNTIME_INIT();\n\n  // Create your ChiMod client\n  const chi::PoolId pool_id = chi::PoolId(7000, 0);\n  myproject::my_module::Client client(pool_id);\n\n  // Test your ChiMod functionality\n  auto pool_query = chi::PoolQuery::Local();\n  client.Create(HSHM_MCTX, pool_query, "test_pool");\n\n  // Assertions and test logic...\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use Each:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CHIMAERA_CLIENT_INIT()"}),": Production applications connecting to existing runtime"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CHIMAERA_RUNTIME_INIT()"}),": Unit tests, benchmarks, and simple testing scenarios"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dependencies-and-installation-paths",children:"Dependencies and Installation Paths"}),"\n",(0,r.jsx)(n.p,{children:"External ChiMod development requires these components to be installed:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Core Package"}),": ",(0,r.jsx)(n.code,{children:"chimaera"})," (includes main library and ChimaeraCommon.cmake utilities)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin ChiMod"}),": ",(0,r.jsx)(n.code,{children:"chimaera::admin_client"})," and ",(0,r.jsx)(n.code,{children:"chimaera::admin_runtime"})," (required for most modules)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CMake Configs"}),": Package discovery files (automatically installed with packages)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Headers"}),": All Chimaera framework headers (installed with packages)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["All build utilities (",(0,r.jsx)(n.code,{children:"add_chimod_client()"}),", ",(0,r.jsx)(n.code,{children:"add_chimod_runtime()"}),") are automatically available via ",(0,r.jsx)(n.code,{children:"find_package(chimaera)"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If Chimaera is installed in a custom location, set ",(0,r.jsx)(n.code,{children:"CMAKE_PREFIX_PATH"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'export CMAKE_PREFIX_PATH="/path/to/[namespace]/install:$CMAKE_PREFIX_PATH"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"common-external-development-issues",children:"Common External Development Issues"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ChimaeraCommon.cmake Not Found:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Ensure Chimaera was installed with ",(0,r.jsx)(n.code,{children:"cmake --install build --prefix <path>"})]}),"\n",(0,r.jsxs)(n.li,{children:["Verify ",(0,r.jsx)(n.code,{children:"CMAKE_PREFIX_PATH"})," includes the Chimaera installation directory"]}),"\n",(0,r.jsxs)(n.li,{children:["Check that ",(0,r.jsx)(n.code,{children:"find_package(chimaera REQUIRED)"})," succeeded (ChimaeraCommon.cmake is included automatically)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Library Name Mismatch:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Ensure ",(0,r.jsx)(n.code,{children:"CreateParams::chimod_lib_name"})," exactly matches your namespace and module name"]}),"\n",(0,r.jsxs)(n.li,{children:['For namespace "myproject" and module "my_module": ',(0,r.jsx)(n.code,{children:'chimod_lib_name = "myproject_my_module"'})]}),"\n",(0,r.jsx)(n.li,{children:'The system automatically appends "_runtime" to find the runtime library'}),"\n",(0,r.jsxs)(n.li,{children:["Target names use format: ",(0,r.jsx)(n.code,{children:"myproject_my_module_runtime"})," and ",(0,r.jsx)(n.code,{children:"myproject_my_module_client"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Missing Dependencies:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The ChiMod build functions automatically link admin and rt library dependencies"}),"\n",(0,r.jsx)(n.li,{children:"Ensure all external dependencies (Boost, MPI, etc.) are available in your build environment"}),"\n",(0,r.jsx)(n.li,{children:"Use the same dependency versions that Chimaera was built with"}),"\n",(0,r.jsx)(n.li,{children:"For runtime code, rt library is automatically included for async I/O support"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"external-chimod-checklist",children:"External ChiMod Checklist"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Repository Configuration"}),": ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"})," with custom namespace"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"CMake Setup"}),": Root CMakeLists.txt finds ",(0,r.jsx)(n.code,{children:"chimaera"})," package"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"ChiMod Configuration"}),": ",(0,r.jsx)(n.code,{children:"chimaera_mod.yaml"})," with method definitions"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Library Name"}),": ",(0,r.jsx)(n.code,{children:"CreateParams::chimod_lib_name"})," matches namespace pattern"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"C++ Namespace"}),": All code uses custom namespace consistently"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Build Integration"}),": ChiMod CMakeLists.txt uses ",(0,r.jsx)(n.code,{children:"add_chimod_client()"})," and ",(0,r.jsx)(n.code,{children:"add_chimod_runtime()"})," (installation is automatic)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Dependencies"}),": All required external libraries available at build time"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Automatic Linking"}),": Rely on ChiMod build functions for rt and admin dependencies"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-module",children:"Example Module"}),"\n",(0,r.jsxs)(n.p,{children:["See the ",(0,r.jsx)(n.code,{children:"chimods/MOD_NAME"})," directory for a complete working example that demonstrates:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Task definition with proper constructors"}),"\n",(0,r.jsx)(n.li,{children:"Client API with sync/async methods"}),"\n",(0,r.jsx)(n.li,{children:"Runtime container with execution logic"}),"\n",(0,r.jsx)(n.li,{children:"Build system integration"}),"\n",(0,r.jsx)(n.li,{children:"YAML configuration"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-new-module",children:"Creating a New Module"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Copy the MOD_NAME template directory"}),"\n",(0,r.jsx)(n.li,{children:"Rename all MOD_NAME occurrences to your module name"}),"\n",(0,r.jsx)(n.li,{children:"Update the chimaera_mod.yaml configuration"}),"\n",(0,r.jsx)(n.li,{children:"Define your tasks in the _tasks.h file"}),"\n",(0,r.jsx)(n.li,{children:"Implement client API in _client.h/cc"}),"\n",(0,r.jsx)(n.li,{children:"Implement runtime logic in _runtime.h/cc"}),"\n",(0,r.jsxs)(n.li,{children:["Add ",(0,r.jsx)(n.code,{children:"CHI_TASK_CC(YourContainerClass)"})," at the end of runtime source"]}),"\n",(0,r.jsx)(n.li,{children:"Add to the build system"}),"\n",(0,r.jsx)(n.li,{children:"Test with client and runtime"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"recent-changes-and-best-practices",children:"Recent Changes and Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"container-initialization-pattern",children:"Container Initialization Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Starting with the latest version, container initialization has been simplified:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Separate Init Method"}),": The ",(0,r.jsx)(n.code,{children:"Init"})," method has been merged with ",(0,r.jsx)(n.code,{children:"Create"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create Does Everything"}),": The ",(0,r.jsx)(n.code,{children:"Create"})," method now handles both container creation and initialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Access to Task Data"}),": Since ",(0,r.jsx)(n.code,{children:"Create"})," receives the CreateTask, you have access to pool_id and pool_query from the task"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"framework-managed-task-cleanup",children:"Framework-Managed Task Cleanup"}),"\n",(0,r.jsx)(n.p,{children:"Task cleanup is handled by the framework using the IPC manager:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Custom Del Methods Required"}),": Individual ",(0,r.jsx)(n.code,{children:"DelTaskType"})," methods are no longer needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IPC Manager Handles Cleanup"}),": The framework automatically calls ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})," to deallocate tasks from shared memory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Segment Deallocation"}),": Tasks are properly removed from their respective memory segments (typically ",(0,r.jsx)(n.code,{children:"kMainSegment"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"simplified-chimod-entry-points",children:"Simplified ChiMod Entry Points"}),"\n",(0,r.jsxs)(n.p,{children:["ChiMod entry points are now hidden behind the ",(0,r.jsx)(n.code,{children:"CHI_TASK_CC"})," macro:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Macro Call"}),': Replace complex extern "C" blocks with one macro']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Container Integration"}),": Works seamlessly with ",(0,r.jsx)(n.code,{children:"chi::Container"})," base class"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cleaner Module Code"}),": Eliminates boilerplate entry point code"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Old approach (complex extern "C" block)\nextern "C" {\n  chi::ChiContainer* alloc_chimod() { /* ... */ }\n  chi::ChiContainer* new_chimod(/*...*/) { /* ... */ }\n  const char* get_chimod_name() { /* ... */ }\n  void destroy_chimod(/*...*/) { /* ... */ }\n  bool is_chimaera_chimod_ = true;\n}\n\n// New approach (simple macro)\nCHI_TASK_CC(chimaera::MOD_NAME::Runtime)\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void Create(hipc::FullPtr<CreateTask> task, chi::RunContext& ctx) {\n  // Container is already initialized via Init() before Create is called\n  // Do NOT call Init() here\n\n  // Container-specific initialization logic\n  // All tasks will be routed through the external queue lanes\n  // which are automatically mapped to workers at runtime startup\n\n  // Container is now ready for operation\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"fullptr-parameter-pattern",children:"FullPtr Parameter Pattern"}),"\n",(0,r.jsxs)(n.p,{children:["All runtime methods now use ",(0,r.jsx)(n.code,{children:"hipc::FullPtr<TaskType>"})," instead of raw pointers:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Old pattern (deprecated)\nvoid Custom(CustomTask* task, chi::RunContext& ctx) { ... }\n\n// New pattern (current)\nvoid Custom(hipc::FullPtr<CustomTask> task, chi::RunContext& ctx) { ... }\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits of FullPtr:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shared Memory Safety"}),": Provides safe access across process boundaries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Dereferencing"}),": Use ",(0,r.jsx)(n.code,{children:"task->field"})," just like raw pointers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Management"}),": Framework handles allocation/deallocation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Null Checking"}),": Use ",(0,r.jsx)(n.code,{children:"task.IsNull()"})," to check validity"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"migration-guide-1",children:"Migration Guide"}),"\n",(0,r.jsx)(n.p,{children:"When updating existing modules:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove Init Override"}),": Delete custom ",(0,r.jsx)(n.code,{children:"Init"})," method implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update Create Method"}),": Move initialization logic from ",(0,r.jsx)(n.code,{children:"Init"})," to ",(0,r.jsx)(n.code,{children:"Create"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Change Method Signatures"}),": Replace ",(0,r.jsx)(n.code,{children:"TaskType*"})," with ",(0,r.jsx)(n.code,{children:"hipc::FullPtr<TaskType>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update Monitor Methods"}),": Ensure all monitoring methods use FullPtr"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement kLocalSchedule"}),": Every Monitor method MUST implement ",(0,r.jsx)(n.code,{children:"kLocalSchedule"})," mode"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove Del Methods"}),": Delete all ",(0,r.jsx)(n.code,{children:"DelTaskType"})," methods - framework calls ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})," automatically"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update Autogen Files"}),": Ensure Del dispatcher calls ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})," instead of custom Del methods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Replace Entry Points"}),': Replace extern "C" blocks with ',(0,r.jsx)(n.code,{children:"CHI_TASK_CC(ClassName)"})," macro"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remove Completion Calls"}),": Framework handles task completion automatically"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"custom-namespace-configuration",children:"Custom Namespace Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"overview-5",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["While the default namespace is ",(0,r.jsx)(n.code,{children:"chimaera"}),", you can customize the namespace for your ChiMod modules. This is useful for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Project Branding"}),": Use your own project or company namespace"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Avoiding Conflicts"}),": Prevent naming conflicts with other ChiMod collections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module Organization"}),": Group related modules under a custom namespace"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"configuring-custom-namespace",children:"Configuring Custom Namespace"}),"\n",(0,r.jsxs)(n.p,{children:["The namespace is controlled by the ",(0,r.jsx)(n.code,{children:"chimaera_repo.yaml"})," file in your project root:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"namespace: your_custom_namespace\n"})}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"namespace: mycompany\n"})}),"\n",(0,r.jsx)(n.h3,{id:"required-changes-for-custom-namespace",children:"Required Changes for Custom Namespace"}),"\n",(0,r.jsx)(n.p,{children:"When using a custom namespace, you must update several components:"}),"\n",(0,r.jsxs)(n.h4,{id:"1-createparams-chimod_lib_name",children:["1. ",(0,r.jsx)(n.strong,{children:"CreateParams chimod_lib_name"})]}),"\n",(0,r.jsxs)(n.p,{children:["The most critical change is updating the ",(0,r.jsx)(n.code,{children:"chimod_lib_name"})," in your CreateParams:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Default chimaera namespace\nstruct CreateParams {\n  static constexpr const char* chimod_lib_name = "chimaera_your_module";\n};\n\n// Custom namespace example\nstruct CreateParams {\n  static constexpr const char* chimod_lib_name = "mycompany_your_module";\n};\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"2-module-namespace-declaration",children:["2. ",(0,r.jsx)(n.strong,{children:"Module Namespace Declaration"})]}),"\n",(0,r.jsx)(n.p,{children:"Update your module's C++ namespace:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Default\nnamespace chimaera::your_module {\n  // module code\n}\n\n// Custom\nnamespace mycompany::your_module {\n  // module code\n}\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"3-cmake-library-names",children:["3. ",(0,r.jsx)(n.strong,{children:"CMake Library Names"})]}),"\n",(0,r.jsx)(n.p,{children:"The CMake system automatically uses your custom namespace. Libraries will be named:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Default: ",(0,r.jsx)(n.code,{children:"libchimaera_module_runtime.so"}),", ",(0,r.jsx)(n.code,{children:"libchimaera_module_client.so"})]}),"\n",(0,r.jsxs)(n.li,{children:["Custom: ",(0,r.jsx)(n.code,{children:"libmycompany_module_runtime.so"}),", ",(0,r.jsx)(n.code,{children:"libmycompany_module_client.so"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"4-runtime-integration",children:["4. ",(0,r.jsx)(n.strong,{children:"Runtime Integration"})]}),"\n",(0,r.jsx)(n.p,{children:"If your runtime code references the admin module or other system modules, update the references:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Default admin module reference\nauto* admin_chimod = module_manager->GetChiMod("chimaera_admin");\n\n// Custom namespace admin module\nauto* admin_chimod = module_manager->GetChiMod("mycompany_admin");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"checklist-for-custom-namespace",children:"Checklist for Custom Namespace"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Update chimaera_repo.yaml"})," with your custom namespace"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Update CreateParams::chimod_lib_name"})," to use custom namespace prefix"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Update C++ namespace declarations"})," in all module files"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Update runtime references"})," to admin module and other system modules"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Update any hardcoded module names"})," in configuration or startup code"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Rebuild all modules"})," after namespace changes"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Update library search paths"})," if needed for deployment"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-complete-custom-namespace-module",children:"Example: Complete Custom Namespace Module"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"# chimaera_repo.yaml\nnamespace: mycompany\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// mymodule_tasks.h\nnamespace mycompany::mymodule {\n\nstruct CreateParams {\n  static constexpr const char* chimod_lib_name = "mycompany_mymodule";\n  // ... other parameters\n};\n\nusing CreateTask = chimaera::admin::BaseCreateTask<CreateParams, Method::kCreate>;\n\n}  // namespace mycompany::mymodule\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// mymodule_runtime.h\nnamespace mycompany::mymodule {\n\nclass Runtime : public chi::Container {\npublic:\n  using CreateParams = mycompany::mymodule::CreateParams;  // Required for CHI_TASK_CC\n  // ... rest of class\n};\n\n}  // namespace mycompany::mymodule\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// mymodule_runtime.cc\nCHI_TASK_CC(mycompany::mymodule::Runtime)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"important-notes-2",children:"Important Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Library Name Consistency"}),": The ",(0,r.jsx)(n.code,{children:"chimod_lib_name"})," must exactly match what the CMake system generates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin Module"}),": If you customize the namespace, you may also want to rebuild the admin module with your custom namespace"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backward Compatibility"}),": Changing namespace breaks compatibility with existing deployments using default namespace"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Documentation"}),": Update any module-specific documentation to reflect the new namespace"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,r.jsx)(n.h3,{id:"task-scheduling",children:"Task Scheduling"}),"\n",(0,r.jsx)(n.p,{children:"Tasks can be scheduled with different priorities:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"kLowLatency"}),": For time-critical operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"kHighLatency"}),": For batch processing"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"automatic-routing-architecture",children:"Automatic Routing Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The framework handles all task routing automatically:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Client-Side Enqueuing"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Tasks are enqueued via ",(0,r.jsx)(n.code,{children:"IpcManager::Enqueue()"})," from client code"]}),"\n",(0,r.jsx)(n.li,{children:"Lane selection uses PID+TID hash for automatic distribution across lanes"}),"\n",(0,r.jsxs)(n.li,{children:["Formula: ",(0,r.jsx)(n.code,{children:"lane_id = hash(PID, TID) % num_lanes"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Worker-Lane Mapping"})," (1:1 Direct Mapping):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Number of lanes automatically equals number of sched workers (default: 8)"}),"\n",(0,r.jsx)(n.li,{children:"Each worker assigned exactly one lane: worker i \u2192 lane i"}),"\n",(0,r.jsx)(n.li,{children:"No round-robin needed - perfect 1:1 correspondence"}),"\n",(0,r.jsx)(n.li,{children:"Lane headers track assigned worker ID"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"No Configuration Required"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lane count automatically matches sched worker count from config"}),"\n",(0,r.jsxs)(n.li,{children:["No separate ",(0,r.jsx)(n.code,{children:"task_queue_lanes"})," configuration needed"]}),"\n",(0,r.jsx)(n.li,{children:"Change worker count \u2192 lane count adjusts automatically"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": With 8 sched workers (default):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"8 lanes created automatically in external queue"}),"\n",(0,r.jsx)(n.li,{children:"Worker 0 \u2192 Lane 0, Worker 1 \u2192 Lane 1, ..., Worker 7 \u2192 Lane 7"}),"\n",(0,r.jsx)(n.li,{children:"Client tasks distributed via hash to lanes 0-7"}),"\n",(0,r.jsx)(n.li,{children:"Each worker processes tasks from its dedicated lane"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void Custom(hipc::FullPtr<CustomTask> task, chi::RunContext& ctx) {\n  try {\n    // Operation logic\n    task->result_code_ = 0;\n  } catch (const std::exception& e) {\n    task->result_code_ = 1;\n    task->data_ = chi::string(main_allocator_, e.what());\n  }\n  // Framework handles task completion automatically\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"debugging-tips",children:"Debugging Tips"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check Shared Memory"}),": Use ",(0,r.jsx)(n.code,{children:"ipcs -m"})," to view segments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Verify Task State"}),": Check task completion status"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor Queue Depth"}),": Use GetProcessQueue() to inspect queues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enable Debug Logging"}),": Set CHI_DEBUG environment variable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use GDB"}),": Attach to runtime process for debugging"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Tasks Not Being Executed:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Tasks not being routed to worker queues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Verify task pool_query is set correctly and pool exists"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debug"}),": Add logging in task execution methods to verify they're being called"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Queue Overflow or Deadlocks:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Tasks being enqueued but not dequeued from lanes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Verify lane creation in Create() method and proper task routing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debug"}),": Check lane sizes with ",(0,r.jsx)(n.code,{children:"lane->Size()"})," and ",(0,r.jsx)(n.code,{children:"lane->IsEmpty()"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Memory Leaks in Shared Memory:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cause"}),": Tasks not being properly cleaned up"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Solution"}),": Ensure framework Del dispatcher is working correctly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debug"}),": Monitor shared memory usage with ",(0,r.jsx)(n.code,{children:"ipcs -m"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations-2",children:"Performance Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize Allocations"}),": Reuse buffers when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch Operations"}),": Submit multiple tasks together"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Appropriate Segments"}),": Put large data in client_data_segment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Avoid Blocking"}),": Use async operations when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Profile First"}),": Measure before optimizing"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,r.jsx)(n.p,{children:"Unit testing for ChiMods can be implemented following these key principles:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Set up test environment with proper configuration"}),"\n",(0,r.jsx)(n.li,{children:"Configure environment variables for module discovery"}),"\n",(0,r.jsx)(n.li,{children:"Integrate with test framework patterns"}),"\n",(0,r.jsx)(n.li,{children:"Create test examples with fixtures"}),"\n",(0,r.jsx)(n.li,{children:"Configure CMake for test builds"}),"\n",(0,r.jsx)(n.li,{children:"Follow best practices for ChiMod testing"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Test both runtime and client components in the same process for comprehensive integration testing without complex multi-process coordination."}),"\n",(0,r.jsx)(n.h2,{id:"quick-reference-checklist",children:"Quick Reference Checklist"}),"\n",(0,r.jsx)(n.p,{children:"When creating a new Chimaera module, ensure you have:"}),"\n",(0,r.jsxs)(n.h3,{id:"task-definition-checklist-_tasksh",children:["Task Definition Checklist (",(0,r.jsx)(n.code,{children:"_tasks.h"}),")"]}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Tasks inherit from ",(0,r.jsx)(n.code,{children:"chi::Task"})," or use GetOrCreatePoolTask template (recommended for non-admin modules)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Use GetOrCreatePoolTask"}),": For non-admin modules instead of BaseCreateTask directly"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Use BaseCreateTask with IS_ADMIN=true"}),": Only for admin module"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","SHM constructor with CtxAllocator parameter (if custom task)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Emplace constructor with all required parameters (if custom task)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Uses HSHM serializable types (chi::string, chi::vector, etc.)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Method constant assigned in constructor (e.g., ",(0,r.jsx)(n.code,{children:"method_ = Method::kCreate;"}),")"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"No static casting"}),": Use Method namespace constants directly"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Include auto-generated methods file for Method constants"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"runtime-container-checklist-_runtimehcc",children:["Runtime Container Checklist (",(0,r.jsx)(n.code,{children:"_runtime.h/cc"}),")"]}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Inherits from ",(0,r.jsx)(n.code,{children:"chi::Container"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Init() method overridden"})," - calls base class Init() then initializes client for this ChiMod"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Create() method does NOT call ",(0,r.jsx)(n.code,{children:"chi::Container::Init()"})," (container is already initialized before Create is called)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All task methods use ",(0,r.jsx)(n.code,{children:"hipc::FullPtr<TaskType>"})," parameters"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"NO custom Del methods needed"})," - framework calls ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})," automatically"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Uses ",(0,r.jsx)(n.code,{children:"CHI_TASK_CC(ClassName)"})," macro for entry points"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Routing is automatic"})," - tasks are routed through external queue lanes mapped to workers (1:1 worker-to-lane mapping)"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"client-api-checklist-_clienthcc",children:["Client API Checklist (",(0,r.jsx)(n.code,{children:"_client.h/cc"}),")"]}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Inherits from ",(0,r.jsx)(n.code,{children:"chi::ContainerClient"})]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Uses ",(0,r.jsx)(n.code,{children:"CHI_IPC->NewTask<TaskType>()"})," for allocation"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Uses ",(0,r.jsx)(n.code,{children:"CHI_IPC->Enqueue()"})," for task submission"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Uses ",(0,r.jsx)(n.code,{children:"CHI_IPC->DelTask()"})," for cleanup"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Provides both sync and async methods"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"CRITICAL"}),": Create methods update ",(0,r.jsx)(n.code,{children:"pool_id_ = task->new_pool_id_"})," after task completion"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"build-system-checklist",children:"Build System Checklist"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","CMakeLists.txt creates both client and runtime libraries"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","chimaera_mod.yaml defines module metadata"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Auto-generated methods file"}),": ",(0,r.jsx)(n.code,{children:"autogen/MOD_NAME_methods.h"})," with Method namespace"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"Include chimaera.h"}),": In methods file for GLOBAL_CONST macro"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,r.jsx)(n.strong,{children:"GLOBAL_CONST constants"}),": Use namespace constants, not enum class"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Proper install targets configured"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Links against chimaera library"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsx)(n.strong,{children:"CRITICAL: Not updating pool_id_ in Create methods"})," (leads to incorrect pool ID for subsequent operations)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c Using raw pointers instead of FullPtr in runtime methods"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsxs)(n.strong,{children:["Calling ",(0,r.jsx)(n.code,{children:"chi::Container::Init()"})," in Create method"]})," (container is already initialized by framework before Create is called)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsxs)(n.strong,{children:["Not overriding ",(0,r.jsx)(n.code,{children:"Init()"})," method"]})," (required to initialize the client member)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c Using non-HSHM types in task data members"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c Implementing custom Del methods (framework calls ",(0,r.jsx)(n.code,{children:"ipc_manager->DelTask()"})," automatically)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ",'\u274c Writing complex extern "C" blocks (use ',(0,r.jsx)(n.code,{children:"CHI_TASK_CC"})," macro instead)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsx)(n.strong,{children:"Using static_cast with Method values"})," (use Method::kName directly)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c Attempting to manually manage task routing (framework handles automatically)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsx)(n.strong,{children:"Missing chimaera.h include"})," in methods file (GLOBAL_CONST won't work)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsx)(n.strong,{children:"Using enum class for methods"})," (use namespace with GLOBAL_CONST instead)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsx)(n.strong,{children:"Using BaseCreateTask directly for non-admin modules"})," (use GetOrCreatePoolTask instead)"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","\u274c ",(0,r.jsx)(n.strong,{children:"Forgetting GetOrCreatePoolTask template"})," for container creation (reduces boilerplate)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"pool-name-requirements",children:"Pool Name Requirements"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CRITICAL"}),": All ChiMod Create functions MUST require a user-provided ",(0,r.jsx)(n.code,{children:"pool_name"})," parameter. Never auto-generate pool names using ",(0,r.jsx)(n.code,{children:"pool_id_"})," during Create operations."]}),"\n",(0,r.jsx)(n.h3,{id:"why-pool-names-are-required",children:"Why Pool Names Are Required"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pool_id_ Not Available"}),": ",(0,r.jsx)(n.code,{children:"pool_id_"})," is not set until after Create completes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"User Intent"}),": Users should explicitly name their pools for better organization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Uniqueness"}),": Users can ensure uniqueness better than auto-generation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debugging"}),": Named pools are easier to identify during debugging"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pool-naming-guidelines",children:"Pool Naming Guidelines"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Descriptive Names"}),": Use names that identify purpose or content"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"File-based Devices"}),": For BDev file devices, ",(0,r.jsx)(n.code,{children:"pool_name"})," serves as the file path"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RAM-based Devices"}),": For BDev RAM devices, ",(0,r.jsx)(n.code,{children:"pool_name"})," should be unique identifier"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unique Identifiers"}),": Consider timestamp + PID combinations when needed"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"correct-pool-naming-usage",children:"Correct Pool Naming Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// BDev file-based device - pool_name is the file path\nstd::string file_path = "/path/to/device.dat";\nconst chi::PoolId bdev_pool_id(7000, 0);\nbdev_client.Create(mctx, pool_query, file_path, bdev_pool_id,\n                   chimaera::bdev::BdevType::kFile);\n\n// BDev RAM-based device - pool_name is unique identifier\nstd::string pool_name = "my_ram_device_" + std::to_string(timestamp);\nconst chi::PoolId ram_pool_id(7001, 0);\nbdev_client.Create(mctx, pool_query, pool_name, ram_pool_id,\n                   chimaera::bdev::BdevType::kRam, ram_size);\n\n// Other ChiMods - pool_name is descriptive identifier\nstd::string pool_name = "my_container_" + user_identifier;\nconst chi::PoolId mod_pool_id(7002, 0);\nmod_client.Create(mctx, pool_query, pool_name, mod_pool_id);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"incorrect-pool-naming-usage",children:"Incorrect Pool Naming Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// WRONG: Using pool_id_ before it\'s set (will be 0 or garbage)\nstd::string bad_name = "pool_" + std::to_string(pool_id_.ToU64());\n\n// WRONG: Using empty strings\nclient.Create(mctx, pool_query, "");\n\n// WRONG: Auto-generating inside Create function\n// Create functions should not auto-generate names\nvoid Create(mctx, pool_query) {\n    std::string auto_name = "pool_" + generate_id();  // Wrong approach\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"client-interface-pattern",children:"Client Interface Pattern"}),"\n",(0,r.jsx)(n.p,{children:"All ChiMod clients should follow this interface pattern:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class Client : public chi::ContainerClient {\n public:\n  // Synchronous Create with required pool_name\n  void Create(const hipc::MemContext& mctx, \n              const chi::PoolQuery& pool_query,\n              const std::string& pool_name /* user-provided name */) {\n    auto task = AsyncCreate(mctx, pool_query, pool_name);\n    task->Wait();\n    pool_id_ = task->new_pool_id_;  // Set AFTER Create completes\n    // ... cleanup\n  }\n  \n  // Asynchronous Create with required pool_name\n  hipc::FullPtr<CreateTask> AsyncCreate(\n      const hipc::MemContext& mctx,\n      const chi::PoolQuery& pool_query,\n      const std::string& pool_name /* user-provided name */) {\n    // Use pool_name directly, never generate internally\n    auto task = ipc_manager->NewTask<CreateTask>(\n        chi::CreateTaskId(),\n        chi::kAdminPoolId,  // Always use admin pool\n        pool_query,\n        CreateParams::chimod_lib_name,  // Never hardcode\n        pool_name,  // User-provided name\n        pool_id_    // Target pool ID (unset during Create)\n    );\n    return task;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"bdev-specific-requirements",children:"BDev-Specific Requirements"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Interface"}),": Use only one ",(0,r.jsx)(n.code,{children:"Create()"})," and ",(0,r.jsx)(n.code,{children:"AsyncCreate()"})," method (no multiple overloads)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"File Devices"}),": ",(0,r.jsx)(n.code,{children:"pool_name"})," parameter serves as the file path"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RAM Devices"}),": ",(0,r.jsx)(n.code,{children:"pool_name"})," parameter serves as unique identifier"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Method Signature"}),": ",(0,r.jsx)(n.code,{children:"Create(mctx, pool_query, pool_name, bdev_type, total_size=0, io_depth=32, alignment=4096)"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"compose-configuration-feature",children:"Compose Configuration Feature"}),"\n",(0,r.jsx)(n.p,{children:"The compose feature allows automatic pool creation from YAML configuration files. This enables declarative infrastructure setup where all required pools can be defined in configuration and created during runtime initialization or via utility script."}),"\n",(0,r.jsx)(n.h3,{id:"createparams-loadconfig-requirement",children:"CreateParams LoadConfig Requirement"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CRITICAL"}),": All ChiMod CreateParams structures MUST implement a ",(0,r.jsx)(n.code,{children:"LoadConfig()"})," method to support compose feature."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'/**\n * Load configuration from PoolConfig (for compose mode)\n * Required for compose feature support\n * @param pool_config Pool configuration from compose section\n */\nvoid LoadConfig(const chi::PoolConfig& pool_config) {\n  // Parse YAML config string\n  YAML::Node config = YAML::Load(pool_config.config_);\n\n  // Load module-specific parameters from YAML\n  if (config["parameter_name"]) {\n    parameter_name_ = config["parameter_name"].as<Type>();\n  }\n\n  // Parse size strings (e.g., "2GB", "512MB")\n  if (config["capacity"]) {\n    std::string capacity_str = config["capacity"].as<std::string>();\n    total_size_ = hshm::ConfigParse::ParseSize(capacity_str);\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"compose-configuration-format",children:"Compose Configuration Format"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'compose:\n- mod_name: chimaera_bdev        # ChiMod library name\n  pool_name: ram://test          # Pool name (or file path for BDev)\n  pool_query: dynamic            # Either "dynamic" or "local"\n  pool_id: 200.0                 # Pool ID in "major.minor" format\n  capacity: 2GB                  # Module-specific parameters\n  bdev_type: ram                 # Additional parameters as needed\n  io_depth: 32\n  alignment: 4096\n\n- mod_name: chimaera_another_mod\n  pool_name: my_pool\n  pool_query: local\n  pool_id: 201.0\n  custom_param: value\n'})}),"\n",(0,r.jsx)(n.h3,{id:"usage-modes",children:"Usage Modes"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"1. Automatic During Runtime Init:"}),"\nPools are automatically created when runtime initializes if compose section is present in configuration:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"export CHI_SERVER_CONF=/path/to/config_with_compose.yaml\nchimaera_start_runtime\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"2. Manual via chimaera_compose Utility:"}),"\nCreate pools using compose configuration against running runtime:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"chimaera_compose /path/to/compose_config.yaml\n"})}),"\n",(0,r.jsx)(n.h3,{id:"implementation-checklist",children:"Implementation Checklist"}),"\n",(0,r.jsx)(n.p,{children:"When adding compose support to a ChiMod:"}),"\n",(0,r.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Add ",(0,r.jsx)(n.code,{children:"LoadConfig(const chi::PoolConfig& pool_config)"})," method to CreateParams"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Parse all module-specific parameters from YAML config"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle optional parameters with defaults"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use ",(0,r.jsx)(n.code,{children:"hshm::ConfigParse::ParseSize()"})," for size strings"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Include ",(0,r.jsx)(n.code,{children:"<yaml-cpp/yaml.h>"})," and ",(0,r.jsx)(n.code,{children:"<chimaera/config_manager.h>"})," in tasks header"]}),"\n",(0,r.jsxs)(n.li,{className:"task-list-item",children:[(0,r.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test with compose configuration before release"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-admin-chimod-loadconfig",children:"Example Admin ChiMod LoadConfig"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void LoadConfig(const chi::PoolConfig& pool_config) {\n  // Admin doesn't have additional configuration fields\n  // YAML config parsing would go here for modules with config fields\n  (void)pool_config;  // Suppress unused parameter warning\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-bdev-chimod-loadconfig",children:"Example BDev ChiMod LoadConfig"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'void LoadConfig(const chi::PoolConfig& pool_config) {\n  YAML::Node config = YAML::Load(pool_config.config_);\n\n  // Load BDev type\n  if (config["bdev_type"]) {\n    std::string type_str = config["bdev_type"].as<std::string>();\n    if (type_str == "file") {\n      bdev_type_ = BdevType::kFile;\n    } else if (type_str == "ram") {\n      bdev_type_ = BdevType::kRam;\n    }\n  }\n\n  // Load capacity (parse size strings)\n  if (config["capacity"]) {\n    std::string capacity_str = config["capacity"].as<std::string>();\n    total_size_ = hshm::ConfigParse::ParseSize(capacity_str);\n  }\n\n  // Load optional parameters\n  if (config["io_depth"]) {\n    io_depth_ = config["io_depth"].as<chi::u32>();\n  }\n  if (config["alignment"]) {\n    alignment_ = config["alignment"].as<chi::u32>();\n  }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);