"use strict";(globalThis.webpackChunkiowarp_site=globalThis.webpackChunkiowarp_site||[]).push([[8376],{6093:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"sdk/context_transfer","title":"Context Transfer SDK","description":"Overview","source":"@site/docs/sdk/3.context_transfer.md","sourceDirName":"sdk","slug":"/sdk/context_transfer","permalink":"/docs/sdk/context_transfer","draft":false,"unlisted":false,"editUrl":"https://github.com/iowarp/iowarp.github.io/tree/main/docs/sdk/3.context_transfer.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chimaera Module Development Guide","permalink":"/docs/sdk/runtime_modules"},"next":{"title":"Context Assimilation SDK","permalink":"/docs/sdk/context_assimilation"}}');var i=t(4848),r=t(8453);const s={},o="Context Transfer SDK",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Installation &amp; Linking",id:"installation--linking",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Building CTE Core",id:"building-cte-core",level:3},{value:"Linking to CTE Core in CMake Projects",id:"linking-to-cte-core-in-cmake-projects",level:3},{value:"Package and Target Naming",id:"package-and-target-naming",level:4},{value:"Dependency Management",id:"dependency-management",level:4},{value:"API Reference",id:"api-reference",level:2},{value:"Core Client Class",id:"core-client-class",level:3},{value:"Class Definition",id:"class-definition",level:4},{value:"Tag Wrapper Class",id:"tag-wrapper-class",level:3},{value:"Class Definition",id:"class-definition-1",level:4},{value:"Key Features",id:"key-features",level:4},{value:"Memory Management Guidelines",id:"memory-management-guidelines",level:4},{value:"Data Structures",id:"data-structures",level:3},{value:"CreateParams",id:"createparams",level:4},{value:"ListTargets Return Type",id:"listtargets-return-type",level:4},{value:"GetOrCreateTag Return Type",id:"getorcreatetag-return-type",level:4},{value:"BlobInfo",id:"blobinfo",level:4},{value:"BlobBlock",id:"blobblock",level:4},{value:"CteTelemetry",id:"ctetelemetry",level:4},{value:"Global Access",id:"global-access",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Initialization",id:"basic-initialization",level:3},{value:"Registering Storage Targets",id:"registering-storage-targets",level:3},{value:"Working with Tags and Blobs",id:"working-with-tags-and-blobs",level:3},{value:"Using the Core Client Directly",id:"using-the-core-client-directly",level:4},{value:"Using the Tag Wrapper (Recommended for Convenience)",id:"using-the-tag-wrapper-recommended-for-convenience",level:4},{value:"Tag Wrapper Usage Examples",id:"tag-wrapper-usage-examples",level:3},{value:"Basic Tag Wrapper Operations",id:"basic-tag-wrapper-operations",level:4},{value:"Memory Management: Automatic vs Manual",id:"memory-management-automatic-vs-manual",level:4},{value:"Advanced Tag Wrapper with Scoring",id:"advanced-tag-wrapper-with-scoring",level:4},{value:"Blob Retrieval with Tag Wrapper",id:"blob-retrieval-with-tag-wrapper",level:4},{value:"Asynchronous Operations with Tag Wrapper",id:"asynchronous-operations-with-tag-wrapper",level:4},{value:"Asynchronous Operations",id:"asynchronous-operations",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Blob Reorganization",id:"blob-reorganization",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Configuration File Format",id:"configuration-file-format",level:3},{value:"Programmatic Configuration",id:"programmatic-configuration",level:3},{value:"Queue Priority Options",id:"queue-priority-options",level:3},{value:"Storage Device Types",id:"storage-device-types",level:3},{value:"Manual Tier Scoring",id:"manual-tier-scoring",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:4},{value:"Behavior",id:"behavior",level:4},{value:"Example Configuration",id:"example-configuration",level:4},{value:"Data Placement Engine Types",id:"data-placement-engine-types",level:3},{value:"Python Bindings",id:"python-bindings",level:2},{value:"Installation",id:"installation",level:3},{value:"Python API Usage",id:"python-api-usage",level:3},{value:"Python Data Types",id:"python-data-types",level:3},{value:"Python Blob Reorganization",id:"python-blob-reorganization",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Choosing Between Tag Wrapper and Direct Client API",id:"choosing-between-tag-wrapper-and-direct-client-api",level:4},{value:"Memory Management Best Practices",id:"memory-management-best-practices",level:4},{value:"Performance Optimization",id:"performance-optimization",level:4},{value:"Error Handling Patterns",id:"error-handling-patterns",level:4},{value:"Thread Safety Considerations",id:"thread-safety-considerations",level:4},{value:"Multi-Node Deployment",id:"multi-node-deployment",level:3},{value:"Custom Data Placement Algorithms",id:"custom-data-placement-algorithms",level:3},{value:"Performance Optimization",id:"performance-optimization-1",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Logging",id:"debug-logging",level:3},{value:"Metrics Collection",id:"metrics-collection",level:3},{value:"API Stability and Versioning",id:"api-stability-and-versioning",level:2},{value:"Support and Resources",id:"support-and-resources",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"context-transfer-sdk",children:"Context Transfer SDK"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The Context Transfer Engine (CTE) Core is a high-performance distributed storage middleware system built on the Chimaera framework. It provides a flexible blob storage API with advanced features including:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-target Storage Management"}),": Register and manage multiple storage backends (file, RAM, NVMe)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Blob Storage with Tags"}),": Store and retrieve data blobs with tag-based organization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Block-based Data Management"}),": Efficient block-level data placement across multiple targets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Monitoring"}),": Built-in telemetry and performance metrics collection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configurable Data Placement"}),": Multiple data placement algorithms (random, round-robin, max bandwidth)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous Operations"}),": Both synchronous and asynchronous APIs for all operations"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"CTE Core implements a ChiMod (Chimaera Module) that integrates with the Chimaera distributed runtime system, providing scalable data management across multiple nodes in a cluster."}),"\n",(0,i.jsx)(n.h2,{id:"installation--linking",children:"Installation & Linking"}),"\n",(0,i.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CMake 3.20 or higher"}),"\n",(0,i.jsx)(n.li,{children:"C++17 compatible compiler"}),"\n",(0,i.jsx)(n.li,{children:"Chimaera framework (chimaera and chimaera_admin packages)"}),"\n",(0,i.jsx)(n.li,{children:"yaml-cpp library"}),"\n",(0,i.jsx)(n.li,{children:"Python 3.7+ (for Python bindings)"}),"\n",(0,i.jsx)(n.li,{children:"nanobind (for Python bindings)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,i.jsx)(n.p,{children:"Our docker container has all dependencies installed for you."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"docker pull iowarp/iowarp-build:latest\n"})}),"\n",(0,i.jsx)(n.h3,{id:"building-cte-core",children:"Building CTE Core"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Clone the repository\ngit clone https://github.com/iowarp/content-transfer-engine.git\ncd content-transfer-engine\n\n# Create build directory\nmkdir build && cd build\n\n# Configure with CMake (using debug preset as recommended)\ncmake .. -DCMAKE_BUILD_TYPE=Debug\n\n# Build the project\nmake -j\n\n# Install (optional)\nsudo make install\n"})}),"\n",(0,i.jsx)(n.h3,{id:"linking-to-cte-core-in-cmake-projects",children:"Linking to CTE Core in CMake Projects"}),"\n",(0,i.jsxs)(n.p,{children:["Add the following to your ",(0,i.jsx)(n.code,{children:"CMakeLists.txt"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# find iowarp-core\nfind_package(iowarp-core CONFIG)\n\n# Create your executable or library\nadd_executable(my_app main.cpp)\n\n# Link against CTE Core libraries using modern target aliases\ntarget_link_libraries(my_app \n  PRIVATE \n    wrp_cte::core_client                     # CTE Core client library\n)\n"})}),"\n",(0,i.jsx)(n.h4,{id:"package-and-target-naming",children:"Package and Target Naming"}),"\n",(0,i.jsx)(n.p,{children:"CTE Core follows the Chimaera ChiMod naming conventions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Package Name"}),": ",(0,i.jsx)(n.code,{children:"wrp_cte_core"})," (for ",(0,i.jsx)(n.code,{children:"find_package(wrp_cte_core REQUIRED)"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Target Aliases"}),": ",(0,i.jsx)(n.code,{children:"wrp_cte::core_client"}),", ",(0,i.jsx)(n.code,{children:"wrp_cte::core_runtime"})," (recommended for linking)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Actual Targets"}),": ",(0,i.jsx)(n.code,{children:"wrp_cte_core_client"}),", ",(0,i.jsx)(n.code,{children:"wrp_cte_core_runtime"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Library Files"}),": ",(0,i.jsx)(n.code,{children:"libwrp_cte_core_client.so"}),", ",(0,i.jsx)(n.code,{children:"libwrp_cte_core_runtime.so"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Include Path"}),": ",(0,i.jsx)(n.code,{children:"wrp_cte/core/"})," (e.g., ",(0,i.jsx)(n.code,{children:"#include <wrp_cte/core/core_client.h>"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"dependency-management",children:"Dependency Management"}),"\n",(0,i.jsx)(n.p,{children:"The CTE Core ChiMod targets automatically include all required dependencies:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Core Chimaera Framework"}),": Automatically linked via ",(0,i.jsx)(n.code,{children:"wrp_cte::core_client"})," target"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Admin ChiMod"}),": Available via ",(0,i.jsx)(n.code,{children:"chimaera::admin_client"})," if needed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Include Paths"}),": Automatically configured by ChiMod targets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"System Dependencies"}),": Handled by the build system (threading, YAML, etc.)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"External applications only need to link against the CTE Core targets - all framework dependencies are resolved automatically."}),"\n",(0,i.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,i.jsx)(n.h3,{id:"core-client-class",children:"Core Client Class"}),"\n",(0,i.jsxs)(n.p,{children:["The main entry point for CTE Core functionality is the ",(0,i.jsx)(n.code,{children:"wrp_cte::core::Client"})," class."]}),"\n",(0,i.jsx)(n.h4,{id:"class-definition",children:"Class Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"namespace wrp_cte::core {\n\nclass Client : public chi::ContainerClient {\npublic:\n  // Constructors\n  Client();\n  explicit Client(const chi::PoolId &pool_id);\n\n  // Container lifecycle\n  void Create(const hipc::MemContext &mctx,\n              const chi::PoolQuery &pool_query,\n              const std::string &pool_name,\n              const chi::PoolId &custom_pool_id,\n              const CreateParams &params = CreateParams());\n\n  // Target management\n  chi::u32 RegisterTarget(const hipc::MemContext &mctx,\n                          const std::string &target_name,\n                          chimaera::bdev::BdevType bdev_type,\n                          chi::u64 total_size,\n                          const chi::PoolQuery &target_query = chi::PoolQuery::Local(),\n                          const chi::PoolId &bdev_id = chi::PoolId::GetNull());\n\n  chi::u32 UnregisterTarget(const hipc::MemContext &mctx,\n                            const std::string &target_name);\n\n  std::vector<std::string> ListTargets(const hipc::MemContext &mctx);\n\n  chi::u32 StatTargets(const hipc::MemContext &mctx);\n\n  // Tag management\n  TagId GetOrCreateTag(const hipc::MemContext &mctx,\n                       const std::string &tag_name,\n                       const TagId &tag_id = TagId::GetNull());\n\n  bool DelTag(const hipc::MemContext &mctx, const TagId &tag_id);\n  bool DelTag(const hipc::MemContext &mctx, const std::string &tag_name);\n\n  size_t GetTagSize(const hipc::MemContext &mctx, const TagId &tag_id);\n\n  // Blob operations\n  bool PutBlob(const hipc::MemContext &mctx, const TagId &tag_id,\n               const std::string &blob_name,\n               chi::u64 offset, chi::u64 size, hipc::Pointer blob_data,\n               float score, chi::u32 flags);\n\n  bool GetBlob(const hipc::MemContext &mctx, const TagId &tag_id,\n               const std::string &blob_name,\n               chi::u64 offset, chi::u64 size, chi::u32 flags,\n               hipc::Pointer blob_data);\n\n  bool DelBlob(const hipc::MemContext &mctx, const TagId &tag_id,\n               const std::string &blob_name);\n\n  chi::u32 ReorganizeBlob(const hipc::MemContext &mctx,\n                          const TagId &tag_id,\n                          const std::string &blob_name,\n                          float new_score);\n\n  // Blob metadata operations\n  float GetBlobScore(const hipc::MemContext &mctx, const TagId &tag_id,\n                     const std::string &blob_name);\n\n  chi::u64 GetBlobSize(const hipc::MemContext &mctx, const TagId &tag_id,\n                       const std::string &blob_name);\n\n  std::vector<std::string> GetContainedBlobs(const hipc::MemContext &mctx,\n                                             const TagId &tag_id);\n\n  // Telemetry\n  std::vector<CteTelemetry> PollTelemetryLog(const hipc::MemContext &mctx,\n                                             std::uint64_t minimum_logical_time);\n\n  // Async variants (all methods have Async versions)\n  hipc::FullPtr<CreateTask> AsyncCreate(...);\n  hipc::FullPtr<RegisterTargetTask> AsyncRegisterTarget(...);\n  hipc::FullPtr<UnregisterTargetTask> AsyncUnregisterTarget(...);\n  hipc::FullPtr<ListTargetsTask> AsyncListTargets(...);\n  hipc::FullPtr<StatTargetsTask> AsyncStatTargets(...);\n  hipc::FullPtr<GetOrCreateTagTask<CreateParams>> AsyncGetOrCreateTag(...);\n  hipc::FullPtr<DelTagTask> AsyncDelTag(...);\n  hipc::FullPtr<GetTagSizeTask> AsyncGetTagSize(...);\n  hipc::FullPtr<PutBlobTask> AsyncPutBlob(...);\n  hipc::FullPtr<GetBlobTask> AsyncGetBlob(...);\n  hipc::FullPtr<DelBlobTask> AsyncDelBlob(...);\n  hipc::FullPtr<ReorganizeBlobTask> AsyncReorganizeBlob(...);\n  hipc::FullPtr<GetBlobScoreTask> AsyncGetBlobScore(...);\n  hipc::FullPtr<GetBlobSizeTask> AsyncGetBlobSize(...);\n  hipc::FullPtr<GetContainedBlobsTask> AsyncGetContainedBlobs(...);\n  hipc::FullPtr<PollTelemetryLogTask> AsyncPollTelemetryLog(...);\n};\n\n}  // namespace wrp_cte::core\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tag-wrapper-class",children:"Tag Wrapper Class"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"wrp_cte::core::Tag"})," class provides a simplified, object-oriented interface for blob operations within a specific tag. This wrapper class eliminates the need to pass ",(0,i.jsx)(n.code,{children:"TagId"})," and memory context parameters for each operation, making the API more convenient and less error-prone."]}),"\n",(0,i.jsx)(n.h4,{id:"class-definition-1",children:"Class Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"namespace wrp_cte::core {\n\nclass Tag {\nprivate:\n  TagId tag_id_;\n  std::string tag_name_;\n\npublic:\n  // Constructors\n  explicit Tag(const std::string &tag_name);  // Creates or gets existing tag\n  explicit Tag(const TagId &tag_id);          // Uses existing TagId directly\n  \n  // Blob storage operations\n  void PutBlob(const std::string &blob_name, const char *data, size_t data_size, size_t off = 0);\n  void PutBlob(const std::string &blob_name, const hipc::Pointer &data, size_t data_size, \n               size_t off = 0, float score = 1.0f);\n  \n  // Asynchronous blob storage\n  hipc::FullPtr<PutBlobTask> AsyncPutBlob(const std::string &blob_name, const hipc::Pointer &data, \n                                          size_t data_size, size_t off = 0, float score = 1.0f);\n  \n  // Blob retrieval operations\n  void GetBlob(const std::string &blob_name, char *data, size_t data_size, size_t off = 0);      // Automatic memory management\n  void GetBlob(const std::string &blob_name, hipc::Pointer data, size_t data_size, size_t off = 0); // Manual memory management\n  \n  // Blob metadata operations\n  float GetBlobScore(const std::string &blob_name);\n  chi::u64 GetBlobSize(const std::string &blob_name);\n  std::vector<std::string> GetContainedBlobs();\n\n  // Tag accessor\n  const TagId& GetTagId() const { return tag_id_; }\n};\n\n}  // namespace wrp_cte::core\n"})}),"\n",(0,i.jsx)(n.h4,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic Tag Management"}),": Constructor with tag name automatically creates or retrieves existing tags"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simplified API"}),": No need to pass TagId or MemContext for each operation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Management"}),": Raw data variant automatically handles shared memory allocation and cleanup"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Exception Safety"}),": Operations throw exceptions on failure for clear error handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Score Support"}),": Blob scoring for intelligent data placement across storage targets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Blob Enumeration"}),": ",(0,i.jsx)(n.code,{children:"GetContainedBlobs()"})," method returns all blob names in the tag"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"memory-management-guidelines",children:"Memory Management Guidelines"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Synchronous Operations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Raw data variant (",(0,i.jsx)(n.code,{children:"const char*"}),") automatically manages shared memory lifecycle"]}),"\n",(0,i.jsxs)(n.li,{children:["Shared memory variant requires caller to manage ",(0,i.jsx)(n.code,{children:"hipc::Pointer"})," lifecycle"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Asynchronous Operations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Only shared memory variant available to avoid memory lifecycle issues"}),"\n",(0,i.jsxs)(n.li,{children:["Caller must keep ",(0,i.jsx)(n.code,{children:"hipc::FullPtr<char>"})," alive until async task completes"]}),"\n",(0,i.jsx)(n.li,{children:"See usage examples below for proper async memory management patterns"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"data-structures",children:"Data Structures"}),"\n",(0,i.jsx)(n.h4,{id:"createparams",children:"CreateParams"}),"\n",(0,i.jsx)(n.p,{children:"Configuration parameters for CTE container creation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'struct CreateParams {\n  chi::string config_file_path_;  // YAML config file path\n  chi::u32 worker_count_;         // Number of worker threads (default: 4)\n  \n  CreateParams();\n  CreateParams(const hipc::CtxAllocator<CHI_MAIN_ALLOC_T> &alloc, \n               const std::string& config_file_path = "", \n               chi::u32 worker_count = 4);\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"listtargets-return-type",children:"ListTargets Return Type"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ListTargets"})," method returns a vector of target names (strings):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"std::vector<std::string> ListTargets(const hipc::MemContext &mctx);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example usage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'auto target_names = cte_client->ListTargets(mctx);\nfor (const auto& target_name : target_names) {\n    std::cout << "Target: " << target_name << "\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"getorcreatetag-return-type",children:"GetOrCreateTag Return Type"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"GetOrCreateTag"})," method returns a ",(0,i.jsx)(n.code,{children:"TagId"})," directly:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"TagId GetOrCreateTag(const hipc::MemContext &mctx,\n                     const std::string &tag_name,\n                     const TagId &tag_id = TagId::GetNull());\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example usage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'TagId tag_id = cte_client->GetOrCreateTag(mctx, "my_dataset");\n'})}),"\n",(0,i.jsx)(n.h4,{id:"blobinfo",children:"BlobInfo"}),"\n",(0,i.jsx)(n.p,{children:"Blob metadata and block management:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct BlobInfo {\n  BlobId blob_id_;\n  std::string blob_name_;\n  std::vector<BlobBlock> blocks_;  // Ordered blocks making up the blob\n  float score_;                    // 0-1 score for reorganization\n  Timestamp last_modified_;\n  Timestamp last_read_;\n  \n  chi::u64 GetTotalSize() const;   // Total size from all blocks\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": Individual blob sizes can be queried efficiently using ",(0,i.jsx)(n.code,{children:"Client::GetBlobSize()"})," or ",(0,i.jsx)(n.code,{children:"Tag::GetBlobSize()"})," without needing to retrieve full BlobInfo."]}),"\n",(0,i.jsx)(n.h4,{id:"blobblock",children:"BlobBlock"}),"\n",(0,i.jsx)(n.p,{children:"Individual block within a blob:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct BlobBlock {\n  chimaera::bdev::Client bdev_client_;  // Target client for this block\n  chi::u64 target_offset_;             // Offset within target\n  chi::u64 size_;                      // Size of this block\n};\n"})}),"\n",(0,i.jsx)(n.h4,{id:"ctetelemetry",children:"CteTelemetry"}),"\n",(0,i.jsx)(n.p,{children:"Telemetry data for performance monitoring:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct CteTelemetry {\n  CteOp op_;                    // Operation type\n  size_t off_;                  // Offset within blob\n  size_t size_;                 // Size of operation\n  BlobId blob_id_;\n  TagId tag_id_;\n  Timestamp mod_time_;\n  Timestamp read_time_;\n  std::uint64_t logical_time_;  // For ordering entries\n};\n\nenum class CteOp : chi::u32 {\n  kPutBlob = 0,\n  kGetBlob = 1,\n  kDelBlob = 2,\n  kGetOrCreateTag = 3,\n  kDelTag = 4,\n  kGetTagSize = 5,\n  kGetBlobScore = 6,\n  kGetBlobSize = 7\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"global-access",children:"Global Access"}),"\n",(0,i.jsx)(n.p,{children:"CTE Core provides singleton access patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Initialize CTE client (must be called once)\n// NOTE: This automatically calls CHIMAERA_CLIENT_INIT internally\n// config_path: Optional path to YAML configuration file\n// pool_query: Pool query type for CTE container creation (default: Dynamic)\nbool WRP_CTE_CLIENT_INIT(const std::string &config_path = "",\n                         const chi::PoolQuery &pool_query = chi::PoolQuery::Dynamic());\n\n// Access global CTE client instance\nauto *client = WRP_CTE_CLIENT;\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Important Notes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"WRP_CTE_CLIENT_INIT"})," automatically calls ",(0,i.jsx)(n.code,{children:"CHIMAERA_CLIENT_INIT"})," internally"]}),"\n",(0,i.jsxs)(n.li,{children:["You do NOT need to call ",(0,i.jsx)(n.code,{children:"CHIMAERA_CLIENT_INIT"})," separately when using CTE Core"]}),"\n",(0,i.jsx)(n.li,{children:"Configuration is managed per-Runtime instance (no global ConfigManager singleton)"}),"\n",(0,i.jsxs)(n.li,{children:["The config file path can also be specified via the ",(0,i.jsx)(n.code,{children:"WRP_CTE_CONF"})," environment variable"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"basic-initialization",children:"Basic Initialization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <chimaera/chimaera.h>\n#include <wrp_cte/core/core_client.h>\n#include <wrp_cte/core/core_tasks.h>\n\nint main() {\n  // Initialize Chimaera runtime\n  chi::CHIMAERA_RUNTIME_INIT();\n\n  // Initialize CTE subsystem\n  // NOTE: WRP_CTE_CLIENT_INIT automatically calls CHIMAERA_CLIENT_INIT internally\n  // You do NOT need to call CHIMAERA_CLIENT_INIT separately\n  wrp_cte::core::WRP_CTE_CLIENT_INIT("/path/to/config.yaml");\n\n  // Get global CTE client instance (created during initialization)\n  auto *cte_client = WRP_CTE_CLIENT;\n\n  // The CTE client is now ready to use - no need to call Create() again\n  // The client is automatically initialized with the pool specified during WRP_CTE_CLIENT_INIT\n\n  return 0;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"registering-storage-targets",children:"Registering Storage Targets"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Get global CTE client\nauto *cte_client = WRP_CTE_CLIENT;\nhipc::MemContext mctx;\n\n// Register a file-based storage target\nstd::string target_path = "/mnt/nvme/cte_storage.dat";\nchi::u64 target_size = 100ULL * 1024 * 1024 * 1024;  // 100GB\n\nchi::u32 result = cte_client->RegisterTarget(\n    mctx,\n    target_path,\n    chimaera::bdev::BdevType::kFile,\n    target_size\n);\n\nif (result == 0) {\n    std::cout << "Target registered successfully\\n";\n}\n\n// Register a RAM-based cache target\nresult = cte_client->RegisterTarget(\n    mctx,\n    "/tmp/cte_cache",\n    chimaera::bdev::BdevType::kRam,\n    8ULL * 1024 * 1024 * 1024  // 8GB\n);\n\n// List all registered targets\nauto targets = cte_client->ListTargets(mctx);\nfor (const auto& target_name : targets) {\n    std::cout << "Target: " << target_name << "\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"working-with-tags-and-blobs",children:"Working with Tags and Blobs"}),"\n",(0,i.jsx)(n.h4,{id:"using-the-core-client-directly",children:"Using the Core Client Directly"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Get global CTE client\nauto *cte_client = WRP_CTE_CLIENT;\nhipc::MemContext mctx;\n\n// Create or get a tag for grouping related blobs\nTagId tag_id = cte_client->GetOrCreateTag(mctx, "dataset_v1");\n\n// Prepare data for storage\nstd::vector<char> data(1024 * 1024);  // 1MB of data\nstd::fill(data.begin(), data.end(), \'A\');\n\n// Allocate shared memory for the data\n// NOTE: AllocateBuffer is NOT templated - it returns hipc::FullPtr<char>\nhipc::FullPtr<char> shm_buffer = CHI_IPC->AllocateBuffer(data.size());\nmemcpy(shm_buffer.ptr_, data.data(), data.size());\n\nbool success = cte_client->PutBlob(\n    mctx,\n    tag_id,\n    "blob_001",           // Blob name\n    0,                    // Offset\n    data.size(),          // Size\n    shm_buffer.shm_,      // Shared memory pointer\n    0.8f,                 // Score (0-1, higher = hotter data)\n    0                     // Flags\n);\n\nif (success) {\n    std::cout << "Blob stored successfully\\n";\n\n    // Get blob size\n    chi::u64 blob_size = cte_client->GetBlobSize(mctx, tag_id, "blob_001");\n    std::cout << "Stored blob size: " << blob_size << " bytes\\n";\n\n    // Get blob score\n    float blob_score = cte_client->GetBlobScore(mctx, tag_id, "blob_001");\n    std::cout << "Blob score: " << blob_score << "\\n";\n}\n\n// Retrieve the blob\nauto retrieve_buffer = CHI_IPC->AllocateBuffer(data.size());\nsuccess = cte_client->GetBlob(\n    mctx,\n    tag_id,\n    "blob_001",           // Blob name for lookup\n    0,                    // Offset\n    data.size(),          // Size to read\n    0,                    // Flags\n    retrieve_buffer.shm_  // Buffer for data\n);\n\n// Get all blob names in the tag\nstd::vector<std::string> blob_names = cte_client->GetContainedBlobs(mctx, tag_id);\nstd::cout << "Tag contains " << blob_names.size() << " blobs\\n";\nfor (const auto& name : blob_names) {\n    std::cout << "  - " << name << "\\n";\n}\n\n// Get total size of all blobs in tag\nsize_t tag_size = cte_client->GetTagSize(mctx, tag_id);\nstd::cout << "Tag total size: " << tag_size << " bytes\\n";\n\n// Delete a specific blob\nsuccess = cte_client->DelBlob(mctx, tag_id, "blob_001");\n\n// Delete entire tag (removes all blobs)\nsuccess = cte_client->DelTag(mctx, tag_id);\n'})}),"\n",(0,i.jsx)(n.h4,{id:"using-the-tag-wrapper-recommended-for-convenience",children:"Using the Tag Wrapper (Recommended for Convenience)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Create tag wrapper - automatically creates or gets existing tag\nwrp_cte::core::Tag dataset_tag("dataset_v1");\n\n// Prepare data for storage\nstd::vector<char> data(1024 * 1024);  // 1MB of data\nstd::fill(data.begin(), data.end(), \'A\');\n\ntry {\n    // Store blob - automatically handles shared memory management\n    dataset_tag.PutBlob("blob_001", data.data(), data.size());\n    std::cout << "Blob stored successfully\\n";\n    \n    // Get blob size\n    chi::u64 blob_size = dataset_tag.GetBlobSize("blob_001");\n    std::cout << "Stored blob size: " << blob_size << " bytes\\n";\n    \n    // Get blob score  \n    float blob_score = dataset_tag.GetBlobScore("blob_001");\n    std::cout << "Blob score: " << blob_score << "\\n";\n    \n    // Retrieve the blob using automatic memory management (recommended)\n    std::vector<char> retrieve_data(blob_size);\n    dataset_tag.GetBlob("blob_001", retrieve_data.data(), blob_size);\n    \n    // Alternative: Retrieve using manual shared memory management\n    // auto retrieve_buffer = CHI_IPC->AllocateBuffer(blob_size);\n    // dataset_tag.GetBlob("blob_001", retrieve_buffer.shm_, blob_size);\n\n    std::cout << "Blob retrieved successfully\\n";\n\n    // Get all blobs in the tag\n    std::vector<std::string> blob_names = dataset_tag.GetContainedBlobs();\n    std::cout << "Tag contains " << blob_names.size() << " blobs\\n";\n\n} catch (const std::exception& e) {\n    std::cerr << "Error: " << e.what() << "\\n";\n}\n\n// For tag-level operations, you still need the core client:\nauto *cte_client = WRP_CTE_CLIENT;\nhipc::MemContext mctx;\n\n// Get total size of all blobs in tag\nsize_t tag_size = cte_client->GetTagSize(mctx, dataset_tag.GetTagId());\nstd::cout << "Tag total size: " << tag_size << " bytes\\n";\n\n// Delete entire tag (removes all blobs)\nbool success = cte_client->DelTag(mctx, dataset_tag.GetTagId());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"tag-wrapper-usage-examples",children:"Tag Wrapper Usage Examples"}),"\n",(0,i.jsx)(n.p,{children:"The Tag wrapper class provides a more convenient interface for blob operations within a specific tag. Here are comprehensive examples showing different usage patterns:"}),"\n",(0,i.jsx)(n.h4,{id:"basic-tag-wrapper-operations",children:"Basic Tag Wrapper Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <wrp_cte/core/core_client.h>\n#include <iostream>\n#include <vector>\n\n// Initialize CTE system (same as before)\n// ... initialization code ...\n\n// Create a tag wrapper - automatically creates or gets existing tag\nwrp_cte::core::Tag dataset_tag("dataset_v1");\n\n// Store data using the simple raw data interface\nstd::vector<char> data(1024 * 1024);  // 1MB of data\nstd::fill(data.begin(), data.end(), \'X\');\n\ntry {\n    // Simple PutBlob - automatically manages shared memory\n    dataset_tag.PutBlob("sample_blob", data.data(), data.size());\n    std::cout << "Blob stored successfully\\n";\n    \n    // Get blob size without retrieving data\n    chi::u64 blob_size = dataset_tag.GetBlobSize("sample_blob");\n    std::cout << "Blob size: " << blob_size << " bytes\\n";\n    \n    // Get blob score (data temperature)\n    float blob_score = dataset_tag.GetBlobScore("sample_blob");\n    std::cout << "Blob score: " << blob_score << "\\n";\n    \n} catch (const std::exception& e) {\n    std::cerr << "Error: " << e.what() << "\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"memory-management-automatic-vs-manual",children:"Memory Management: Automatic vs Manual"}),"\n",(0,i.jsx)(n.p,{children:"The Tag class provides two GetBlob variants to suit different memory management preferences:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'wrp_cte::core::Tag data_tag("performance_data");\n\ntry {\n    // Store some test data\n    std::string test_data = "Sample blob data for retrieval testing";\n    data_tag.PutBlob("test_blob", test_data.c_str(), test_data.size());\n    \n    chi::u64 blob_size = data_tag.GetBlobSize("test_blob");\n    std::cout << "Blob size: " << blob_size << " bytes\\n";\n    \n    // Method 1: Automatic memory management (recommended for most use cases)\n    std::vector<char> auto_buffer(blob_size);\n    data_tag.GetBlob("test_blob", auto_buffer.data(), blob_size);\n    std::cout << "Retrieved with automatic memory management\\n";\n    \n    // Method 2: Manual shared memory management (for advanced use cases)\n    auto shm_buffer = CHI_IPC->AllocateBuffer(blob_size);\n    if (!shm_buffer.IsNull()) {\n        data_tag.GetBlob("test_blob", shm_buffer.shm_, blob_size);\n        std::cout << "Retrieved with manual shared memory management\\n";\n        // shm_buffer automatically freed when it goes out of scope\n    }\n    \n    // Method 1 is preferred because:\n    // - No shared memory allocation required\n    // - Automatic cleanup via RAII\n    // - Works with standard C++ containers\n    // - Simpler error handling\n    \n} catch (const std::exception& e) {\n    std::cerr << "Memory management example error: " << e.what() << "\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"advanced-tag-wrapper-with-scoring",children:"Advanced Tag Wrapper with Scoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Create tag wrapper for time-series data\nwrp_cte::core::Tag timeseries_tag("timeseries_2024");\n\n// Store multiple data chunks with different scores (data temperatures)\nstd::vector<std::vector<char>> chunks;\nstd::vector<float> scores = {0.9f, 0.7f, 0.5f, 0.2f};  // Hot to cold data\nstd::vector<std::string> chunk_names = {"latest", "recent", "old", "archived"};\n\nfor (size_t i = 0; i < 4; ++i) {\n    chunks.emplace_back(1024 * 512);  // 512KB chunks\n    std::fill(chunks[i].begin(), chunks[i].end(), \'A\' + i);\n    \n    try {\n        // For custom scoring, use shared memory version:\n        auto shm_ptr = CHI_IPC->AllocateBuffer(chunks[i].size());\n        memcpy(shm_ptr.ptr_, chunks[i].data(), chunks[i].size());\n        timeseries_tag.PutBlob(chunk_names[i], shm_ptr.shm_, chunks[i].size(), 0, scores[i]);\n\n        std::cout << "Stored chunk \'" << chunk_names[i] << "\' with score " << scores[i] << "\\n";\n\n    } catch (const std::exception& e) {\n        std::cerr << "Failed to store chunk " << chunk_names[i] << ": " << e.what() << "\\n";\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"blob-retrieval-with-tag-wrapper",children:"Blob Retrieval with Tag Wrapper"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Create tag wrapper from existing TagId\nTagId existing_tag_id = /* ... get from somewhere ... */;\nwrp_cte::core::Tag existing_tag(existing_tag_id);\n\ntry {\n    // First, check if blob exists and get its size\n    chi::u64 blob_size = existing_tag.GetBlobSize("target_blob");\n    if (blob_size == 0) {\n        std::cout << "Blob \'target_blob\' not found or empty\\n";\n        return;\n    }\n    \n    std::cout << "Blob size: " << blob_size << " bytes\\n";\n\n    // Allocate shared memory buffer for retrieval\n    auto retrieve_buffer = CHI_IPC->AllocateBuffer(blob_size);\n    if (retrieve_buffer.IsNull()) {\n        throw std::runtime_error("Failed to allocate retrieval buffer");\n    }\n\n    // Retrieve the blob\n    existing_tag.GetBlob("target_blob", retrieve_buffer.shm_, blob_size);\n\n    // Process the retrieved data\n    ProcessBlobData(retrieve_buffer.ptr_, blob_size);\n\n    std::cout << "Successfully retrieved and processed blob\\n";\n\n} catch (const std::exception& e) {\n    std::cerr << "Blob retrieval error: " << e.what() << "\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"asynchronous-operations-with-tag-wrapper",children:"Asynchronous Operations with Tag Wrapper"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'wrp_cte::core::Tag async_tag("async_operations");\n\n// Prepare data for async operations\nstd::vector<std::vector<char>> async_data;\nstd::vector<hipc::FullPtr<void>> shm_buffers;\nstd::vector<hipc::FullPtr<PutBlobTask>> async_tasks;\n\nfor (int i = 0; i < 5; ++i) {\n    // Prepare data\n    async_data.emplace_back(1024 * 256);  // 256KB each\n    std::fill(async_data[i].begin(), async_data[i].end(), \'Z\' - i);\n    \n    // Allocate shared memory (must keep alive until async operation completes)\n    auto shm_buffer = CHI_IPC->AllocateBuffer(async_data[i].size());\n    if (shm_buffer.IsNull()) {\n        std::cerr << "Failed to allocate shared memory for async operation " << i << "\\n";\n        continue;\n    }\n\n    // Copy data to shared memory\n    memcpy(shm_buffer.ptr_, async_data[i].data(), async_data[i].size());\n\n    try {\n        // Start async operation (returns immediately)\n        auto task = async_tag.AsyncPutBlob(\n            "async_blob_" + std::to_string(i),\n            shm_buffer.shm_,\n            async_data[i].size(),\n            0,    // offset\n            0.6f  // score\n        );\n\n        // Store references to keep alive\n        shm_buffers.push_back(std::move(shm_buffer));\n        async_tasks.push_back(task);\n\n        std::cout << "Started async put for blob " << i << "\\n";\n\n    } catch (const std::exception& e) {\n        std::cerr << "Failed to start async put " << i << ": " << e.what() << "\\n";\n    }\n}\n\n// Wait for all async operations to complete\nstd::cout << "Waiting for async operations to complete...\\n";\nfor (size_t i = 0; i < async_tasks.size(); ++i) {\n    try {\n        async_tasks[i]->Wait();\n        if (async_tasks[i]->result_code_ == 0) {\n            std::cout << "Async operation " << i << " completed successfully\\n";\n        } else {\n            std::cout << "Async operation " << i << " failed with code " \n                      << async_tasks[i]->result_code_ << "\\n";\n        }\n        \n        // Clean up task\n        CHI_IPC->DelTask(async_tasks[i]);\n        \n    } catch (const std::exception& e) {\n        std::cerr << "Error waiting for async operation " << i << ": " << e.what() << "\\n";\n    }\n}\n\n// Note: shm_buffers will be automatically cleaned up when they go out of scope\n'})}),"\n",(0,i.jsx)(n.h3,{id:"asynchronous-operations",children:"Asynchronous Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Asynchronous blob operations for better performance\nauto put_task = cte_client.AsyncPutBlob(\n    mctx, tag_id, "async_blob", BlobId::GetNull(),\n    0, data.size(), data_ptr, 0.5f, 0\n);\n\n// Do other work while blob is being stored\nProcessOtherData();\n\n// Wait for completion\nput_task->Wait();\nif (put_task->result_code_ == 0) {\n    std::cout << "Async put completed successfully\\n";\n}\n\n// Clean up task\nCHI_IPC->DelTask(put_task);\n\n// Multiple async operations\nstd::vector<hipc::FullPtr<PutBlobTask>> tasks;\nfor (int i = 0; i < 10; ++i) {\n    auto task = cte_client.AsyncPutBlob(\n        mctx, tag_id, \n        "blob_" + std::to_string(i),\n        BlobId::GetNull(),\n        0, data.size(), data_ptr, 0.5f, 0\n    );\n    tasks.push_back(task);\n}\n\n// Wait for all to complete\nfor (auto& task : tasks) {\n    task->Wait();\n    CHI_IPC->DelTask(task);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Poll telemetry log for performance analysis\nstd::uint64_t last_logical_time = 0;\n\nauto telemetry = cte_client.PollTelemetryLog(mctx, last_logical_time);\n\nfor (const auto& entry : telemetry) {\n    std::cout << "Operation: ";\n    switch (entry.op_) {\n        case CteOp::kPutBlob: std::cout << "PUT"; break;\n        case CteOp::kGetBlob: std::cout << "GET"; break;\n        case CteOp::kDelBlob: std::cout << "DEL"; break;\n        case CteOp::kGetBlobScore: std::cout << "GET_SCORE"; break;\n        case CteOp::kGetBlobSize: std::cout << "GET_SIZE"; break;\n        case CteOp::kGetOrCreateTag: std::cout << "GET_TAG"; break;\n        case CteOp::kDelTag: std::cout << "DEL_TAG"; break;\n        case CteOp::kGetTagSize: std::cout << "TAG_SIZE"; break;\n        default: std::cout << "OTHER"; break;\n    }\n    std::cout << " Size: " << entry.size_ \n              << " Offset: " << entry.off_\n              << " LogicalTime: " << entry.logical_time_ << "\\n";\n}\n\n// Update target statistics\ncte_client.StatTargets(mctx);\n\n// Check updated target metrics\nauto targets = cte_client.ListTargets(mctx);\nfor (const auto& target : targets) {\n    std::cout << "Target: " << target.target_name_ << "\\n"\n              << "  Bytes read: " << target.bytes_read_ << "\\n"\n              << "  Bytes written: " << target.bytes_written_ << "\\n"\n              << "  Read ops: " << target.ops_read_ << "\\n"\n              << "  Write ops: " << target.ops_written_ << "\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"blob-reorganization",children:"Blob Reorganization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Reorganize blobs based on new access patterns\n// Higher scores (closer to 1.0) indicate hotter data\n\nTagId tag_id = tag_info.tag_id_;\n\n// Reorganize multiple blobs by calling ReorganizeBlob once per blob\nstd::vector<std::string> blob_names = {"blob_001", "blob_002", "blob_003"};\nstd::vector<float> new_scores = {0.95f, 0.7f, 0.3f};  // Hot, warm, cold\n\nfor (size_t i = 0; i < blob_names.size(); ++i) {\n    chi::u32 result = cte_client.ReorganizeBlob(mctx, tag_id, blob_names[i], new_scores[i]);\n    if (result == 0) {\n        std::cout << "Blob " << blob_names[i] << " reorganized successfully\\n";\n    }\n}\n\n// Example: Reorganize single blob\nchi::u32 result = cte_client.ReorganizeBlob(mctx, tag_id, "important_blob", 0.95f);\nif (result == 0) {\n    std::cout << "Single blob reorganized successfully\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.p,{children:"CTE Core uses YAML configuration files for runtime parameters. Configuration can be loaded from:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"A file path specified during initialization"}),"\n",(0,i.jsxs)(n.li,{children:["Environment variable ",(0,i.jsx)(n.code,{children:"WRP_CTE_CONF"})]}),"\n",(0,i.jsx)(n.li,{children:"Programmatically via the Config API"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"configuration-file-format",children:"Configuration File Format"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# Worker thread configuration\nworker_count: 4\n\n# Target management settings\ntargets:\n  max_targets: 100\n  default_target_timeout_ms: 30000\n  auto_unregister_failed: true\n\n# Performance tuning\nperformance:\n  target_stat_interval_ms: 5000      # Target statistics update interval\n  blob_cache_size_mb: 512            # Cache size for blob operations\n  max_concurrent_operations: 64      # Max concurrent I/O operations\n  score_threshold: 0.7               # Threshold for blob reorganization\n\n# Queue configuration for different operation types\nqueues:\n  target_management:\n    lane_count: 2\n    priority: "low_latency"\n  \n  tag_management:\n    lane_count: 2\n    priority: "low_latency"\n  \n  blob_operations:\n    lane_count: 4\n    priority: "high_latency"\n  \n  stats:\n    lane_count: 1\n    priority: "high_latency"\n\n# Storage device configuration\nstorage:\n  # Primary high-performance storage with manual tier score\n  - path: "/mnt/nvme/cte_primary"\n    bdev_type: "file"\n    capacity_limit: "1TB"\n    score: 0.9                # Optional: Manual tier score (0.0-1.0)\n  \n  # RAM-based cache (highest tier)\n  - path: "/tmp/cte_cache"\n    bdev_type: "ram"\n    capacity_limit: "8GB"\n    score: 1.0                # Optional: Manual tier score for fastest access\n  \n  # Secondary storage (uses automatic scoring)\n  - path: "/mnt/ssd/cte_secondary"\n    bdev_type: "file"\n    capacity_limit: "500GB"\n    # No score specified - uses automatic bandwidth-based scoring\n\n# Data Placement Engine configuration\ndpe:\n  dpe_type: "max_bw"  # Options: "random", "round_robin", "max_bw"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"programmatic-configuration",children:"Programmatic Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["Configuration in CTE Core is now managed per-Runtime instance, not through a global singleton. Configuration is loaded during initialization through the ",(0,i.jsx)(n.code,{children:"WRP_CTE_CLIENT_INIT"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <wrp_cte/core/core_client.h>\n\n// Initialize CTE with configuration file\n// Configuration is passed to the Runtime during creation\nbool success = wrp_cte::core::WRP_CTE_CLIENT_INIT("/path/to/config.yaml");\n\n// Or use environment variable WRP_CTE_CONF\n// export WRP_CTE_CONF=/path/to/config.yaml\nsuccess = wrp_cte::core::WRP_CTE_CLIENT_INIT();\n\n// Configuration is now embedded in the Runtime instance\n// and cannot be modified after initialization\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," The ConfigManager singleton has been removed. Configuration is now:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Loaded once during ",(0,i.jsx)(n.code,{children:"WRP_CTE_CLIENT_INIT"})]}),"\n",(0,i.jsxs)(n.li,{children:["Embedded in the CTE Runtime instance via ",(0,i.jsx)(n.code,{children:"CreateParams"})]}),"\n",(0,i.jsx)(n.li,{children:"Immutable after initialization"}),"\n",(0,i.jsxs)(n.li,{children:["Can be specified via file path parameter or ",(0,i.jsx)(n.code,{children:"WRP_CTE_CONF"})," environment variable"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"queue-priority-options",children:"Queue Priority Options"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"low_latency"'})," - Optimized for minimal latency (chi::kLowLatency)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"high_latency"'})," - Optimized for throughput (chi::kHighLatency)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"storage-device-types",children:"Storage Device Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"file"'})," - File-based block device"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"ram"'})," - RAM-based block device (for caching)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"dev_dax"'})," - Persistent memory device"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"posix"'})," - POSIX file system interface"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"manual-tier-scoring",children:"Manual Tier Scoring"}),"\n",(0,i.jsx)(n.p,{children:"Storage devices support optional manual tier scoring to override automatic bandwidth-based tier assignment:"}),"\n",(0,i.jsx)(n.h4,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"score"})})," ",(0,i.jsx)(n.em,{children:"(optional, float 0.0-1.0)"}),": Manual tier score for the storage device","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"1.0"}),": Highest tier (fastest access, e.g., RAM, high-end NVMe)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"0.8-0.9"}),": High-performance tier (e.g., NVMe SSDs)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"0.5-0.7"}),": Medium-performance tier (e.g., SATA SSDs)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"0.1-0.4"}),": Low-performance tier (e.g., HDDs, network storage)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Not specified"}),": Uses automatic bandwidth-based scoring"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"behavior",children:"Behavior"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Manual scores are preserved during target statistics updates"}),"\n",(0,i.jsx)(n.li,{children:"Targets with manual scores will not be overwritten by automatic scoring algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Data placement engines use these scores for intelligent tier selection"}),"\n",(0,i.jsx)(n.li,{children:"Mixed configurations (some manual, some automatic) are fully supported"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-configuration",children:"Example Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'storage:\n  # Fastest tier - manual score\n  - path: "/mnt/ram/cache"\n    bdev_type: "ram"\n    capacity_limit: "16GB"\n    score: 1.0\n  \n  # High-performance tier - manual score  \n  - path: "/mnt/nvme/primary"\n    bdev_type: "file"\n    capacity_limit: "1TB"\n    score: 0.85\n  \n  # Medium tier - automatic scoring\n  - path: "/mnt/ssd/secondary"\n    bdev_type: "file"\n    capacity_limit: "2TB"\n    # Uses automatic bandwidth measurement\n'})}),"\n",(0,i.jsx)(n.h3,{id:"data-placement-engine-types",children:"Data Placement Engine Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"random"'})," - Random placement across targets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"round_robin"'})," - Round-robin placement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"max_bw"'})," - Place on target with maximum available bandwidth"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"python-bindings",children:"Python Bindings"}),"\n",(0,i.jsx)(n.p,{children:"CTE Core provides Python bindings for easy integration with Python applications."}),"\n",(0,i.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Build Python bindings\ncd build\ncmake .. -DBUILD_PYTHON_BINDINGS=ON\nmake\n\n# Install Python module\npip install ./wrapper/python\n"})}),"\n",(0,i.jsx)(n.h3,{id:"python-api-usage",children:"Python API Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import wrp_cte_core_ext as cte\n\n# Initialize Chimaera runtime\ncte.chimaera_runtime_init()\n\n# Initialize CTE\n# NOTE: This automatically calls chimaera_client_init() internally\n# You do NOT need to call chimaera_client_init() separately\ncte.initialize_cte("/path/to/config.yaml")\n\n# Get global CTE client\nclient = cte.get_cte_client()\n\n# Create memory context\nmctx = cte.MemContext()\n\n# Poll telemetry log\nminimum_logical_time = 0\ntelemetry_entries = client.PollTelemetryLog(mctx, minimum_logical_time)\n\nfor entry in telemetry_entries:\n    print(f"Operation: {entry.op_}")\n    print(f"Size: {entry.size_}")\n    print(f"Offset: {entry.off_}")\n    print(f"Logical Time: {entry.logical_time_}")\n\n# Reorganize blobs with new scores\ntag_id = cte.TagId()\ntag_id.major_ = 0\ntag_id.minor_ = 1\n\nblob_names = ["blob_001", "blob_002", "blob_003"]\nnew_scores = [0.95, 0.85, 0.75]  # Different tier assignments\n\n# Call ReorganizeBlob once per blob\nfor blob_name, new_score in zip(blob_names, new_scores):\n    result = client.ReorganizeBlob(mctx, tag_id, blob_name, new_score)\n    if result == 0:\n        print(f"Blob {blob_name} reorganized successfully")\n    else:\n        print(f"Reorganization of {blob_name} failed with error code: {result}")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"python-data-types",children:"Python Data Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Create unique IDs\ntag_id = cte.TagId.GetNull()\nblob_id = cte.BlobId.GetNull()\n\n# Check if ID is null\nif tag_id.IsNull():\n    print("Tag ID is null")\n\n# Access ID components\nprint(f"Major: {tag_id.major_}, Minor: {tag_id.minor_}")\n\n# Operation types\nprint(cte.CteOp.kPutBlob)    # Put blob operation\nprint(cte.CteOp.kGetBlob)    # Get blob operation\nprint(cte.CteOp.kDelBlob)    # Delete blob operation\n'})}),"\n",(0,i.jsx)(n.h3,{id:"python-blob-reorganization",children:"Python Blob Reorganization"}),"\n",(0,i.jsxs)(n.p,{children:["The Python bindings support blob reorganization for dynamic data placement optimization using the ",(0,i.jsx)(n.code,{children:"ReorganizeBlob"})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import wrp_cte_core_ext as cte\n\n# Initialize CTE system (as shown in previous examples)\n# ...\n\nclient = cte.get_cte_client()\nmctx = cte.MemContext()\n\n# Get or create tag for the blobs\ntag_id = cte.TagId()\ntag_id.major_ = 0\ntag_id.minor_ = 1\n\n# Example 1: Reorganize multiple blobs to different tiers\nblob_names = ["hot_data", "warm_data", "cold_archive"]\nnew_scores = [0.95, 0.6, 0.2]  # Hot, warm, and cold tiers\n\n# Call ReorganizeBlob once per blob\nfor blob_name, new_score in zip(blob_names, new_scores):\n    result = client.ReorganizeBlob(mctx, tag_id, blob_name, new_score)\n    if result == 0:\n        print(f"Blob {blob_name} reorganized successfully")\n    else:\n        print(f"Reorganization of {blob_name} failed with error code: {result}")\n\n# Example 2: Promote frequently accessed blobs based on telemetry\ntelemetry = client.PollTelemetryLog(mctx, 0)\naccess_counts = {}\n\n# Count accesses per blob name (requires tracking blob names from telemetry)\n# Note: You may need to maintain a blob_id to blob_name mapping\nfor entry in telemetry:\n    if entry.op_ == cte.CteOp.kGetBlob:\n        # Track access patterns\n        blob_key = (entry.blob_id_.major_, entry.blob_id_.minor_)\n        access_counts[blob_key] = access_counts.get(blob_key, 0) + 1\n\n# Batch reorganize based on access frequency\n# Assuming you have a mapping of blob IDs to names\nblob_id_to_name = {\n    (0, 1): "dataset_001",\n    (0, 2): "dataset_002",\n    (0, 3): "dataset_003"\n}\n\nblobs_to_reorganize = []\nnew_scores_list = []\n\nfor blob_key, count in access_counts.items():\n    if blob_key in blob_id_to_name and count > 10:\n        blob_name = blob_id_to_name[blob_key]\n        blobs_to_reorganize.append(blob_name)\n\n        # Calculate score based on access frequency\n        score = min(0.5 + (count / 100.0), 1.0)\n        new_scores_list.append(score)\n\n# Perform reorganization for each blob\nif blobs_to_reorganize:\n    for blob_name, new_score in zip(blobs_to_reorganize, new_scores_list):\n        result = client.ReorganizeBlob(mctx, tag_id, blob_name, new_score)\n        if result == 0:\n            print(f"Reorganized blob {blob_name} successfully")\n\n# Example 3: Tier-based reorganization strategy\n# Organize blobs into three tiers based on size and access patterns\n\n# Small, frequently accessed -> Hot tier (0.9)\nsmall_hot_blobs = ["config", "index", "metadata"]\nfor blob_name in small_hot_blobs:\n    result = client.ReorganizeBlob(mctx, tag_id, blob_name, 0.9)\n    if result == 0:\n        print(f"Hot tier blob {blob_name} reorganized")\n\n# Medium, occasionally accessed -> Warm tier (0.5-0.7)\nwarm_blobs = ["dataset_recent_01", "dataset_recent_02"]\nwarm_scores = [0.6, 0.5]\nfor blob_name, score in zip(warm_blobs, warm_scores):\n    result = client.ReorganizeBlob(mctx, tag_id, blob_name, score)\n    if result == 0:\n        print(f"Warm tier blob {blob_name} reorganized")\n\n# Large, rarely accessed -> Cold tier (0.1-0.3)\ncold_blobs = ["archive_2023", "backup_full"]\ncold_scores = [0.2, 0.1]\nfor blob_name, score in zip(cold_blobs, cold_scores):\n    result = client.ReorganizeBlob(mctx, tag_id, blob_name, score)\n    if result == 0:\n        print(f"Cold tier blob {blob_name} reorganized")\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Score Guidelines for Python:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0.9 - 1.0"}),": Highest tier (RAM cache, frequently accessed)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0.7 - 0.8"}),": High tier (NVMe, recently accessed)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0.4 - 0.6"}),": Medium tier (SSD, occasionally accessed)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0.1 - 0.3"}),": Low tier (HDD, archival data)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0.0"}),": Lowest tier (cold storage, rarely accessed)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Method Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"result = client.ReorganizeBlob(\n    mctx,           # Memory context\n    tag_id,         # Tag ID containing the blob\n    blob_name,      # Blob name (string)\n    new_score       # New score (float, 0.0 to 1.0)\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Return Codes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0"}),": Success - blob reorganized successfully"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Non-zero"}),": Error - reorganization failed (tag not found, blob not found, insufficient space, etc.)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Important Notes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Call ",(0,i.jsx)(n.code,{children:"ReorganizeBlob"})," once per blob to reorganize multiple blobs"]}),"\n",(0,i.jsxs)(n.li,{children:["All blobs must belong to the specified ",(0,i.jsx)(n.code,{children:"tag_id"})]}),"\n",(0,i.jsxs)(n.li,{children:["Scores must be in the range ",(0,i.jsx)(n.code,{children:"[0.0, 1.0]"})]}),"\n",(0,i.jsx)(n.li,{children:"Higher scores indicate hotter data that should be placed on faster storage tiers"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,i.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h4,{id:"choosing-between-tag-wrapper-and-direct-client-api",children:"Choosing Between Tag Wrapper and Direct Client API"}),"\n",(0,i.jsx)(n.p,{children:"Generally, the tag wrapper class is preferred over the direct API."}),"\n",(0,i.jsx)(n.h4,{id:"memory-management-best-practices",children:"Memory Management Best Practices"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Raw Data Operations:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Tag wrapper automatically manages shared memory for sync operations\nwrp_cte::core::Tag tag("my_data");\nstd::vector<char> data = LoadData();\ntag.PutBlob("item", data.data(), data.size());  // Safe - automatic cleanup\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Shared Memory Operations:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Manual shared memory management - more control\n// NOTE: AllocateBuffer is NOT templated - it returns hipc::FullPtr<char>\nauto shm_buffer = CHI_IPC->AllocateBuffer(data_size);\nmemcpy(shm_buffer.ptr_, raw_data, data_size);\ntag.PutBlob("item", shm_buffer.shm_, data_size, 0, score);\n// shm_buffer automatically cleaned up when it goes out of scope\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Asynchronous Operations:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Always keep shared memory alive until async task completes\nstd::vector<hipc::FullPtr<char>> buffers;  // Keep alive\nstd::vector<hipc::FullPtr<PutBlobTask>> tasks;\n\nfor (auto& data_chunk : data_chunks) {\n    auto buffer = CHI_IPC->AllocateBuffer(data_chunk.size());\n    memcpy(buffer.ptr_, data_chunk.data(), data_chunk.size());\n\n    auto task = tag.AsyncPutBlob("chunk", buffer.shm_, data_chunk.size());\n\n    buffers.push_back(std::move(buffer));  // Keep alive!\n    tasks.push_back(task);\n}\n\n// Wait for completion and cleanup\nfor (auto& task : tasks) {\n    task->Wait();\n    CHI_IPC->DelTask(task);\n}\n// buffers automatically cleaned up here\n'})}),"\n",(0,i.jsx)(n.h4,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Blob Scoring Guidelines:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Use scores 0.8-1.0 for frequently accessed "hot" data'}),"\n",(0,i.jsx)(n.li,{children:'Use scores 0.4-0.7 for occasionally accessed "warm" data'}),"\n",(0,i.jsx)(n.li,{children:'Use scores 0.0-0.3 for archival "cold" data'}),"\n",(0,i.jsx)(n.li,{children:"CTE uses scores for intelligent placement across storage tiers"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Batch Operations:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Efficient: Group related operations\nwrp_cte::core::Tag batch_tag("batch_job");\nfor (const auto& item : batch_items) {\n    batch_tag.PutBlob(item.name, item.data, item.size);\n}\n\n// Less efficient: Multiple tags with few operations each\n// Creates overhead for tag lookup and context switching\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Size Queries:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Efficient: Check size before allocating retrieval buffer\nchi::u64 blob_size = tag.GetBlobSize("large_blob");\nif (blob_size > 0) {\n    auto buffer = CHI_IPC->AllocateBuffer(blob_size);\n    tag.GetBlob("large_blob", buffer.shm_, blob_size);\n}\n\n// Less efficient: Allocate maximum possible size\n// auto buffer = CHI_IPC->AllocateBuffer(MAX_SIZE);  // Wasteful\n'})}),"\n",(0,i.jsx)(n.h4,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Tag Wrapper (Exception-based):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'try {\n    wrp_cte::core::Tag tag("dataset");\n    tag.PutBlob("data", buffer, size);\n    \n    chi::u64 stored_size = tag.GetBlobSize("data");\n    if (stored_size != size) {\n        throw std::runtime_error("Size mismatch after storage");\n    }\n    \n} catch (const std::exception& e) {\n    std::cerr << "Storage operation failed: " << e.what() << "\\n";\n    // Automatic cleanup via RAII\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Direct Client (Return Code-based):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'auto *client = WRP_CTE_CLIENT;\nhipc::MemContext mctx;\n\nTagId tag_id = client->GetOrCreateTag(mctx, "dataset");\nbool success = client->PutBlob(mctx, tag_id, "data",\n                               0, size, buffer, 0.5f, 0);\n\nif (!success) {\n    std::cerr << "PutBlob failed\\n";\n    return false;\n}\n\nchi::u64 stored_size = client->GetBlobSize(mctx, tag_id, "data");\nif (stored_size != size) {\n    std::cerr << "Size mismatch: expected " << size << ", got " << stored_size << "\\n";\n    return false;\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"thread-safety-considerations",children:"Thread Safety Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Both Tag wrapper and Client are thread-safe"}),"\n",(0,i.jsx)(n.li,{children:"Multiple threads can safely share the same Tag or Client instance"}),"\n",(0,i.jsxs)(n.li,{children:["Shared memory buffers (",(0,i.jsx)(n.code,{children:"hipc::FullPtr"}),") should not be shared between threads"]}),"\n",(0,i.jsxs)(n.li,{children:["Each thread should use its own ",(0,i.jsx)(n.code,{children:"hipc::MemContext"})," for optimal performance"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"multi-node-deployment",children:"Multi-Node Deployment"}),"\n",(0,i.jsx)(n.p,{children:"CTE Core supports distributed deployment across multiple nodes:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Configure Chimaera for multi-node operation"}),"\n",(0,i.jsxs)(n.li,{children:["Use appropriate PoolQuery values:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"chi::PoolQuery::Local()"})," - Local node only"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"chi::PoolQuery::Global()"})," - All nodes"]}),"\n",(0,i.jsx)(n.li,{children:"Custom pool queries for specific node groups"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"custom-data-placement-algorithms",children:"Custom Data Placement Algorithms"}),"\n",(0,i.jsx)(n.p,{children:"Extend the DPE (Data Placement Engine) by implementing custom placement strategies:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Inherit from the base DPE class"}),"\n",(0,i.jsx)(n.li,{children:"Implement placement logic based on target metrics"}),"\n",(0,i.jsx)(n.li,{children:"Register the new DPE type in configuration"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-optimization-1",children:"Performance Optimization"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch Operations"}),": Use async APIs for multiple operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Score-based Placement"}),": Set appropriate scores (0-1) for data temperature"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Target Balancing"}),": Monitor and rebalance based on target metrics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue Tuning"}),": Adjust lane counts and priorities based on workload"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"All operations return result codes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0"}),": Success"]}),"\n",(0,i.jsx)(n.li,{children:"Non-zero: Error (specific codes depend on operation)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Always check return values and handle errors appropriately:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'chi::u32 result = cte_client.RegisterTarget(...);\nif (result != 0) {\n    // Handle error\n    std::cerr << "Failed to register target, error code: " << result << "\\n";\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CTE Core client operations are thread-safe"}),"\n",(0,i.jsx)(n.li,{children:"Multiple threads can share a client instance"}),"\n",(0,i.jsx)(n.li,{children:"Async operations are particularly suitable for multi-threaded usage"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CTE Core uses shared memory for zero-copy data transfer"}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"hipc::Pointer"})," type represents shared memory locations"]}),"\n",(0,i.jsxs)(n.li,{children:["Memory contexts (",(0,i.jsx)(n.code,{children:"hipc::MemContext"}),") manage allocation lifecycle"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Initialization Failures"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ensure Chimaera runtime is initialized first"}),"\n",(0,i.jsx)(n.li,{children:"Check configuration file path and format"}),"\n",(0,i.jsx)(n.li,{children:"Verify storage paths have appropriate permissions"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Target Registration Errors"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Confirm target path exists and is writable"}),"\n",(0,i.jsx)(n.li,{children:"Check available disk space"}),"\n",(0,i.jsx)(n.li,{children:"Verify bdev type matches storage medium"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Blob Operations Failing"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ensure tag exists before blob operations"}),"\n",(0,i.jsx)(n.li,{children:"Check target has sufficient space"}),"\n",(0,i.jsx)(n.li,{children:"Verify data pointers are valid shared memory"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Performance Issues"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Monitor target statistics regularly"}),"\n",(0,i.jsx)(n.li,{children:"Adjust worker count based on workload"}),"\n",(0,i.jsx)(n.li,{children:"Tune queue configurations"}),"\n",(0,i.jsx)(n.li,{children:"Consider data placement strategy"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"debug-logging",children:"Debug Logging"}),"\n",(0,i.jsx)(n.p,{children:"Enable debug logging by setting environment variables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"export CHIMAERA_LOG_LEVEL=DEBUG\nexport CTE_LOG_LEVEL=DEBUG\n"})}),"\n",(0,i.jsx)(n.h3,{id:"metrics-collection",children:"Metrics Collection"}),"\n",(0,i.jsx)(n.p,{children:"Use the telemetry API to collect performance metrics:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Continuous monitoring loop\nwhile (running) {\n    auto telemetry = cte_client.PollTelemetryLog(mctx, last_logical_time);\n    ProcessTelemetry(telemetry);\n    \n    if (!telemetry.empty()) {\n        last_logical_time = telemetry.back().logical_time_;\n    }\n    \n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"api-stability-and-versioning",children:"API Stability and Versioning"}),"\n",(0,i.jsx)(n.p,{children:"CTE Core follows semantic versioning:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Major version: Breaking API changes"}),"\n",(0,i.jsx)(n.li,{children:"Minor version: New features, backward compatible"}),"\n",(0,i.jsx)(n.li,{children:"Patch version: Bug fixes"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Check version compatibility:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Version macros (defined in headers)\n#if CTE_CORE_VERSION_MAJOR >= 1 && CTE_CORE_VERSION_MINOR >= 0\n    // Use newer API features\n#endif\n"})}),"\n",(0,i.jsx)(n.h2,{id:"support-and-resources",children:"Support and Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": This document and inline API documentation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": See ",(0,i.jsx)(n.code,{children:"test/unit/"})," directory for comprehensive examples"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration"}),": Example configs in ",(0,i.jsx)(n.code,{children:"config/"})," directory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Issues"}),": Report bugs via project issue tracker"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);