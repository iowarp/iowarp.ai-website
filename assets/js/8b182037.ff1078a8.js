"use strict";(globalThis.webpackChunkiowarp_site=globalThis.webpackChunkiowarp_site||[]).push([[8482],{3278:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"sdk/interprocess","title":"Hermes Shared Memory (CTE)","description":"IoWarp","source":"@site/docs/sdk/1.interprocess.md","sourceDirName":"sdk","slug":"/sdk/interprocess","permalink":"/docs/sdk/interprocess","draft":false,"unlisted":false,"editUrl":"https://github.com/iowarp/iowarp.github.io/tree/main/docs/sdk/1.interprocess.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MCP Servers","permalink":"/docs/agent-toolkit/mcp"},"next":{"title":"Chimaera Module Development Guide","permalink":"/docs/sdk/runtime_modules"}}');var r=l(4848),a=l(8453);const o={},i="Hermes Shared Memory (CTE)",s={},c=[{value:"Linking",id:"linking",level:2},{value:"Overview",id:"overview",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"FullPtr&lt;T, PointerT&gt;",id:"fullptrt-pointert",level:3},{value:"Memory Context",id:"memory-context",level:3},{value:"Allocator Types",id:"allocator-types",level:2},{value:"1. StackAllocator",id:"1-stackallocator",level:3},{value:"2. MallocAllocator",id:"2-mallocallocator",level:3},{value:"3. ScalablePageAllocator",id:"3-scalablepageallocator",level:3},{value:"4. ThreadLocalAllocator",id:"4-threadlocalallocator",level:3},{value:"Core API Functions",id:"core-api-functions",level:2},{value:"Allocation Functions",id:"allocation-functions",level:3},{value:"Basic Allocation",id:"basic-allocation",level:4},{value:"Aligned Allocation",id:"aligned-allocation",level:4},{value:"Reallocation",id:"reallocation",level:4},{value:"Deallocation",id:"deallocation",level:4},{value:"Object-Oriented API",id:"object-oriented-api",level:2},{value:"Single Object Operations",id:"single-object-operations",level:3},{value:"Object Construction",id:"object-construction",level:4},{value:"Object Destruction",id:"object-destruction",level:4},{value:"Array Object Operations",id:"array-object-operations",level:3},{value:"Array Construction",id:"array-construction",level:4},{value:"Array Reallocation",id:"array-reallocation",level:4},{value:"Array Destruction",id:"array-destruction",level:4},{value:"Advanced Usage Patterns",id:"advanced-usage-patterns",level:2},{value:"Working with Custom Types",id:"working-with-custom-types",level:3},{value:"Pointer Conversion and Management",id:"pointer-conversion-and-management",level:3},{value:"Multi-threaded Usage",id:"multi-threaded-usage",level:3},{value:"Memory Backend Integration",id:"memory-backend-integration",level:2},{value:"Allocator Setup",id:"allocator-setup",level:3},{value:"Custom Headers",id:"custom-headers",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Choosing the Right Allocator",id:"choosing-the-right-allocator",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Memory Leak Detection",id:"memory-leak-detection",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Migration Guide",id:"migration-guide",level:2},{value:"Examples Summary",id:"examples-summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"hermes-shared-memory-cte",children:"Hermes Shared Memory (CTE)"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"http://github.com/iowarp",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/badge/IoWarp-GitHub-blue.svg",alt:"IoWarp"})}),"\n",(0,r.jsx)(n.a,{href:"https://grc.iit.edu/",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/badge/GRC-Website-blue.svg",alt:"GRC"})}),"\n",(0,r.jsx)(n.a,{href:"https://isocpp.org/",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/badge/C++-17-blue.svg",alt:"C++"})}),"\n",(0,r.jsx)(n.a,{href:"https://developer.nvidia.com/cuda-zone",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/badge/CUDA-Compatible-green.svg",alt:"CUDA"})}),"\n",(0,r.jsx)(n.a,{href:"https://rocmdocs.amd.com/",children:(0,r.jsx)(n.img,{src:"https://img.shields.io/badge/ROCm-Compatible-red.svg",alt:"ROCm"})})]}),"\n",(0,r.jsx)(n.p,{children:"A high-performance shared memory library containing data structures and synchronization primitives compatible with shared memory, CUDA, and ROCm."}),"\n",(0,r.jsx)(n.h2,{id:"linking",children:"Linking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"find_package(iowarp-core CONFIG)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Hermes Shared Memory (HSHM) allocation API provides a sophisticated memory management system designed for high-performance shared memory applications. The API supports multiple allocator types, type-safe memory operations, and seamless integration between process-local and shared memory pointers."}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"fullptrt-pointert",children:"FullPtr<T, PointerT>"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"FullPtr"})," is the fundamental abstraction that encapsulates both process-local and shared memory pointers:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T, typename PointerT = Pointer>\nstruct FullPtr {\n    T* ptr_;           // Process-local pointer (fast access)\n    PointerT shm_;     // Shared memory pointer (serializable)\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dual representation"}),": Contains both fast process-local pointer and serializable shared memory offset"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type safety"}),": Template-based type checking at compile time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conversion support"}),": Easy casting between different types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Null checking"}),": Built-in null pointer detection"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"memory-context",children:"Memory Context"}),"\n",(0,r.jsx)(n.p,{children:"Memory operations can benefit from a context that provides thread-local information. :"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class MemContext {\npublic:\n    ThreadId tid_ = ThreadId::GetNull();  // Thread identifier for thread-local allocators\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"For the default context, we have a macro:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"HSHM_MCTX\n"})}),"\n",(0,r.jsx)(n.p,{children:"This should be fine for the vast majority of allocations."}),"\n",(0,r.jsx)(n.h2,{id:"allocator-types",children:"Allocator Types"}),"\n",(0,r.jsx)(n.h3,{id:"1-stackallocator",children:"1. StackAllocator"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use case"}),": Simple linear allocation, no deallocation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Fastest allocation (O(1))"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limitation"}),": No individual deallocation support"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-mallocallocator",children:"2. MallocAllocator"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use case"}),": General-purpose allocation using system malloc"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Standard system allocation performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Features"}),": Full malloc/free semantics"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-scalablepageallocator",children:"3. ScalablePageAllocator"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use case"}),": High-performance page-based allocation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Fast allocation with good fragmentation control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Features"}),": Thread-safe, supports reallocation"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-threadlocalallocator",children:"4. ThreadLocalAllocator"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use case"}),": Thread-local caching for reduced contention"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": Excellent multi-threaded performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Features"}),": Per-thread memory pools, automatic thread management"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-api-functions",children:"Core API Functions"}),"\n",(0,r.jsx)(n.h3,{id:"allocation-functions",children:"Allocation Functions"}),"\n",(0,r.jsx)(n.h4,{id:"basic-allocation",children:"Basic Allocation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T = void, typename PointerT = Pointer>\nFullPtr<T, PointerT> Allocate(const MemContext &ctx, size_t size);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Allocate 1024 bytes\nauto full_ptr = alloc->template Allocate<void>(HSHM_DEFAULT_MEM_CTX, 1024);\nvoid* ptr = full_ptr.ptr_;         // Process-local pointer\nPointer shm_ptr = full_ptr.shm_;   // Shared memory pointer\n\n// Type-specific allocation\nauto int_ptr = alloc->template Allocate<int>(HSHM_DEFAULT_MEM_CTX, sizeof(int) * 100);\nint* ints = int_ptr.ptr_;          // Direct access to int array\n"})}),"\n",(0,r.jsx)(n.h4,{id:"aligned-allocation",children:"Aligned Allocation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T = void, typename PointerT = Pointer>\nFullPtr<T, PointerT> AlignedAllocate(const MemContext &ctx, size_t size, size_t alignment);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Allocate 4KB page-aligned memory\nauto aligned_ptr = alloc->template AlignedAllocate<char>(\n    HSHM_DEFAULT_MEM_CTX, 4096, 4096);\nchar* page = aligned_ptr.ptr_;\nassert(((uintptr_t)page % 4096) == 0);  // Verify alignment\n"})}),"\n",(0,r.jsx)(n.h4,{id:"reallocation",children:"Reallocation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T = void, typename PointerT = Pointer>\nFullPtr<T, PointerT> Reallocate(const MemContext &ctx, \n                                FullPtr<T, PointerT> &old_ptr, \n                                size_t new_size);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// Initial allocation\nauto data = alloc->template Allocate<char>(HSHM_DEFAULT_MEM_CTX, 1024);\nstrcpy(data.ptr_, "Hello, World!");\n\n// Expand to larger size\nauto expanded = alloc->template Reallocate<char>(HSHM_DEFAULT_MEM_CTX, data, 2048);\n// Original data is preserved\nassert(strcmp(expanded.ptr_, "Hello, World!") == 0);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"deallocation",children:"Deallocation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T = void, typename PointerT = Pointer>\nvoid Free(const MemContext &ctx, FullPtr<T, PointerT> &ptr);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"auto memory = alloc->template Allocate<int>(HSHM_DEFAULT_MEM_CTX, 1000 * sizeof(int));\n// Use the memory...\nalloc->template Free<int>(HSHM_DEFAULT_MEM_CTX, memory);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"object-oriented-api",children:"Object-Oriented API"}),"\n",(0,r.jsx)(n.h3,{id:"single-object-operations",children:"Single Object Operations"}),"\n",(0,r.jsx)(n.h4,{id:"object-construction",children:"Object Construction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T, typename ...Args>\nFullPtr<T> NewObj(const MemContext &ctx, Args&&... args);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Create a std::vector with initial capacity\nauto vec_ptr = alloc->NewObj<std::vector<int>>(HSHM_DEFAULT_MEM_CTX, 100);\nvec_ptr.ptr_->push_back(42);\nvec_ptr.ptr_->push_back(24);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"object-destruction",children:"Object Destruction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nvoid DelObj(const MemContext &ctx, FullPtr<T> &ptr);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'auto obj = alloc->NewObj<std::string>(HSHM_DEFAULT_MEM_CTX, "Hello HSHM!");\n// Use the object...\nalloc->DelObj(HSHM_DEFAULT_MEM_CTX, obj);  // Calls destructor and frees memory\n'})}),"\n",(0,r.jsx)(n.h3,{id:"array-object-operations",children:"Array Object Operations"}),"\n",(0,r.jsx)(n.h4,{id:"array-construction",children:"Array Construction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nFullPtr<T> NewObjs(const MemContext &ctx, size_t count);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Create array of 50 integers\nauto int_array = alloc->NewObjs<int>(HSHM_DEFAULT_MEM_CTX, 50);\nfor (int i = 0; i < 50; ++i) {\n    int_array.ptr_[i] = i * 2;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"array-reallocation",children:"Array Reallocation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nFullPtr<T> ReallocateObjs(const MemContext &ctx, FullPtr<T> &ptr, size_t new_count);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'auto objects = alloc->NewObjs<std::string>(HSHM_DEFAULT_MEM_CTX, 10);\n// Initialize strings...\nfor (int i = 0; i < 10; ++i) {\n    new (objects.ptr_ + i) std::string("Item " + std::to_string(i));\n}\n\n// Expand array to 20 elements\nobjects = alloc->ReallocateObjs<std::string>(HSHM_DEFAULT_MEM_CTX, objects, 20);\n'})}),"\n",(0,r.jsx)(n.h4,{id:"array-destruction",children:"Array Destruction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename T>\nvoid DelObjs(const MemContext &ctx, FullPtr<T> &ptr, size_t count);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-usage-patterns",children:"Advanced Usage Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"working-with-custom-types",children:"Working with Custom Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'struct CustomData {\n    int id;\n    char name[32];\n    \n    CustomData(int i, const char* n) : id(i) {\n        strncpy(name, n, 31);\n        name[31] = \'\\0\';\n    }\n};\n\n// Allocate and construct custom object\nauto custom = alloc->NewObj<CustomData>(HSHM_DEFAULT_MEM_CTX, 42, "MyObject");\nprintf("Created object: id=%d, name=%s\\n", custom.ptr_->id, custom.ptr_->name);\nalloc->DelObj(HSHM_DEFAULT_MEM_CTX, custom);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pointer-conversion-and-management",children:"Pointer Conversion and Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Allocate FullPtr\nFullPtr<void> orig_ptr = alloc->Allocate(HSHM_MCTX, 1024);\n\n// Create FullPtr from private pointer \n// This will automatically determine the shared pointer\nFullPtr<void> full_ptr(orig_ptr.ptr_);\n\n// Create FullPtr from shared pointer\n// This will automatically determine the private pionter.\nFullPtr<void> full_ptr2(orig_ptr.shm_);\n\n// Type casting\nFullPtr<int> int_ptr = full_ptr.Cast<int>();\nFullPtr<char> char_ptr = full_ptr.Cast<char>();\n\n// Null checking\nif (!full_ptr.IsNull()) {\n    // Safe to use pointer\n    memset(full_ptr.ptr_, 0, 1024);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"multi-threaded-usage",children:"Multi-threaded Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Thread-local allocator example\nvoid worker_thread(ThreadLocalAllocator* alloc, int thread_id) {\n    MemContext ctx(ThreadId(thread_id));\n    \n    // Each thread gets its own memory pool\n    auto local_data = alloc->template Allocate<WorkerData>(ctx, sizeof(WorkerData));\n    \n    // Perform thread-local work...\n    process_data(local_data.ptr_);\n    \n    // Cleanup\n    alloc->template Free<WorkerData>(ctx, local_data);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"memory-backend-integration",children:"Memory Backend Integration"}),"\n",(0,r.jsx)(n.h3,{id:"allocator-setup",children:"Allocator Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include "hermes_shm/memory/memory_manager.h"\n\n// Initialize memory backend\nauto mem_manager = HSHM_MEMORY_MANAGER;\nmem_manager->CreateBackendWithUrl<hipc::PosixShmMmap>(\n    hipc::MemoryBackendId::Get(0), \n    hshm::Unit<size_t>::Gigabytes(1), \n    "my_shared_memory"\n);\n\n// Create allocator\nAllocatorId alloc_id(1, 0);\nmem_manager->CreateAllocator<hipc::ScalablePageAllocator>(\n    hipc::MemoryBackendId::Get(0), \n    alloc_id, \n    0  // No custom header\n);\n\n// Get allocator instance\nauto alloc = mem_manager->GetAllocator<hipc::ScalablePageAllocator>(alloc_id);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-headers",children:"Custom Headers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct MyAllocatorHeader {\n    uint64_t magic_number;\n    size_t allocation_count;\n};\n\n// Create allocator with custom header\nmem_manager->CreateAllocator<hipc::ScalablePageAllocator>(\n    hipc::MemoryBackendId::Get(0), \n    alloc_id, \n    sizeof(MyAllocatorHeader)\n);\n\n// Access custom header\nauto header = alloc->template GetCustomHeader<MyAllocatorHeader>();\nheader->magic_number = 0xDEADBEEF;\nheader->allocation_count = 0;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"choosing-the-right-allocator",children:"Choosing the Right Allocator"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"StackAllocator"}),": Best for temporary, short-lived allocations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ThreadLocalAllocator"}),": Optimal for multi-threaded applications with frequent allocations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ScalablePageAllocator"}),": Good general-purpose choice with reallocation support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MallocAllocator"}),": Use when system malloc behavior is required"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize Allocations"}),": Batch allocate when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Appropriate Types"}),": Specify template parameters for better type safety"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread Context"}),": Always provide appropriate MemContext for thread-local allocators"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Tracking"}),": Enable ",(0,r.jsx)(n.code,{children:"HSHM_ALLOC_TRACK_SIZE"})," for debugging memory leaks"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"memory-leak-detection",children:"Memory Leak Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Check for memory leaks\nsize_t before = alloc->GetCurrentlyAllocatedSize();\n{\n    auto temp = alloc->template Allocate<char>(HSHM_DEFAULT_MEM_CTX, 1024);\n    // Use memory...\n    alloc->template Free<char>(HSHM_DEFAULT_MEM_CTX, temp);\n}\nsize_t after = alloc->GetCurrentlyAllocatedSize();\nassert(before == after);  // No memory leak\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"The allocator API throws exceptions for error conditions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'try {\n    // This may throw if out of memory\n    auto huge_alloc = alloc->template Allocate<char>(HSHM_DEFAULT_MEM_CTX, SIZE_MAX);\n} catch (const hshm::Error& e) {\n    if (e.code() == hshm::ErrorCode::OUT_OF_MEMORY) {\n        printf("Out of memory: requested=%zu, available=%zu\\n", \n               SIZE_MAX, alloc->GetCurrentlyAllocatedSize());\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"migration-guide",children:"Migration Guide"}),"\n",(0,r.jsx)(n.p,{children:"When migrating from older versions:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Template Parameters"}),": Add explicit template parameters to allocation functions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FullPtr Usage"}),": Replace separate pointer and shared memory offset handling with FullPtr"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Context"}),": Ensure proper MemContext is passed to all operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety"}),": Leverage template parameters for compile-time type checking"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"examples-summary",children:"Examples Summary"}),"\n",(0,r.jsx)(n.p,{children:"The API provides a comprehensive memory management solution with:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Type-safe allocation and deallocation"}),"\n",(0,r.jsx)(n.li,{children:"Support for both raw memory and constructed objects"}),"\n",(0,r.jsx)(n.li,{children:"Multiple allocator implementations for different use cases"}),"\n",(0,r.jsx)(n.li,{children:"Seamless integration with shared memory systems"}),"\n",(0,r.jsx)(n.li,{children:"Thread-safe operations with minimal contention"}),"\n",(0,r.jsx)(n.li,{children:"Built-in memory leak detection and debugging support"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>o,x:()=>i});var t=l(6540);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);